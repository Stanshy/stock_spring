# DOC-01-M06 資料管理模組 (Data Management Module)

## 文件資訊
- **文件編號**: DOC-01-M06
- **模組名稱**: 資料管理模組 (Data Management Module)
- **模組代碼**: M06
- **版本**: v2.0
- **建立日期**: 2025-12-22
- **最後更新**: 2025-12-24
- **文件狀態**: Draft
- **負責人**: [chris]
- **依賴模組**: 無（基礎模組）
- **技術棧**: PostgreSQL 15+ / JPA + MyBatis / Redis 7.0

---

## 📑 目錄

1. [模組概述](#1-模組概述)
2. [功能需求](#2-功能需求)
3. [資料設計](#3-資料設計)
4. [API 設計](#4-api-設計)
5. [資料流設計](#5-資料流設計)
6. [Job/排程設計](#6-job排程設計)
7. [業務邏輯設計](#7-業務邏輯設計)
8. [整合點](#8-整合點)
9. [效能考量](#9-效能考量)
10. [測試準則](#10-測試準則)

---

## 1. 模組概述

### 1.1 模組定位

資料管理模組是整個系統的**基礎層（Layer 1）**，負責：
- 從外部資料源獲取股票相關資料
- 清洗、驗證資料品質
- 儲存至 PostgreSQL 資料庫
- 提供資料查詢 API 給其他模組使用
- 管理資料生命週期（歸檔、清理）

**核心價值**: 為所有上層模組（分析、信號、選股等）提供乾淨、正確、即時的資料基礎。

### 1.2 模組目標

- ✅ 自動化資料獲取：每日自動同步台股股價、財報、籌碼資料
- ✅ 資料品質保證：確保資料完整、準確、一致（參照總綱 4.7 資料品質規範）
- ✅ 高效資料存取：透過快取與索引優化查詢效能
- ✅ 多資料源支援：整合 Yahoo Finance、證交所、FinMind 等資料源
- ✅ 容錯與備援：資料源失敗時自動切換備援
- ✅ 冪等性保證：所有 Job 遵守總綱 4.5 Job 模型的冪等性要求

### 1.3 功能範圍

**包含功能**:
1. 股票基本資料管理（股票代碼、名稱、產業分類）
2. 股價歷史資料同步（開高低收量）
3. 財務報表資料同步（季報、年報）
4. 籌碼資料同步（三大法人、融資融券、董監持股）
5. 交易日曆管理
6. 資料品質檢核（參照總綱 4.7）
7. 資料更新排程（參照總綱 4.5 Job 模型）

**不包含功能**:
- 資料分析與計算（由 M07, M08, M09 負責）
- 信號產生（由 M13 負責）
- 即時報價串流（使用延遲報價）

### 1.4 依賴關係

**上游依賴**: 無（Layer 1 基礎模組）

**下游依賴**: 
- M07 技術分析模組
- M08 基本面分析模組
- M09 籌碼分析模組
- M10 技術型態辨識模組
- M12 總經與產業分析模組
- M13 信號判斷引擎
- M14 選股引擎
- M16 回測系統
- M17 風險管理模組
- M18 投資組合管理

**外部依賴**:
- Yahoo Finance API
- 台灣證券交易所公開資訊
- 公開資訊觀測站
- FinMind API（可選）

---

## 2. 功能需求

### 2.1 功能清單

| 功能編號 | 功能名稱 | 優先級 | 說明 | 持久層 |
|---------|---------|-------|------|-------|
| F-M06-001 | 股票清單管理 | P0 | 維護台股上市櫃公司清單 | JPA |
| F-M06-002 | 股價資料同步 | P0 | 每日同步股價資料（OHLCV） | MyBatis |
| F-M06-003 | 財報資料同步 | P1 | 每季同步財務報表資料 | MyBatis |
| F-M06-004 | 籌碼資料同步 | P1 | 每日同步三大法人、融資融券資料 | MyBatis |
| F-M06-005 | 交易日曆管理 | P0 | 維護交易日與假日資訊 | JPA |
| F-M06-006 | 資料品質檢核 | P0 | 驗證資料完整性與一致性 | MyBatis |
| F-M06-007 | 資料查詢 API | P0 | 提供股票資料查詢介面 | JPA + MyBatis |
| F-M06-008 | 資料更新排程 | P0 | 定時自動執行資料同步 | - |
| F-M06-009 | 資料補齊機制 | P1 | 補齊缺失的歷史資料 | MyBatis |
| F-M06-010 | 資料源備援 | P2 | 主資料源失敗時切換備援 | - |

### 2.2 用例說明

#### UC-M06-001: 每日股價資料同步

**參與者**: 系統排程器  
**前置條件**: 
- 當日為交易日
- 收盤後（15:00 之後）

**主要流程**:
1. 系統於每日 15:00 觸發股價同步 Job（參照總綱 4.5 Job 模型）
2. 建立 Job 執行記錄（job_executions 表，status='RUNNING'）
3. 從 Yahoo Finance 獲取所有上市櫃股票當日股價
4. 驗證資料品質（參照總綱 4.7 資料品質規範）
   - 四價關係：`low <= open,close <= high`
   - 價格變動：不超過 ±10%（漲跌停幅度）
   - 成交量非負
5. 使用 MyBatis 批次 UPSERT 儲存至 stock_prices 表
6. 更新 Redis 快取（熱門股票）
7. 更新 Job 執行記錄（status='SUCCESS', end_time, statistics）
8. 發布 StockPriceUpdated 事件

**後置條件**:
- 當日股價資料已儲存
- Job 執行記錄狀態為 SUCCESS
- Redis 快取已更新
- 事件已發布給訂閱者

**替代流程**:
- 4a. 資料驗證失敗 → 記錄到 data_quality_issues 表，跳過該股票，繼續處理其他股票
- 3a. Yahoo Finance 失敗 → 切換至備援資料源（證交所 API）
- 5a. 資料庫錯誤 → 回滾交易，更新 Job 狀態為 FAILED，觸發重試機制

**冪等性設計**:
- 使用 PostgreSQL `ON CONFLICT ... DO UPDATE`
- 重複執行同一日期的 Job 不會產生重複資料
- Job 參數包含 trade_date，確保可追溯與重跑

---

#### UC-M06-002: 查詢股票歷史股價

**參與者**: 其他模組（M07, M08, M13 等）  
**前置條件**: 股票代碼存在

**主要流程**:
1. 接收查詢請求（stock_id, start_date, end_date）
2. 參數驗證（日期格式、範圍合理性）
3. 檢查 Redis 快取（快取 Key: `stock:prices:{stock_id}:{start_date}:{end_date}`）
4. 若快取命中 → 直接返回
5. 若快取未命中 → 使用 JPA Repository 查詢 PostgreSQL
6. 將查詢結果序列化並寫入 Redis 快取
7. 返回結果（遵守總綱 4.4 API Response 格式）

**後置條件**:
- 返回符合條件的股價列表
- 熱資料已快取至 Redis

**替代流程**:
- 1a. 股票代碼不存在 → 返回錯誤碼 M06_STOCK_001（參照總綱 4.4）
- 2a. 參數驗證失敗 → 返回錯誤碼 M06_PARAM_001
- 5a. 資料庫查詢失敗 → 返回錯誤碼 M06_DB_001

---

#### UC-M06-003: 財報資料同步

**參與者**: 系統排程器  
**前置條件**: 
- 財報公告日期已到
- 公開資訊觀測站資料可用

**主要流程**:
1. 系統偵測新財報公告（每季財報公告後 3 個工作日內）
2. 建立 Job 執行記錄（SYNC_FINANCIAL_DATA）
3. 從公開資訊觀測站下載財報資料（XBRL 格式優先）
4. 解析 XBRL/HTML 資料
5. 驗證資料完整性（參照總綱 4.7）
   - 必填欄位檢查（revenue, net_income, total_assets 等）
   - 資產負債平衡：`total_assets = total_liabilities + equity`（容許 ±1% 誤差）
6. 使用 MyBatis 批次儲存至 financial_statements 表
7. 更新 Job 執行記錄（SUCCESS）
8. 發布 FinancialStatementUpdated 事件

**後置條件**:
- 最新財報資料已儲存
- Job 執行記錄已更新
- 事件已發布

**替代流程**:
- 3a. 下載失敗 → 重試 3 次，仍失敗則記錄錯誤
- 4a. 解析失敗 → 記錄 data_quality_issues，標記為 MANUAL_REVIEW
- 6a. 資料庫錯誤 → 回滾交易，Job 狀態設為 FAILED

---

### 2.3 業務規則

#### BR-M06-001: 股價資料驗證規則
遵守總綱 4.7 資料品質規範：

**完整性**:
- stock_id, trade_date, open_price, high_price, low_price, close_price, volume 不可為 NULL

**準確性**:
- 價格 >= 0
- 成交量 >= 0
- 成交金額 = close_price × volume（容許 ±1% 誤差）

**一致性**:
- 四價關係：`low_price <= open_price` AND `low_price <= close_price` AND `high_price >= open_price` AND `high_price >= close_price`

**有效性**:
- 台股漲跌幅限制 ±10%（相較於前一交易日收盤價）
- 交易日期必須為有效交易日（查詢 trading_calendar 表）

**唯一性**:
- (stock_id, trade_date) 為唯一鍵

---

#### BR-M06-002: 資料更新頻率
遵守總綱 4.5 Job 排程規範：

| 資料類型 | 更新頻率 | 執行時間 | Job 名稱 |
|---------|---------|---------|---------|
| 股價資料 | 每交易日 | 15:00 | SYNC_STOCK_PRICES |
| 籌碼資料 | 每交易日 | 15:30 | SYNC_CHIP_DATA |
| 財報資料 | 每季財報公告後 | 手動/自動觸發 | SYNC_FINANCIAL_DATA |
| 股票清單 | 每月 1 日 | 08:00 | SYNC_STOCK_LIST |
| 交易日曆 | 每年 1 月 1 日 | 02:00 | SYNC_TRADING_CALENDAR |

---

#### BR-M06-003: 資料保留政策

| 資料類型 | 保留期限 | 歸檔策略 | 清理策略 |
|---------|---------|---------|---------|
| 股價資料 | 20 年 | 使用 PostgreSQL 分區（每年一個分區） | 每年清理 20 年前資料 |
| 財報資料 | 永久 | 不歸檔 | 不清理 |
| 籌碼資料 | 5 年 | 使用分區（每年一個分區） | 每年清理 5 年前資料 |
| Job 執行記錄 | 3 個月 | 每月歸檔到 job_executions_archive | 每月清理 3 個月前資料 |
| 資料品質問題記錄 | 1 年 | 季度歸檔 | 每季清理 1 年前已解決問題 |

---

#### BR-M06-004: 快取策略
參照總綱快取策略：

| 資料類型 | 快取位置 | TTL | 預熱策略 | 失效策略 |
|---------|---------|-----|---------|---------|
| 熱門股票股價（市值前 50） | Redis | 1 小時 | 系統啟動時載入 | Job 完成後主動更新 |
| 一般股票股價 | Redis | 6 小時 | 首次查詢時載入 | LRU 自動淘汰 |
| 財報資料 | Redis | 24 小時 | 不預熱 | 新財報同步後主動更新 |
| 股票清單 | Redis | 24 小時 | 系統啟動時載入 | 股票清單更新後主動更新 |
| 交易日曆 | Redis | 7 天 | 系統啟動時載入 | 年度更新後主動更新 |

**快取 Key 設計**:
```
stock:info:{stock_id}                              → 股票基本資訊
stock:prices:{stock_id}:{start_date}:{end_date}    → 股價範圍查詢
stock:price:{stock_id}:{trade_date}                → 單日股價
stock:financial:{stock_id}:{year}:{quarter}        → 單季財報
stocks:list:active                                 → 活躍股票清單
trading:calendar:{year}                            → 年度交易日曆
```

---

## 3. 資料設計

### 3.1 資料表清單

| 表名 | 說明 | 持久層 | 特殊功能 |
|-----|------|-------|---------|
| stocks | 股票基本資料表 | JPA | 陣列欄位、JSONB |
| stock_prices | 股價歷史資料表 | JPA + MyBatis | 分區、計算欄位 |
| financial_statements | 財務報表資料表 | MyBatis | JSONB、GIN 索引 |
| institutional_trading | 三大法人買賣超資料表 | JPA + MyBatis | 計算欄位 |
| margin_trading | 融資融券資料表 | JPA + MyBatis | 計算欄位 |
| trading_calendar | 交易日曆表 | JPA | 計算欄位 |

### 3.2 資料表設計

#### 3.2.1 stocks (股票基本資料表)

```sql
-- PostgreSQL 建表語法
CREATE TABLE stocks (
    stock_id        VARCHAR(10) PRIMARY KEY,
    stock_name      VARCHAR(50) NOT NULL,
    stock_name_en   VARCHAR(100),
    market_type     VARCHAR(20) NOT NULL CHECK (market_type IN ('TWSE', 'OTC', 'EMERGING')),
    industry        VARCHAR(50),
    sector          VARCHAR(50),
    listing_date    DATE,
    delisting_date  DATE,
    is_active       BOOLEAN DEFAULT TRUE,
    
    -- 基本資訊
    par_value       NUMERIC(10,2),
    issued_shares   BIGINT,
    market_cap      NUMERIC(20,2),
    
    -- 分類標籤（使用 PostgreSQL 陣列型態）
    tags            TEXT[] DEFAULT '{}',
    
    -- 額外資訊（使用 JSONB）
    extra_info      JSONB DEFAULT '{}',
    
    -- 審計欄位
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 約束
    CHECK (issued_shares >= 0),
    CHECK (market_cap >= 0)
);

-- 索引
CREATE INDEX idx_stocks_market_type ON stocks(market_type);
CREATE INDEX idx_stocks_industry ON stocks(industry);
CREATE INDEX idx_stocks_is_active ON stocks(is_active);
CREATE INDEX idx_stocks_tags ON stocks USING GIN(tags);  -- GIN 索引支援陣列查詢
CREATE INDEX idx_stocks_extra_info ON stocks USING GIN(extra_info);  -- GIN 索引支援 JSONB

-- 自動更新 updated_at 觸發器
CREATE TRIGGER update_stocks_updated_at
    BEFORE UPDATE ON stocks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 表註釋
COMMENT ON TABLE stocks IS '股票基本資料表';
COMMENT ON COLUMN stocks.stock_id IS '股票代碼（如 2330）';
COMMENT ON COLUMN stocks.tags IS '股票標籤陣列（如: {半導體, AI, ESG}）';
COMMENT ON COLUMN stocks.extra_info IS '額外資訊 JSONB（如: 網站、董事長等）';
```

**設計說明**:
- 使用 PostgreSQL **陣列型態** (TEXT[]) 儲存股票標籤
- 使用 **JSONB** 儲存額外資訊，彈性擴充
- GIN 索引加速陣列與 JSONB 查詢
- 主鍵為 stock_id

**JSONB 結構範例**:
```json
{
  "website": "https://www.tsmc.com",
  "chairman": "劉德音",
  "ceo": "魏哲家",
  "employee_count": 75000,
  "founded_year": 1987
}
```

**陣列查詢範例**:
```sql
-- 查詢包含特定標籤的股票
SELECT * FROM stocks WHERE 'AI' = ANY(tags);

-- 查詢包含任一標籤的股票
SELECT * FROM stocks WHERE tags && ARRAY['AI', '半導體'];

-- 查詢包含所有標籤的股票
SELECT * FROM stocks WHERE tags @> ARRAY['AI', '半導體'];
```

---

#### 3.2.2 stock_prices (股價歷史資料表)

```sql
-- PostgreSQL 建表語法（使用分區）
CREATE TABLE stock_prices (
    price_id        BIGSERIAL,
    stock_id        VARCHAR(10) NOT NULL,
    trade_date      DATE NOT NULL,
    
    -- OHLCV
    open_price      NUMERIC(10,2) NOT NULL,
    high_price      NUMERIC(10,2) NOT NULL,
    low_price       NUMERIC(10,2) NOT NULL,
    close_price     NUMERIC(10,2) NOT NULL,
    volume          BIGINT NOT NULL,
    
    -- 額外資訊
    turnover        NUMERIC(20,2),
    transactions    INTEGER,
    change_price    NUMERIC(10,2),
    change_percent  NUMERIC(5,2),
    
    -- 技術指標快速查詢欄位（冗餘，由 M07 計算後回寫）
    ma5             NUMERIC(10,2),
    ma20            NUMERIC(10,2),
    volume_ma5      BIGINT,
    
    -- 審計欄位
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (price_id, trade_date),  -- 分區表的主鍵必須包含分區鍵
    UNIQUE (stock_id, trade_date),
    
    -- 約束
    CHECK (open_price >= 0),
    CHECK (high_price >= low_price),
    CHECK (low_price <= open_price),
    CHECK (low_price <= close_price),
    CHECK (high_price >= open_price),
    CHECK (high_price >= close_price),
    CHECK (volume >= 0),
    
    FOREIGN KEY (stock_id) REFERENCES stocks(stock_id) ON DELETE CASCADE
) PARTITION BY RANGE (trade_date);

-- 建立分區（按年份）
CREATE TABLE stock_prices_2023 PARTITION OF stock_prices
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');
    
CREATE TABLE stock_prices_2024 PARTITION OF stock_prices
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
    
CREATE TABLE stock_prices_2025 PARTITION OF stock_prices
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
    
-- 預留未來分區
CREATE TABLE stock_prices_future PARTITION OF stock_prices
    FOR VALUES FROM ('2026-01-01') TO (MAXVALUE);

-- 索引（會自動在每個分區建立）
CREATE INDEX idx_stock_prices_stock_id ON stock_prices(stock_id);
CREATE INDEX idx_stock_prices_trade_date ON stock_prices(trade_date);

-- 自動更新 updated_at 觸發器
CREATE TRIGGER update_stock_prices_updated_at
    BEFORE UPDATE ON stock_prices
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 表註釋
COMMENT ON TABLE stock_prices IS '股價歷史資料表（使用分區優化查詢）';
COMMENT ON COLUMN stock_prices.ma5 IS '5日均線（冗餘欄位，由M07計算）';
```

**設計說明**:
- 使用 PostgreSQL **分區（Partitioning）** 優化大量歷史資料查詢
- 分區策略：按年份 RANGE 分區，查詢時自動裁剪不相關分區
- 使用 UNIQUE (stock_id, trade_date) 確保唯一性
- 預留技術指標冗餘欄位（ma5, ma20），由 M07 計算後回寫
- CHECK 約束保證四價關係

**分區優勢**:
- 查詢特定年份時，只掃描該年份分區，效能大幅提升
- 歸檔舊資料時，直接 DETACH 分區即可
- 維護索引更容易（分區索引較小）

**UPSERT 語法（MyBatis）**:
```sql
INSERT INTO stock_prices (
    stock_id, trade_date, open_price, high_price, low_price, 
    close_price, volume, turnover, transactions, 
    change_price, change_percent
) VALUES (
    '2330', '2024-12-24', 575.00, 582.00, 573.00, 
    580.00, 35000000, 20300000000, 125000, 
    5.00, 0.87
)
ON CONFLICT (stock_id, trade_date)
DO UPDATE SET
    open_price = EXCLUDED.open_price,
    high_price = EXCLUDED.high_price,
    low_price = EXCLUDED.low_price,
    close_price = EXCLUDED.close_price,
    volume = EXCLUDED.volume,
    turnover = EXCLUDED.turnover,
    transactions = EXCLUDED.transactions,
    change_price = EXCLUDED.change_price,
    change_percent = EXCLUDED.change_percent,
    updated_at = CURRENT_TIMESTAMP;
```

---

#### 3.2.3 financial_statements (財務報表資料表)

```sql
-- PostgreSQL 建表語法
CREATE TABLE financial_statements (
    statement_id    BIGSERIAL PRIMARY KEY,
    stock_id        VARCHAR(10) NOT NULL,
    year            INTEGER NOT NULL,
    quarter         SMALLINT NOT NULL CHECK (quarter BETWEEN 1 AND 4),
    report_type     VARCHAR(2) NOT NULL CHECK (report_type IN ('Q', 'A')),
    
    -- 損益表（核心欄位）
    revenue         NUMERIC(20,2),
    operating_income NUMERIC(20,2),
    net_income      NUMERIC(20,2),
    gross_profit    NUMERIC(20,2),
    operating_expense NUMERIC(20,2),
    
    -- 資產負債表（核心欄位）
    total_assets    NUMERIC(20,2),
    total_liabilities NUMERIC(20,2),
    equity          NUMERIC(20,2),
    current_assets  NUMERIC(20,2),
    current_liabilities NUMERIC(20,2),
    
    -- 現金流量表（核心欄位）
    operating_cash_flow NUMERIC(20,2),
    investing_cash_flow NUMERIC(20,2),
    financing_cash_flow NUMERIC(20,2),
    free_cash_flow  NUMERIC(20,2),
    
    -- 每股指標
    eps             NUMERIC(10,2),
    bps             NUMERIC(10,2),
    
    -- 詳細資料（使用 JSONB 儲存完整財報）
    income_statement    JSONB DEFAULT '{}',
    balance_sheet       JSONB DEFAULT '{}',
    cash_flow_statement JSONB DEFAULT '{}',
    financial_ratios    JSONB DEFAULT '{}',
    
    -- 審計欄位
    publish_date    DATE,
    source          VARCHAR(50),
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE (stock_id, year, quarter, report_type),
    FOREIGN KEY (stock_id) REFERENCES stocks(stock_id) ON DELETE CASCADE,
    
    -- 約束
    CHECK (total_assets >= 0),
    CHECK (equity >= 0)
);

-- 索引
CREATE INDEX idx_financial_statements_stock_id ON financial_statements(stock_id);
CREATE INDEX idx_financial_statements_year_quarter ON financial_statements(year, quarter);
CREATE INDEX idx_financial_statements_publish_date ON financial_statements(publish_date);

-- JSONB GIN 索引（加速 JSON 查詢）
CREATE INDEX idx_financial_income_statement ON financial_statements USING GIN(income_statement);
CREATE INDEX idx_financial_balance_sheet ON financial_statements USING GIN(balance_sheet);
CREATE INDEX idx_financial_ratios ON financial_statements USING GIN(financial_ratios);

-- 自動更新 updated_at
CREATE TRIGGER update_financial_statements_updated_at
    BEFORE UPDATE ON financial_statements
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 表註釋
COMMENT ON TABLE financial_statements IS '財務報表資料表（核心欄位+JSONB詳細資料）';
COMMENT ON COLUMN financial_statements.income_statement IS '完整損益表 JSONB';
COMMENT ON COLUMN financial_statements.balance_sheet IS '完整資產負債表 JSONB';
COMMENT ON COLUMN financial_statements.financial_ratios IS '財務比率 JSONB（由M08計算）';
```

**設計說明**:
- **核心欄位**獨立儲存（revenue, net_income 等），查詢效能高
- **詳細資料**使用 JSONB 儲存，彈性擴充
- GIN 索引加速 JSONB 查詢
- 支援 PostgreSQL 原生 JSON 操作符

**JSONB 結構範例**:
```json
{
  "income_statement": {
    "revenue": 1000000,
    "cost_of_goods_sold": 600000,
    "gross_profit": 400000,
    "operating_expenses": {
      "selling_expenses": 100000,
      "general_expenses": 50000,
      "rd_expenses": 80000
    },
    "non_operating_income": 20000,
    "income_before_tax": 190000,
    "income_tax": 30000,
    "net_income": 160000
  },
  
  "financial_ratios": {
    "roe": 15.5,
    "roa": 8.2,
    "gross_margin": 40.0,
    "operating_margin": 19.0,
    "net_margin": 16.0,
    "current_ratio": 1.8,
    "quick_ratio": 1.2,
    "debt_to_equity": 0.5
  }
}
```

**JSONB 查詢範例**（MyBatis）:
```sql
-- 查詢 ROE > 15% 的股票
SELECT 
    stock_id,
    stock_name,
    year,
    quarter,
    (financial_ratios->>'roe')::numeric AS roe
FROM financial_statements f
JOIN stocks s USING (stock_id)
WHERE year = 2024
  AND quarter = 3
  AND (financial_ratios->>'roe')::numeric > 15.0
ORDER BY (financial_ratios->>'roe')::numeric DESC;

-- 查詢包含特定資訊的財報
SELECT * FROM financial_statements
WHERE income_statement @> '{"rd_expenses": 80000}'::jsonb;

-- 查詢是否存在特定欄位
SELECT * FROM financial_statements
WHERE financial_ratios ? 'roe';
```

---

#### 3.2.4 institutional_trading (三大法人買賣超資料表)

```sql
-- PostgreSQL 建表語法
CREATE TABLE institutional_trading (
    trading_id      BIGSERIAL PRIMARY KEY,
    stock_id        VARCHAR(10) NOT NULL,
    trade_date      DATE NOT NULL,
    
    -- 外資（Foreign Investors）
    foreign_buy     BIGINT DEFAULT 0,
    foreign_sell    BIGINT DEFAULT 0,
    foreign_net     BIGINT GENERATED ALWAYS AS (foreign_buy - foreign_sell) STORED,
    
    -- 投信（Investment Trust）
    trust_buy       BIGINT DEFAULT 0,
    trust_sell      BIGINT DEFAULT 0,
    trust_net       BIGINT GENERATED ALWAYS AS (trust_buy - trust_sell) STORED,
    
    -- 自營商（Dealers）
    dealer_buy      BIGINT DEFAULT 0,
    dealer_sell     BIGINT DEFAULT 0,
    dealer_net      BIGINT GENERATED ALWAYS AS (dealer_buy - dealer_sell) STORED,
    
    -- 合計
    total_net       BIGINT GENERATED ALWAYS AS (foreign_net + trust_net + dealer_net) STORED,
    
    -- 審計欄位
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE (stock_id, trade_date),
    FOREIGN KEY (stock_id) REFERENCES stocks(stock_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_institutional_stock_id ON institutional_trading(stock_id);
CREATE INDEX idx_institutional_trade_date ON institutional_trading(trade_date);
CREATE INDEX idx_institutional_foreign_net ON institutional_trading(foreign_net);
CREATE INDEX idx_institutional_total_net ON institutional_trading(total_net);

-- 自動更新 updated_at
CREATE TRIGGER update_institutional_trading_updated_at
    BEFORE UPDATE ON institutional_trading
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 表註釋
COMMENT ON TABLE institutional_trading IS '三大法人買賣超資料表';
COMMENT ON COLUMN institutional_trading.foreign_net IS '外資買賣超（使用 GENERATED COLUMN 自動計算）';
```

**設計說明**:
- 使用 PostgreSQL **GENERATED COLUMN（計算欄位）** 自動計算買賣超
- `STORED` 表示計算結果實際儲存，查詢效能更好
- 索引 foreign_net, total_net 加速籌碼分析查詢
- 買賣超 = 買進 - 賣出，自動維護無需應用程式計算

---

#### 3.2.5 margin_trading (融資融券資料表)

```sql
-- PostgreSQL 建表語法
CREATE TABLE margin_trading (
    margin_id       BIGSERIAL PRIMARY KEY,
    stock_id        VARCHAR(10) NOT NULL,
    trade_date      DATE NOT NULL,
    
    -- 融資（Margin Purchase）
    margin_purchase BIGINT DEFAULT 0,
    margin_sell     BIGINT DEFAULT 0,
    margin_balance  BIGINT DEFAULT 0,
    margin_quota    BIGINT,
    margin_usage_rate NUMERIC(5,2) GENERATED ALWAYS AS 
        (CASE WHEN margin_quota > 0 THEN (margin_balance::numeric / margin_quota * 100) ELSE 0 END) STORED,
    
    -- 融券（Short Selling）
    short_purchase  BIGINT DEFAULT 0,
    short_sell      BIGINT DEFAULT 0,
    short_balance   BIGINT DEFAULT 0,
    short_quota     BIGINT,
    short_usage_rate NUMERIC(5,2) GENERATED ALWAYS AS 
        (CASE WHEN short_quota > 0 THEN (short_balance::numeric / short_quota * 100) ELSE 0 END) STORED,
    
    -- 審計欄位
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE (stock_id, trade_date),
    FOREIGN KEY (stock_id) REFERENCES stocks(stock_id) ON DELETE CASCADE,
    
    -- 約束
    CHECK (margin_balance >= 0),
    CHECK (short_balance >= 0)
);

-- 索引
CREATE INDEX idx_margin_stock_id ON margin_trading(stock_id);
CREATE INDEX idx_margin_trade_date ON margin_trading(trade_date);
CREATE INDEX idx_margin_usage_rate ON margin_trading(margin_usage_rate);

-- 自動更新 updated_at
CREATE TRIGGER update_margin_trading_updated_at
    BEFORE UPDATE ON margin_trading
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 表註釋
COMMENT ON TABLE margin_trading IS '融資融券資料表';
COMMENT ON COLUMN margin_trading.margin_usage_rate IS '融資使用率（自動計算）';
```

**設計說明**:
- 融資/融券使用率使用 GENERATED COLUMN 自動計算
- 使用率 = 餘額 / 額度 × 100

---

#### 3.2.6 trading_calendar (交易日曆表)

```sql
-- PostgreSQL 建表語法
CREATE TABLE trading_calendar (
    calendar_id     SERIAL PRIMARY KEY,
    calendar_date   DATE NOT NULL UNIQUE,
    is_trading_day  BOOLEAN NOT NULL,
    day_type        VARCHAR(20) CHECK (day_type IN ('TRADING', 'WEEKEND', 'HOLIDAY', 'SPECIAL')),
    holiday_name    VARCHAR(100),
    year            INTEGER GENERATED ALWAYS AS (EXTRACT(YEAR FROM calendar_date)) STORED,
    month           INTEGER GENERATED ALWAYS AS (EXTRACT(MONTH FROM calendar_date)) STORED,
    day_of_week     INTEGER GENERATED ALWAYS AS (EXTRACT(DOW FROM calendar_date)) STORED,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_trading_calendar_date ON trading_calendar(calendar_date);
CREATE INDEX idx_trading_calendar_is_trading ON trading_calendar(is_trading_day);
CREATE INDEX idx_trading_calendar_year_month ON trading_calendar(year, month);

-- 表註釋
COMMENT ON TABLE trading_calendar IS '交易日曆表';
COMMENT ON COLUMN trading_calendar.day_of_week IS '星期幾（0=週日, 1=週一, ..., 6=週六）';
```

**設計說明**:
- 使用 GENERATED COLUMN 自動提取年、月、星期
- 支援快速查詢某年某月的交易日

---

### 3.3 資料關聯圖

```
┌──────────────┐
│   stocks     │ ← 股票主表（1）
└──────────────┘
       │
       ├──────────────→ stock_prices (1:N)
       │                - 分區表
       │                - 計算欄位（買賣超）
       │
       ├──────────────→ financial_statements (1:N)
       │                - JSONB 詳細資料
       │                - GIN 索引
       │
       ├──────────────→ institutional_trading (1:N)
       │                - 計算欄位（買賣超）
       │
       └──────────────→ margin_trading (1:N)
                        - 計算欄位（使用率）

trading_calendar (獨立表，無外鍵)
```

---

### 3.4 JPA vs MyBatis 使用場景

| 資料表 | 簡單 CRUD | 複雜查詢 | 批次操作 | 統計查詢 |
|-------|----------|---------|---------|---------|
| stocks | JPA | JPA | JPA | JPA |
| stock_prices | JPA | MyBatis | **MyBatis** | **MyBatis** |
| financial_statements | JPA | **MyBatis** | **MyBatis** | **MyBatis** |
| institutional_trading | JPA | MyBatis | **MyBatis** | MyBatis |
| margin_trading | JPA | MyBatis | **MyBatis** | MyBatis |
| trading_calendar | JPA | JPA | JPA | JPA |

**使用原則**:
- **JPA**: 單筆查詢、簡單條件、關聯查詢
- **MyBatis**: 批次 UPSERT、複雜動態 SQL、JSONB 查詢、統計分析

---

## 4. API 設計

> **重要**: 所有 API 必須遵守總綱 4.4 API 統一規範

### 4.1 API 列表總覽

| API 端點 | HTTP Method | 說明 | 權限 | 回應格式 |
|---------|-------------|------|------|---------|
| GET /api/stocks | GET | 查詢股票清單 | READ_STOCK | 分頁列表 |
| GET /api/stocks/{stockId} | GET | 查詢單一股票資訊 | READ_STOCK | 單一物件 |
| GET /api/stocks/{stockId}/prices | GET | 查詢股價歷史 | READ_STOCK_PRICE | 分頁列表 |
| GET /api/stocks/{stockId}/financials | GET | 查詢財報資料 | READ_FINANCIAL | 列表 |
| GET /api/stocks/{stockId}/institutional | GET | 查詢法人買賣超 | READ_CHIP | 列表 |
| GET /api/stocks/{stockId}/margin | GET | 查詢融資融券 | READ_CHIP | 列表 |
| POST /api/jobs/sync-stock-prices | POST | 手動觸發股價同步 | ADMIN | Job 執行資訊 |
| GET /api/trading-calendar | GET | 查詢交易日曆 | PUBLIC | 列表 |

---

### 4.2 API 詳細設計

#### API-M06-001: 查詢股票清單

**Request**:
```
GET /api/stocks?market_type=TWSE&industry=半導體&page=0&size=20&sort=marketCap,desc
Authorization: Bearer {jwt_token}
```

**Query Parameters**:
| 參數 | 類型 | 必填 | 說明 | 預設值 |
|-----|------|------|------|-------|
| market_type | String | N | 市場類別（TWSE/OTC/EMERGING） | 全部 |
| industry | String | N | 產業分類 | 全部 |
| is_active | Boolean | N | 是否活躍 | true |
| page | Integer | N | 頁碼（從 0 開始） | 0 |
| size | Integer | N | 每頁筆數 | 20 |
| sort | String | N | 排序欄位（如 marketCap,desc） | stockId,asc |

**Response** (成功):
```json
{
  "success": true,
  "timestamp": "2024-12-24T10:30:00+08:00",
  "data": {
    "content": [
      {
        "stock_id": "2330",
        "stock_name": "台積電",
        "market_type": "TWSE",
        "industry": "半導體",
        "market_cap": 15000000000.00,
        "is_active": true,
        "tags": ["半導體", "AI", "ESG"]
      },
      {
        "stock_id": "2317",
        "stock_name": "鴻海",
        "market_type": "TWSE",
        "industry": "電子製造",
        "market_cap": 2500000000.00,
        "is_active": true,
        "tags": ["電子製造", "EV"]
      }
    ],
    "pageable": {
      "page_number": 0,
      "page_size": 20,
      "total_elements": 1800,
      "total_pages": 90
    }
  },
  "error": null
}
```

**Response** (失敗):
```json
{
  "success": false,
  "timestamp": "2024-12-24T10:30:00+08:00",
  "data": null,
  "error": {
    "error_code": "M06_PARAM_001",
    "error_message": "參數錯誤",
    "error_detail": "Invalid market_type value",
    "trace_id": "req_abc123",
    "path": "/api/stocks"
  }
}
```

---

#### API-M06-002: 查詢股票歷史股價

**Request**:
```
GET /api/stocks/2330/prices?start_date=2024-01-01&end_date=2024-12-31&include_ma=true&page=0&size=100
Authorization: Bearer {jwt_token}
```

**Path Parameters**:
| 參數 | 類型 | 說明 |
|-----|------|------|
| stockId | String | 股票代碼（如 2330） |

**Query Parameters**:
| 參數 | 類型 | 必填 | 說明 | 預設值 |
|-----|------|------|------|-------|
| start_date | Date | Y | 起始日期（YYYY-MM-DD） | - |
| end_date | Date | Y | 結束日期（YYYY-MM-DD） | - |
| include_ma | Boolean | N | 是否包含均線資料 | false |
| page | Integer | N | 頁碼 | 0 |
| size | Integer | N | 每頁筆數 | 100 |

**Response** (成功):
```json
{
  "success": true,
  "timestamp": "2024-12-24T10:30:00+08:00",
  "data": {
    "stock_id": "2330",
    "stock_name": "台積電",
    "prices": [
      {
        "trade_date": "2024-12-23",
        "open_price": 575.00,
        "high_price": 582.00,
        "low_price": 573.00,
        "close_price": 580.00,
        "volume": 35000000,
        "change_price": 5.00,
        "change_percent": 0.87,
        "ma5": 578.20,
        "ma20": 570.50
      }
    ],
    "pageable": {
      "page_number": 0,
      "page_size": 100,
      "total_elements": 250
    }
  },
  "error": null
}
```

**Response** (股票不存在):
```json
{
  "success": false,
  "timestamp": "2024-12-24T10:30:00+08:00",
  "data": null,
  "error": {
    "error_code": "M06_STOCK_001",
    "error_message": "股票不存在",
    "error_detail": "Stock not found: 9999",
    "trace_id": "req_def456",
    "path": "/api/stocks/9999/prices"
  }
}
```

---

#### API-M06-003: 查詢財報資料

**Request**:
```
GET /api/stocks/2330/financials?year=2024&quarter=3
Authorization: Bearer {jwt_token}
```

**Query Parameters**:
| 參數 | 類型 | 必填 | 說明 |
|-----|------|------|------|
| year | Integer | N | 年度（預設最新年度） |
| quarter | Integer | N | 季度（1-4，空則全年） |

**Response** (成功):
```json
{
  "success": true,
  "timestamp": "2024-12-24T10:30:00+08:00",
  "data": {
    "stock_id": "2330",
    "stock_name": "台積電",
    "financials": [
      {
        "year": 2024,
        "quarter": 3,
        "report_type": "Q",
        "revenue": 7500000,
        "operating_income": 3200000,
        "net_income": 2800000,
        "total_assets": 45000000,
        "equity": 28000000,
        "eps": 11.50,
        "roe": 18.5,
        "roa": 12.8,
        "publish_date": "2024-11-14"
      }
    ]
  },
  "error": null
}
```

---

#### API-M06-004: 手動觸發股價同步（管理員）

**Request**:
```
POST /api/jobs/sync-stock-prices
Authorization: Bearer {admin_jwt_token}
Content-Type: application/json

{
  "trade_date": "2024-12-24",
  "stock_ids": ["2330", "2317"],
  "force": false
}
```

**Request Body**:
| 欄位 | 類型 | 必填 | 說明 |
|-----|------|------|------|
| trade_date | Date | N | 指定日期（空則當日） |
| stock_ids | Array[String] | N | 指定股票代碼（空則全部） |
| force | Boolean | N | 是否強制更新 |

**Response** (成功):
```json
{
  "success": true,
  "timestamp": "2024-12-24T15:05:00+08:00",
  "data": {
    "execution_id": 12345,
    "job_name": "SYNC_STOCK_PRICES",
    "job_status": "RUNNING",
    "start_time": "2024-12-24T15:05:00+08:00",
    "parameters": {
      "trade_date": "2024-12-24",
      "stock_ids": ["2330", "2317"],
      "force": false
    },
    "estimated_duration": "3 minutes"
  },
  "error": null
}
```

---

### 4.3 錯誤碼定義

遵守總綱 4.4 錯誤碼規範。

| 錯誤碼 | HTTP Status | 說明 | 處理建議 |
|-------|------------|------|---------|
| M06_STOCK_001 | 404 | 股票不存在 | 檢查股票代碼 |
| M06_DATA_001 | 404 | 查無資料 | 確認日期範圍或補齊資料 |
| M06_PARAM_001 | 400 | 參數錯誤 | 檢查參數格式與值域 |
| M06_VALIDATION_001 | 422 | 資料驗證失敗 | 檢查資料合理性 |
| M06_SOURCE_001 | 503 | 資料源暫時不可用 | 稍後重試或切換資料源 |
| M06_JOB_001 | 409 | Job 已在執行中 | 等待當前 Job 完成 |
| M06_DB_001 | 500 | 資料庫錯誤 | 聯絡系統管理員 |

---

## 5. 資料流設計

### 5.1 資料流總覽

```
┌─────────────────────────────────────────────────────────────┐
│                    外部資料來源                               │
│  Yahoo Finance / 證交所 / 公開資訊觀測站 / FinMind           │
└─────────────────────────────────────────────────────────────┘
                              ↓
                    ┌─────────────────┐
                    │  資料獲取層      │
                    │  - API 呼叫     │
                    │  - 錯誤處理     │
                    │  - 重試機制     │
                    └─────────────────┘
                              ↓
                    ┌─────────────────┐
                    │  資料清洗層      │
                    │  - 格式轉換     │
                    │  - 欄位對應     │
                    │  - 異常值處理   │
                    └─────────────────┘
                              ↓
                    ┌─────────────────┐
                    │  資料驗證層      │
                    │  - 完整性檢查   │
                    │  - 一致性檢查   │
                    │  - 業務規則驗證 │
                    └─────────────────┘
                              ↓
                    ┌─────────────────┐
                    │  資料儲存層      │
                    │  - UPSERT       │
                    │  - Transaction  │
                    │  - 索引更新     │
                    └─────────────────┘
                              ↓
                    ┌─────────────────┐
                    │  快取更新層      │
                    │  - Redis 寫入   │
                    │  - 設定 TTL     │
                    └─────────────────┘
                              ↓
                    ┌─────────────────┐
                    │  結果記錄層      │
                    │  - Job 記錄     │
                    │  - 統計資訊     │
                    │  - 告警觸發     │
                    └─────────────────┘
```

### 5.2 股價資料同步流程

```
START: 股價資料同步 Job 觸發（每交易日 15:00）
  ↓
1. 檢查是否為交易日（查詢 trading_calendar 表）
   ├─ 否 → 記錄 SKIPPED 狀態 → END
   └─ 是 → 繼續
  ↓
2. 建立 Job 執行記錄（job_executions 表）
   - job_name = 'SYNC_STOCK_PRICES'
   - job_status = 'RUNNING'
   - start_time = CURRENT_TIMESTAMP
  ↓
3. 從 stocks 表查詢所有活躍股票（is_active = true）
  ↓
4. 批次處理（每批 50 檔股票）
  ↓
5. 呼叫 Yahoo Finance API 獲取股價
   ├─ 成功 → 繼續
   └─ 失敗 → 重試 3 次
       ├─ 成功 → 繼續
       └─ 仍失敗 → 切換資料源（證交所 API）
           ├─ 成功 → 繼續
           └─ 仍失敗 → 記錄錯誤，跳過該批次
  ↓
6. 資料清洗與轉換
   - 格式標準化（日期、數值）
   - 計算 change_price, change_percent
  ↓
7. 資料驗證（參照總綱 4.7）
   - 四價關係檢查
   - 價格合理性檢查（漲跌停幅度）
   - 成交量非負檢查
   ├─ 通過 → 繼續
   └─ 失敗 → 記錄到 data_quality_issues 表，跳過該股票
  ↓
8. 使用 MyBatis 批次 UPSERT
   - ON CONFLICT (stock_id, trade_date) DO UPDATE
   - Transaction 保護
  ↓
9. 更新 Redis 快取（僅熱門股票）
   - Key: stock:price:{stock_id}:{date}
   - TTL: 1 小時
  ↓
10. 更新 Job 執行記錄
   - job_status = 'SUCCESS' / 'FAILED'
   - end_time = CURRENT_TIMESTAMP
   - success_items, failed_items
  ↓
11. 發布事件（StockPriceUpdated）
  ↓
12. 檢查失敗率
   ├─ 失敗率 > 10% → 發送告警
   └─ 否 → 正常結束
  ↓
END
```

### 5.3 財報資料同步流程

```
START: 財報資料同步 Job 觸發（檢測到新財報公告）
  ↓
1. 從公開資訊觀測站查詢新公告清單
  ↓
2. 篩選尚未同步的財報
  ↓
3. 逐筆處理財報
  ↓
4. 下載財報檔案（PDF 或 XBRL）
   ├─ 成功 → 繼續
   └─ 失敗 → 重試 3 次 → 仍失敗 → 記錄錯誤，人工處理
  ↓
5. 解析財報資料
   - XBRL 解析（優先）
   - PDF OCR 解析（備援）
  ↓
6. 資料驗證
   - 必填欄位檢查
   - 資產負債平衡檢查（total_assets = total_liabilities + equity）
   ├─ 通過 → 繼續
   └─ 失敗 → 記錄錯誤，人工確認
  ↓
7. 資料儲存（UPSERT）
   - INSERT ... ON DUPLICATE KEY UPDATE
  ↓
8. 更新 Redis 快取（清除相關快取）
  ↓
9. 記錄 Job 執行結果
  ↓
END
```
---

## 6. Job/排程設計

> **重要**: 所有 Job 必須遵守總綱 4.5 Job/排程模型

### 6.1 Job 清單

| Job 編號 | Job 名稱 | Job 類型 | 執行頻率 | 執行時間 | 優先級 | 預估時長 |
|---------|---------|---------|---------|---------|-------|---------|
| JOB-M06-001 | SYNC_STOCK_PRICES | DATA_SYNC | 每交易日 | 15:00 | P0 | 3-5 分鐘 |
| JOB-M06-002 | SYNC_INSTITUTIONAL_TRADING | DATA_SYNC | 每交易日 | 15:30 | P1 | 2-3 分鐘 |
| JOB-M06-003 | SYNC_MARGIN_TRADING | DATA_SYNC | 每交易日 | 15:30 | P1 | 2-3 分鐘 |
| JOB-M06-004 | SYNC_FINANCIAL_STATEMENTS | DATA_SYNC | 每週一次 | 每週一 08:00 | P1 | 10-15 分鐘 |
| JOB-M06-005 | UPDATE_STOCK_LIST | DATA_SYNC | 每月 | 每月1日 08:00 | P2 | 5 分鐘 |
| JOB-M06-006 | CHECK_DATA_QUALITY | MAINTENANCE | 每日 | 01:00 | P0 | 10 分鐘 |
| JOB-M06-007 | CLEANUP_OLD_JOB_LOGS | MAINTENANCE | 每週 | 每週日 03:00 | P2 | 5 分鐘 |
| JOB-M06-008 | ARCHIVE_OLD_PRICES | MAINTENANCE | 每年 | 每年1月1日 04:00 | P2 | 30 分鐘 |

---

### 6.2 Job 詳細設計

#### JOB-M06-001: 股價資料同步

**Cron 表達式**: `0 0 15 * * MON-FRI`（週一到週五 15:00）

**執行邏輯**:
1. 檢查當日是否為交易日（查詢 trading_calendar 表）
2. 若非交易日，記錄 SKIPPED 狀態並結束
3. 若為交易日，執行同步流程（參見 5.2 節）
4. 記錄 Job 執行結果（job_executions 表）

**參數**:
```json
{
  "job_name": "SYNC_STOCK_PRICES",
  "trade_date": "2024-12-24",
  "stock_ids": null,
  "force_update": false,
  "batch_size": 50
}
```

**預期執行時長**: 3-5 分鐘（1800 檔股票）

**冪等性設計**:
- 使用 PostgreSQL `ON CONFLICT (stock_id, trade_date) DO UPDATE`
- 唯一鍵: (stock_id, trade_date)
- 重複執行不會產生重複資料，只會更新現有資料

**失敗處理**:
- 單一股票失敗不影響其他股票（continue on error）
- 記錄失敗股票清單到 job_execution_details
- 失敗率 > 10% 觸發告警（透過 M15 告警系統）
- 支援手動重跑特定日期的 Job

**資料來源優先順序**:
1. Yahoo Finance API（主要）
2. 證交所公開資訊 API（備援）
3. FinMind API（第二備援，若啟用）

---

#### JOB-M06-002: 三大法人買賣超資料同步

**Cron 表達式**: `0 30 15 * * MON-FRI`（週一到週五 15:30）

**執行邏輯**:
1. 檢查當日是否為交易日
2. 從證交所 API 下載三大法人買賣超資料
3. 解析 CSV 或 JSON 格式
4. 驗證資料（買賣超數值合理性）
5. 使用 MyBatis 批次 UPSERT 到 institutional_trading 表
6. 記錄 Job 執行結果

**冪等性設計**:
- 唯一鍵: (stock_id, trade_date)
- 重複執行覆蓋舊資料

**資料驗證規則**:
- foreign_buy, foreign_sell, trust_buy, trust_sell, dealer_buy, dealer_sell >= 0
- 買賣超計算欄位自動由 PostgreSQL GENERATED COLUMN 維護

---

#### JOB-M06-003: 融資融券資料同步

**Cron 表達式**: `0 30 15 * * MON-FRI`（與 JOB-M06-002 同時執行）

**執行邏輯**:
1. 檢查當日是否為交易日
2. 從證交所 API 下載融資融券資料
3. 解析資料
4. 驗證資料（餘額、額度合理性）
5. 使用 MyBatis 批次 UPSERT 到 margin_trading 表
6. 記錄 Job 執行結果

**冪等性設計**:
- 唯一鍵: (stock_id, trade_date)
- 使用率自動由 GENERATED COLUMN 計算

---

#### JOB-M06-004: 財報資料同步

**觸發方式**: 
- 定期檢查：每週一 08:00
- 事件觸發：檢測到新財報公告時立即執行

**Cron 表達式**: `0 0 8 * * MON`

**執行邏輯**:
1. 查詢公開資訊觀測站最新公告清單
2. 比對 financial_statements 表，找出尚未同步的財報
3. 逐筆下載並解析財報（參見 5.3 節）
4. 驗證資料完整性
5. 儲存核心欄位與 JSONB 詳細資料
6. 記錄 Job 執行結果

**資料來源**:
- 公開資訊觀測站（XBRL 格式優先）
- PDF 備援（需 OCR 解析）

**冪等性設計**:
- 唯一鍵: (stock_id, year, quarter, report_type)
- 若財報已存在，更新為最新版本（修正財報）

**特殊處理**:
- 財報資料結構複雜，部分欄位儲存於 JSONB（income_statement, balance_sheet, cash_flow_statement）
- 解析失敗的財報標記為 MANUAL_REVIEW，需人工確認

---

#### JOB-M06-005: 股票清單更新

**Cron 表達式**: `0 0 8 1 * *`（每月 1 日 08:00）

**執行邏輯**:
1. 從證交所 API 下載最新上市櫃公司清單
2. 比對 stocks 表，找出新上市/下市股票
3. 新上市：INSERT 新記錄
4. 下市：更新 is_active = false, delisting_date = 下市日期
5. 發布 StockListUpdated 事件

**冪等性設計**:
- 主鍵: stock_id
- 使用 UPSERT 機制

---

#### JOB-M06-006: 資料品質檢核

**Cron 表達式**: `0 0 1 * * *`（每日 01:00）

**執行邏輯**:
1. 執行預定義的資料品質檢核規則（參照總綱 4.7）
2. 檢查前一交易日資料
3. 記錄檢核結果到 data_quality_issues 表
4. 高嚴重度問題觸發告警

**檢核項目**:

**檢核 1: 股價資料完整性**
```
規則: 檢查所有活躍股票是否都有前一交易日的股價資料

SELECT s.stock_id, s.stock_name
FROM stocks s
WHERE s.is_active = true
  AND NOT EXISTS (
    SELECT 1 FROM stock_prices sp
    WHERE sp.stock_id = s.stock_id
      AND sp.trade_date = :previous_trading_day
  )
```

**檢核 2: 股價四價一致性**
```
規則: 檢查四價關係是否正確

SELECT stock_id, trade_date
FROM stock_prices
WHERE trade_date = :previous_trading_day
  AND (
    low_price > open_price OR
    low_price > close_price OR
    high_price < open_price OR
    high_price < close_price
  )
```

**檢核 3: 成交量合理性**
```
規則: 檢查成交量是否為負數或異常大

SELECT stock_id, trade_date, volume
FROM stock_prices
WHERE trade_date = :previous_trading_day
  AND (volume < 0 OR volume > 1000000000)
```

**檢核 4: 財報資產負債平衡**
```
規則: 檢查 total_assets = total_liabilities + equity

SELECT stock_id, year, quarter
FROM financial_statements
WHERE ABS(total_assets - (total_liabilities + equity)) > 1000
```

---

#### JOB-M06-007: 清理舊 Job 執行記錄

**Cron 表達式**: `0 0 3 * * SUN`（每週日 03:00）

**執行邏輯**:
1. 將 3 個月前的 job_executions 記錄歸檔到 job_executions_archive
2. 刪除已歸檔的記錄
3. 記錄清理統計

**SQL 邏輯**:
```sql
-- 歸檔
INSERT INTO job_executions_archive
SELECT * FROM job_executions
WHERE end_time < CURRENT_TIMESTAMP - INTERVAL '3 months';

-- 刪除
DELETE FROM job_executions
WHERE end_time < CURRENT_TIMESTAMP - INTERVAL '3 months';
```

---

#### JOB-M06-008: 歸檔舊股價資料

**Cron 表達式**: `0 0 4 1 1 *`（每年 1 月 1 日 04:00）

**執行邏輯**:
1. 檢查 stock_prices 表是否有 20 年前的資料
2. 若有，DETACH 該年份的分區
3. 將分區資料匯出到歸檔儲存（如 S3）
4. 刪除已歸檔的分區
5. 記錄歸檔統計

**PostgreSQL 分區操作**:
```sql
-- DETACH 分區（不刪除資料）
ALTER TABLE stock_prices DETACH PARTITION stock_prices_2005;

-- 匯出分區資料
COPY stock_prices_2005 TO '/archive/stock_prices_2005.csv' CSV HEADER;

-- 刪除分區
DROP TABLE stock_prices_2005;
```

---

### 6.3 Job 依賴關係

```
每交易日:
15:00 - SYNC_STOCK_PRICES (JOB-M06-001)
          ↓
15:30 - SYNC_INSTITUTIONAL_TRADING (JOB-M06-002)
        SYNC_MARGIN_TRADING (JOB-M06-003)
        （可並行執行）
          ↓
01:00 - CHECK_DATA_QUALITY (JOB-M06-006)
        （次日檢查前一日資料）

每週:
週一 08:00 - SYNC_FINANCIAL_STATEMENTS (JOB-M06-004)
週日 03:00 - CLEANUP_OLD_JOB_LOGS (JOB-M06-007)

每月:
1日 08:00 - UPDATE_STOCK_LIST (JOB-M06-005)

每年:
1月1日 04:00 - ARCHIVE_OLD_PRICES (JOB-M06-008)
```

---

### 6.4 Job 監控與告警

**監控指標**:
| 指標 | 閾值 | 告警等級 | 處理方式 |
|-----|------|---------|---------|
| Job 執行時長 | > 預估時長 × 2 | WARNING | 記錄慢查詢 |
| Job 失敗率 | > 10% | ERROR | 立即告警 |
| Job 連續失敗 | >= 3 次 | CRITICAL | 立即告警並暫停 |
| 資料品質問題 | HIGH 嚴重度 > 10 筆 | ERROR | 通知資料管理員 |

**告警通道**（透過 M15 告警系統）:
- Email
- Slack
- SMS（CRITICAL 等級）

---

## 7. 業務邏輯設計

> **說明**: 本節以文字描述業務邏輯與演算法，不包含程式碼實作

### 7.1 Service 層架構

```
StockDataService (股票資料服務 - 門面)
    │
    ├─→ StockPriceSyncService (股價同步服務)
    │       ├─ 職責: 股價資料同步、驗證與儲存
    │       ├─ 依賴: StockRepository (JPA), StockPriceMapper (MyBatis)
    │       └─ 核心方法: syncStockPrices(tradeDate)
    │
    ├─→ FinancialStatementSyncService (財報同步服務)
    │       ├─ 職責: 財報資料同步、XBRL解析、驗證
    │       ├─ 依賴: FinancialStatementMapper (MyBatis)
    │       └─ 核心方法: syncFinancialStatements()
    │
    ├─→ ChipDataSyncService (籌碼同步服務)
    │       ├─ 職責: 三大法人、融資融券資料同步
    │       ├─ 依賴: InstitutionalTradingMapper, MarginTradingMapper (MyBatis)
    │       └─ 核心方法: syncChipData(tradeDate)
    │
    ├─→ TradingCalendarService (交易日曆服務)
    │       ├─ 職責: 交易日判斷、日期計算
    │       ├─ 依賴: TradingCalendarRepository (JPA)
    │       └─ 核心方法: isTradingDay(date), getNextTradingDay(date)
    │
    └─→ DataQualityService (資料品質服務)
            ├─ 職責: 資料驗證、品質檢核、異常記錄
            ├─ 依賴: DataQualityIssueRepository (JPA)
            └─ 核心方法: validateStockPrice(price), runQualityChecks()
```

---

### 7.2 資料獲取邏輯

#### 7.2.1 資料源選擇策略

**決策流程**:
1. 根據資料類型（stock_price, financial_data, chip_data）查詢可用資料源
2. 按優先順序排序（priority 越小越優先）
3. 依序嘗試，直到成功或全部失敗
4. 記錄使用的資料源與失敗原因

**範例**:
```
資料類型: stock_price
資料源清單:
├── Yahoo Finance (priority=1, status=ACTIVE)
├── 證交所 API (priority=2, status=ACTIVE)
└── FinMind API (priority=3, status=INACTIVE)

執行順序:
1. 嘗試 Yahoo Finance
   └─ 成功 → 返回資料，記錄使用 Yahoo Finance
2. 失敗 → 嘗試證交所 API
   └─ 成功 → 返回資料，記錄切換到證交所 API
3. 失敗 → 全部失敗
   └─ 記錄錯誤，觸發告警
```

#### 7.2.2 請求重試策略

**重試條件**:
- 網路超時（Timeout）
- HTTP 5xx 錯誤（伺服器錯誤）
- 連線中斷（Connection Reset）

**不重試條件**:
- HTTP 4xx 錯誤（客戶端錯誤，如 401, 404）
- 資料格式錯誤
- 業務邏輯錯誤

**重試策略**:
- 重試次數: 3 次
- 延遲策略: Exponential Backoff
  - 第 1 次重試: 延遲 1 秒
  - 第 2 次重試: 延遲 2 秒
  - 第 3 次重試: 延遲 4 秒
- 超時時間: 10 秒

**重試流程**:
```
API 呼叫
  ↓
成功？
├─ 是 → 返回資料
└─ 否 → 檢查錯誤類型
    ├─ 可重試錯誤 → 延遲後重試（最多 3 次）
    │   ├─ 重試成功 → 返回資料
    │   └─ 重試失敗 → 切換資料源
    └─ 不可重試錯誤 → 立即切換資料源
```

---

### 7.3 資料清洗邏輯

#### 7.3.1 股價資料清洗

**輸入**: 從外部 API 獲取的原始股價資料  
**輸出**: 標準化的股價資料

**處理步驟**:

**步驟 1: 日期格式標準化**
- 統一轉換為 ISO 8601 格式（YYYY-MM-DD）
- 處理時區問題（轉為台灣時區 UTC+8）
- 範例:
  - `2024/12/24` → `2024-12-24`
  - `Dec 24, 2024` → `2024-12-24`

**步驟 2: 數值格式標準化**
- 移除千分位符號（1,000 → 1000）
- 轉換為 NUMERIC 型別
- 保留小數點後 2 位
- 範例:
  - `"580.5"` → `580.50`
  - `"35,000,000"` → `35000000`

**步驟 3: 計算衍生欄位**
- change_price = close_price - 前一交易日 close_price
- change_percent = (change_price / 前一交易日 close_price) × 100
- turnover = close_price × volume（若資料源未提供）

**步驟 4: 異常值處理**
- 價格為 0 或負數 → 標記為異常，不儲存
- 成交量為負數 → 標記為異常，不儲存
- 四價關係錯誤 → 標記為異常，不儲存
- 記錄異常值到 data_quality_issues 表

---

#### 7.3.2 財報資料清洗

**輸入**: 從 PDF/XBRL 解析的財報資料  
**輸出**: 標準化的財報資料

**處理步驟**:

**步驟 1: 單位統一**
- 所有金額統一為「千元」（與公開資訊觀測站一致）
- 每股指標統一為「元」
- 範例:
  - 營收 100 億元 → revenue = 10000000（千元）
  - EPS 11.5 元 → eps = 11.50

**步驟 2: 欄位對應**
- 不同資料源的欄位名稱不同，需對應到統一欄位
- 維護欄位對應表:
  ```
  公開資訊觀測站欄位 → 資料表欄位
  "營業收入淨額" → revenue
  "稅後淨利" → net_income
  "資產總額" → total_assets
  ```

**步驟 3: 計算衍生欄位**
- free_cash_flow = operating_cash_flow - 資本支出（從 investing_cash_flow 提取）
- 若核心欄位缺失，嘗試從 JSONB 詳細資料計算

**步驟 4: JSONB 結構化**
- 將完整財報資料儲存到 income_statement, balance_sheet, cash_flow_statement 欄位
- 確保 JSON 格式正確
- 範例結構參見 3.2.3 節

---

### 7.4 資料驗證邏輯

#### 7.4.1 股價資料驗證規則

**規則 1: 完整性檢查**
```
必填欄位: stock_id, trade_date, open_price, high_price, low_price, close_price, volume
檢查: 所有必填欄位不可為 NULL
```

**規則 2: 四價關係**
```
low_price <= open_price <= high_price
low_price <= close_price <= high_price

檢查邏輯:
IF (low_price > open_price OR low_price > close_price) THEN
    驗證失敗，記錄錯誤: "low_price 超過 open_price 或 close_price"
END IF

IF (high_price < open_price OR high_price < close_price) THEN
    驗證失敗，記錄錯誤: "high_price 低於 open_price 或 close_price"
END IF
```

**規則 3: 漲跌停限制**
```
若前一交易日 close_price 為 prev_close:
limit_up = prev_close × 1.10
limit_down = prev_close × 0.90

檢查邏輯:
IF (high_price > limit_up + 容許誤差) THEN
    驗證失敗，記錄警告: "超過漲停價"
END IF

IF (low_price < limit_down - 容許誤差) THEN
    驗證失敗，記錄警告: "低於跌停價"
END IF

容許誤差 = 0.01 元（考慮計算精度）
```

**規則 4: 成交量非負**
```
IF (volume < 0) THEN
    驗證失敗，記錄錯誤: "成交量為負數"
END IF
```

**規則 5: 交易日期有效性**
```
查詢 trading_calendar 表:
IF (trade_date 不存在 OR is_trading_day = false) THEN
    驗證失敗，記錄錯誤: "非交易日"
END IF
```

**驗證失敗處理**:
- 記錄到 data_quality_issues 表
- 標記嚴重度（HIGH, MEDIUM, LOW）
- 不儲存該筆資料
- 繼續處理其他資料

---

#### 7.4.2 財報資料驗證規則

**規則 1: 資產負債平衡**
```
檢查: total_assets = total_liabilities + equity

允許誤差: 1000 元（千元為單位，即實際 1 元）

檢查邏輯:
difference = ABS(total_assets - (total_liabilities + equity))
IF (difference > 1000) THEN
    IF (difference > 10000) THEN
        驗證失敗，記錄錯誤: "資產負債差異過大"
    ELSE
        驗證通過，記錄警告: "資產負債有輕微差異"
    END IF
END IF
```

**規則 2: 必填欄位檢查**
```
必填欄位: revenue, net_income, total_assets, equity

IF (任一必填欄位為 NULL) THEN
    驗證失敗，記錄錯誤: "缺少必填欄位"
END IF
```

**規則 3: 邏輯一致性**
```
檢查 1: gross_profit = revenue - 營業成本
檢查 2: operating_income = gross_profit - operating_expense

IF (檢查失敗) THEN
    記錄警告: "財報數值邏輯不一致"（不阻擋儲存）
END IF
```

**規則 4: 合理性檢查**
```
檢查 ROE 範圍:
roe = (net_income / equity) × 100

IF (roe < -100 OR roe > 100) THEN
    記錄警告: "ROE 超出合理範圍"
END IF
```

**驗證失敗處理**:
- HIGH 嚴重度錯誤 → 標記為 MANUAL_REVIEW，不自動儲存
- MEDIUM/LOW 警告 → 儲存資料，但記錄警告

---

### 7.5 批次處理邏輯

#### 7.5.1 批次大小決策

**決策依據**:
- 資料量大小
- API 速率限制
- 資料庫寫入效能
- 記憶體使用量

**建議批次大小**:
| 資料類型 | 批次大小 | 理由 |
|---------|---------|------|
| 股價同步 | 50 檔股票 | API 呼叫次數限制 |
| 股價寫入 | 100 筆 | 資料庫 UPSERT 效能 |
| 籌碼同步 | 100 檔股票 | 資料量較小 |
| 財報解析 | 10 份財報 | CPU 密集型任務 |

#### 7.5.2 批次處理流程

```
總資料集（如 1800 檔股票）
  ↓
分批處理（batch_size = 50）
  ↓
批次 1: 股票 1-50
├─ API 呼叫
├─ 資料清洗
├─ 資料驗證
├─ 批次寫入資料庫（MyBatis）
└─ 記錄處理結果
  ↓
批次 2: 股票 51-100
├─ （同上）
└─ ...
  ↓
...
  ↓
批次 36: 股票 1751-1800
├─ （同上）
└─ 完成
  ↓
彙總統計
├─ 成功筆數
├─ 失敗筆數
└─ 記錄到 job_executions
```

**批次失敗處理**:
- 單一批次失敗不影響其他批次
- 記錄失敗批次的股票清單
- 支援重跑失敗批次

---

### 7.6 快取策略

#### 7.6.1 快取鍵設計

**股價資料**:
```
單日股價:
  Key: stock:price:{stock_id}:{trade_date}
  範例: stock:price:2330:2024-12-24
  Value: StockPrice JSON
  TTL: 1 小時

範圍查詢:
  Key: stock:prices:{stock_id}:{start_date}:{end_date}
  範例: stock:prices:2330:2024-01-01:2024-12-24
  Value: List<StockPrice> JSON
  TTL: 6 小時
```

**股票基本資料**:
```
Key: stock:info:{stock_id}
範例: stock:info:2330
Value: Stock JSON
TTL: 24 小時
```

**股票清單**:
```
全部活躍股票:
  Key: stocks:list:active
  Value: List<Stock> JSON
  TTL: 24 小時

依市場分類:
  Key: stocks:list:market:{market_type}
  範例: stocks:list:market:TWSE
  Value: List<Stock> JSON
  TTL: 24 小時

依產業分類:
  Key: stocks:list:industry:{industry}
  範例: stocks:list:industry:半導體
  Value: List<Stock> JSON
  TTL: 24 小時
```

**交易日曆**:
```
Key: trading:calendar:{year}
範例: trading:calendar:2024
Value: List<TradingDay> JSON
TTL: 7 天
```

#### 7.6.2 TTL 設定策略

| 資料類型 | TTL | 理由 |
|---------|-----|------|
| 當日股價（盤後） | 1 小時 | 盤後可能有修正 |
| 歷史股價 | 6 小時 | 不常變動 |
| 股票基本資料 | 24 小時 | 變動頻率低 |
| 股票清單 | 24 小時 | 每日更新一次 |
| 財報資料 | 7 天 | 每季更新 |
| 交易日曆 | 7 天 | 提前一年預載 |

#### 7.6.3 快取更新策略

**Cache-Aside 模式**:
```
讀取流程:
1. 查詢 Redis 快取
   ├─ 命中 → 返回快取資料
   └─ 未命中 → 查詢資料庫
       ├─ 查詢成功 → 寫入快取 → 返回資料
       └─ 查詢失敗 → 返回錯誤

寫入流程:
1. 寫入 PostgreSQL 資料庫
2. 刪除相關快取（或更新快取）
3. 下次讀取時重新載入
```

**快取預熱**:
```
系統啟動時:
1. 載入熱門股票（市值前 50）最新股價
2. 載入當年度交易日曆
3. 載入活躍股票清單

Job 完成後:
1. 更新熱門股票快取
2. 更新股票清單快取（若有變動）
```

**快取失效觸發時機**:
- 股價同步 Job 完成 → 清除 stock:price:* 相關快取
- 股票清單更新 → 清除 stocks:list:* 相關快取
- 財報同步完成 → 清除 stock:financial:* 相關快取

---

## 8. 整合點

### 8.1 對外部系統的依賴

| 外部系統 | 用途 | 協議 | 認證方式 | 限制 | 備援方案 |
|---------|------|------|---------|------|---------|
| Yahoo Finance API | 股價資料 | REST | 無（公開） | 100 req/hour | 證交所 API |
| 證交所公開資訊 | 股價、法人、融資融券 | REST | 無（公開） | 無明確限制 | FinMind API |
| 公開資訊觀測站 | 財報資料 | HTTP | 無（公開） | 需爬蟲解析 | 手動上傳 |
| FinMind API | 綜合資料（備援） | REST | API Key | 依方案不同 | - |

**外部 API 呼叫規範**:
- 設定 User-Agent 標頭
- 遵守 robots.txt 規則
- 實作重試與 Exponential Backoff
- 記錄 API 呼叫日誌（請求時間、狀態碼、回應時間）

---

### 8.2 對內部模組的提供

| 下游模組 | 使用的 API | 資料類型 | 呼叫頻率 | 快取策略 |
|---------|-----------|---------|---------|---------|
| M07 技術分析 | GET /stocks/{id}/prices | 股價歷史 | 每次計算指標 | 6 小時 TTL |
| M08 基本面分析 | GET /stocks/{id}/financials | 財務報表 | 每季更新 | 7 天 TTL |
| M09 籌碼分析 | GET /stocks/{id}/institutional<br>GET /stocks/{id}/margin | 法人、融資融券 | 每日更新 | 6 小時 TTL |
| M13 信號判斷引擎 | GET /stocks | 股票清單 | 初始化時 | 24 小時 TTL |
| M14 選股引擎 | GET /stocks<br>GET /stocks/{id}/prices | 股票清單、股價 | 選股執行時 | 6 小時 TTL |
| M16 回測系統 | GET /stocks/{id}/prices | 歷史股價 | 回測執行時 | 6 小時 TTL |

**服務間通訊規範**:
- 使用 REST API（同步）
- 使用事件（非同步）
- 遵守總綱 4.4 API 規範
- 統一錯誤碼格式

---

### 8.3 事件發布

**發布的事件**（遵守總綱事件規範）:

| 事件名稱 | 觸發條件 | 事件內容 | 訂閱者 | 用途 |
|---------|---------|---------|-------|------|
| StockPriceUpdated | 股價資料同步完成 | stock_id, trade_date, price_id | M07, M13 | 觸發指標計算、信號判斷 |
| FinancialStatementUpdated | 財報資料同步完成 | stock_id, year, quarter | M08, M13 | 觸發基本面分析 |
| StockListUpdated | 股票清單更新 | added_stocks[], removed_stocks[] | M07, M08, M13 | 更新股票池 |
| DataQualityIssueDetected | 發現資料品質問題 | issue_id, severity, affected_table | M15 監控系統 | 觸發告警 |

**事件格式範例**:
```json
{
  "event_id": "evt_abc123",
  "event_type": "StockPriceUpdated",
  "event_time": "2024-12-24T15:30:00+08:00",
  "source": "M06",
  "version": "1.0",
  "data": {
    "stock_id": "2330",
    "trade_date": "2024-12-24",
    "price_id": 123456,
    "affected_count": 1800
  }
}
```

**事件發布機制**:
- 使用 Spring ApplicationEventPublisher（同一 JVM）
- 或使用 Message Queue（Kafka/RabbitMQ，跨服務）
- 確保事件順序性（同一股票的事件按時間順序）

---

### 8.4 資料匯出介面

**用途**: 提供給外部系統或報表工具使用

**API**:
```
GET /api/export/stock-prices?stock_id=2330&start_date=2024-01-01&end_date=2024-12-31&format=csv

支援格式: CSV, JSON, Excel
權限: EXPORT_DATA
```

**匯出限制**:
- 單次最多匯出 1 年資料
- 每日匯出次數限制: 10 次
- 檔案大小限制: 50 MB

---

## 9. 效能考量

### 9.1 效能目標

| 指標 | 目標值 | 測量方式 | 說明 |
|-----|-------|---------|------|
| API 回應時間（單一股票） | P95 < 100ms | APM 監控 | 含快取命中 |
| API 回應時間（範圍查詢） | P95 < 300ms | APM 監控 | 查詢 1 年資料 |
| 股價同步 Job 執行時間 | < 5 分鐘 | Job 執行記錄 | 1800 檔股票 |
| 快取命中率 | > 80% | Redis 統計 | 熱門股票 |
| 資料庫查詢時間 | < 50ms | 慢查詢日誌 | 單表查詢，有索引 |

---

### 9.2 效能優化策略

#### 9.2.1 資料庫優化

**索引優化**:
- 所有常用查詢欄位都建立索引
- 複合索引順序：選擇性高的欄位在前
- 範例：(stock_id, trade_date) 而非 (trade_date, stock_id)
- 定期執行 `ANALYZE` 更新統計資訊

**查詢優化**:
- 避免 SELECT *，只查詢需要的欄位
- 使用 LIMIT 限制查詢筆數
- 批次查詢替代逐筆查詢
  - 不良範例：循環執行 1800 次單筆查詢
  - 良好範例：使用 WHERE stock_id IN (...) 一次查詢

**分區優化**:
- stock_prices 表按年份分區
- 查詢時自動裁剪不相關分區
- 範例：查詢 2024 年資料，只掃描 stock_prices_2024 分區

**連線池優化**:
- PostgreSQL 連線池大小：50-100
- 連線超時時間：30 秒
- 最大閒置連線數：10

---

#### 9.2.2 快取優化

**多層快取架構**:
```
請求 
  ↓
Redis（L1 快取，熱資料）
  ↓ 未命中
PostgreSQL（資料庫）
  ↓
返回資料並寫入 Redis
```

**快取預熱**:
- 系統啟動時預載熱門股票（市值前 50）資料
- 每日 Job 完成後批次更新快取
- 預熱時間：< 30 秒

**快取穿透防護**:
- 布隆過濾器（Bloom Filter）檢查股票是否存在
- 空值快取（TTL 較短，5 分鐘），避免惡意查詢

**快取雪崩防護**:
- TTL 加入隨機值（±10%），避免大量快取同時失效
- 範例：TTL = 6 小時 ± 36 分鐘

**快取擊穿防護**:
- 熱門資料使用分散式鎖（Redis SET NX）
- 只允許一個請求查詢資料庫，其他請求等待

---

#### 9.2.3 批次處理優化

**批次大小調整**:
- 股價同步：每批 50 檔股票（API 限制）
- 資料庫 UPSERT：每批 100 筆（效能最佳）

**並行處理**:
- 使用執行緒池（ThreadPoolExecutor）
- 執行緒池大小：CPU 核心數 × 2
- 注意：避免過度並行導致資料庫連線耗盡

**連線池優化**:
- MySQL 連線池大小：50-100
- Redis 連線池大小：20-50
- 連線超時時間：30 秒

**批次寫入優化（MyBatis）**:
```sql
-- 使用 PostgreSQL COPY 命令（更快）
COPY stock_prices (stock_id, trade_date, open_price, ...)
FROM STDIN WITH (FORMAT csv);

-- 或使用批次 INSERT
INSERT INTO stock_prices VALUES
  (row1), (row2), ..., (row100)
ON CONFLICT (stock_id, trade_date) DO UPDATE ...;
```

---

### 9.3 容量規劃

#### 9.3.1 資料量估算

**stock_prices 表**:
```
每日新增: 1800 檔股票 × 1 筆 = 1,800 筆/日
每年新增: 1,800 × 250 交易日 = 450,000 筆/年
20 年累積: 450,000 × 20 = 9,000,000 筆

單筆大小約 150 bytes（含索引）
總容量: 9,000,000 × 150 bytes ≈ 1.35 GB

加上分區索引、JSONB 額外空間:
實際容量: 約 3-4 GB（20 年資料）
```

**financial_statements 表**:
```
每年新增: 1800 檔股票 × 4 季 = 7,200 筆/年
10 年累積: 72,000 筆

單筆大小約 1 KB（含 JSONB）
總容量: 72,000 × 1 KB ≈ 72 MB

加上 GIN 索引:
實際容量: 約 200 MB（10 年資料）
```

**institutional_trading 表**:
```
類似 stock_prices
5 年累積: 1,800 × 250 × 5 = 2,250,000 筆
總容量: 約 500 MB
```

**總計（20 年資料）**:
- 資料表大小: 約 4-5 GB
- 含索引與備份: 約 15-20 GB
- PostgreSQL WAL 日誌: 約 5 GB

#### 9.3.2 硬體需求建議

**開發/測試環境**:
- CPU: 2 核
- RAM: 4 GB
- Disk: 50 GB SSD
- PostgreSQL shared_buffers: 1 GB
- Redis: 512 MB

**生產環境（單機）**:
- CPU: 8 核
- RAM: 32 GB
- Disk: 500 GB SSD（含備份空間）
- PostgreSQL shared_buffers: 8 GB
- PostgreSQL effective_cache_size: 24 GB
- Redis: 4 GB

**生產環境（高可用）**:
- 主從架構：1 主 + 2 從
- 負載均衡：讀寫分離
- 備份策略：每日全量備份 + WAL 歸檔

---

### 9.4 監控指標

| 指標類型 | 指標名稱 | 閾值 | 告警等級 |
|---------|---------|------|---------|
| API 效能 | P95 回應時間 | > 500ms | WARNING |
| API 效能 | P99 回應時間 | > 1000ms | ERROR |
| 資料庫 | 慢查詢數量 | > 10/分鐘 | WARNING |
| 資料庫 | 連線池使用率 | > 80% | WARNING |
| 資料庫 | Disk I/O 使用率 | > 80% | ERROR |
| 快取 | Redis 記憶體使用率 | > 80% | WARNING |
| 快取 | 快取命中率 | < 70% | WARNING |
| Job 效能 | Job 執行時長 | > 預估時長 × 2 | WARNING |

---

## 10. 測試準則

### 10.1 單元測試

#### 10.1.1 Repository 層測試

**測試目標**: 驗證資料庫操作正確性

**測試場景**:
- 測試 CRUD 基本操作
- 測試唯一鍵約束
- 測試外鍵約束
- 測試查詢方法（findBy...）
- 測試 JSONB 欄位讀寫
- 測試陣列欄位讀寫

**測試範例**:
```
測試: StockRepository.findByStockId()
Given: 資料庫中存在 stock_id='2330'
When: 呼叫 findByStockId("2330")
Then: 應返回對應的 Stock 物件

測試: StockPriceRepository.saveWithDuplicateDate()
Given: 已存在 (stock_id='2330', trade_date='2024-12-24') 的記錄
When: 嘗試插入相同 (stock_id, trade_date) 的新記錄（使用 UPSERT）
Then: 應更新現有記錄而非插入新記錄

測試: StockRepository.findByTag()
Given: stocks 表中有股票標籤包含 'AI'
When: 呼叫 findByTag("AI")
Then: 應返回所有包含 'AI' 標籤的股票
```

**測試工具**:
- JUnit 5
- Spring Boot Test
- Testcontainers（啟動 PostgreSQL 容器）

---

#### 10.1.2 Service 層測試

**測試目標**: 驗證業務邏輯正確性

**測試場景**:
- 測試業務邏輯正確性
- 測試異常處理
- 測試交易邊界
- Mock 外部依賴（Repository, API Client）

**測試範例**:
```
測試: StockPriceSyncService.syncStockPrices()
Given: Yahoo Finance API 返回正常資料
When: 執行 syncStockPrices("2024-12-24")
Then: 
  - 資料應正確儲存到資料庫
  - Redis 快取應更新
  - Job 執行記錄應為 SUCCESS

測試: StockPriceSyncService.syncStockPrices_ValidationFail()
Given: Yahoo Finance API 返回違反四價關係的資料
When: 執行 syncStockPrices("2024-12-24")
Then:
  - 該筆資料不應儲存
  - 錯誤應記錄到 data_quality_issues
  - Job 執行記錄應包含失敗明細

測試: DataQualityService.validateStockPrice_FourPriceError()
Given: 準備違反四價關係的股價資料（high < low）
When: 執行 validateStockPrice(price)
Then:
  - 驗證應失敗
  - 返回錯誤訊息包含 "四價關係不一致"
```

**Mock 策略**:
- Mock 外部 API Client（Yahoo Finance, 證交所）
- Mock Repository 層
- 使用真實 Redis（Testcontainers）

---

### 10.2 整合測試

#### 10.2.1 資料庫整合測試

**測試環境**: 使用 Testcontainers 啟動 PostgreSQL 容器

**測試場景**:
- 測試資料插入與查詢
- 測試交易回滾
- 測試索引效能
- 測試分區功能
- 測試 JSONB 查詢
- 測試 GENERATED COLUMN 計算

**測試範例**:
```
測試: 股價資料批次插入效能
Given: 準備 1000 筆股價資料
When: 使用 MyBatis 批次 UPSERT 插入
Then:
  - 執行時間 < 1 秒
  - 所有資料正確儲存
  - 唯一鍵約束生效（重複執行不產生重複資料）

測試: JSONB 查詢效能
Given: financial_statements 表有 10000 筆資料
When: 查詢 ROE > 15% 的股票
Then:
  - 查詢時間 < 100ms
  - 結果正確

測試: 分區裁剪
Given: stock_prices 表有 2023-2025 年資料（分區）
When: 查詢 2024 年資料
Then:
  - 只掃描 stock_prices_2024 分區
  - 查詢時間 < 2023-2025 全表掃描時間的 1/3
```

---

#### 10.2.2 外部 API 整合測試

**測試環境**: 使用 WireMock 模擬外部 API

**測試場景**:
- 測試正常回應
- 測試超時
- 測試錯誤回應（4xx, 5xx）
- 測試重試機制
- 測試備援切換

**測試範例**:
```
測試: Yahoo Finance API 超時重試
Given: WireMock 模擬 API 第 1-2 次請求超時，第 3 次成功
When: 執行 fetchStockPrice("2330")
Then:
  - 應重試 3 次
  - 最終返回成功結果
  - 重試延遲符合 Exponential Backoff（1s, 2s, 4s）

測試: 備援資料源切換
Given: WireMock 模擬 Yahoo Finance API 持續失敗
When: 執行 fetchStockPrice("2330")
Then:
  - 應自動切換至證交所 API
  - 最終返回成功結果
  - 記錄切換事件
```

---

### 10.3 API 測試

**測試工具**: MockMvc 或 RestAssured

**測試場景**:
- 測試成功回應格式（遵守總綱 4.4 API 規範）
- 測試錯誤回應格式
- 測試參數驗證
- 測試權限控制（Spring Security）
- 測試分頁功能

**測試範例**:
```
測試: GET /api/stocks/2330/prices
Given: 資料庫中存在 2330 的股價資料
When: GET /api/stocks/2330/prices?start_date=2024-01-01&end_date=2024-12-24
Then:
  - HTTP 200
  - Response 格式符合總綱 API 規範
  - 返回資料筆數正確
  - 日期範圍正確

測試: GET /api/stocks/9999（不存在的股票）
When: GET /api/stocks/9999
Then:
  - HTTP 404
  - error_code = "M06_STOCK_001"
  - error_message 清楚說明問題

測試: 參數驗證
When: GET /api/stocks/2330/prices?start_date=2024-13-01
Then:
  - HTTP 400
  - error_code = "M06_PARAM_001"
  - error_detail 說明日期格式錯誤
```

---

### 10.4 效能測試

**測試工具**: JMeter 或 Gatling

**測試場景**:
- 併發查詢測試（100-500 req/s）
- 大量資料查詢測試（查詢 5 年股價）
- 快取命中率測試
- Job 執行時間測試

**測試範例**:
```
測試: 熱門股票查詢效能
Given: 100 個併發使用者
When: 每秒查詢 /api/stocks/2330/prices（最近 30 天）
Then:
  - P95 回應時間 < 100ms
  - 快取命中率 > 80%
  - 無錯誤發生

測試: 股價同步 Job 效能
Given: 1800 檔股票需要同步
When: 執行 SYNC_STOCK_PRICES Job
Then:
  - 執行時間 < 5 分鐘
  - 成功率 > 90%
  - 資料庫連線池未耗盡
```

---

### 10.5 資料品質測試

**測試場景**:
- 測試資料驗證規則
- 測試資料完整性檢查
- 測試資料一致性檢查

**測試範例**:
```
測試: 股價四價關係驗證
Given: 準備違反四價關係的測試資料（high < low）
When: 執行資料驗證
Then:
  - 驗證失敗
  - 資料不應儲存
  - 錯誤記錄到 data_quality_issues

測試: 財報資產負債平衡檢查
Given: 準備 total_assets ≠ total_liabilities + equity 的測試資料
When: 執行資料驗證
Then:
  - 驗證失敗
  - 標記為需人工確認
  - 記錄到 data_quality_issues
```

---

### 10.6 測試覆蓋率目標

| 層級 | 覆蓋率目標 | 說明 |
|-----|----------|------|
| Repository 層 | > 90% | 重要的資料庫操作必須測試 |
| Service 層 | > 80% | 核心業務邏輯必須測試 |
| Controller 層 | > 70% | 主要 API 端點必須測試 |
| 整體 | > 75% | 整體程式碼覆蓋率 |

**測試優先級**:
1. P0 功能：100% 測試覆蓋（如股價同步、資料驗證）
2. P1 功能：> 80% 測試覆蓋
3. P2 功能：> 60% 測試覆蓋

---

## 附錄

### A. 參考資料

**外部資料源文檔**:
- Yahoo Finance API: https://finance.yahoo.com/
- 台灣證券交易所: https://www.twse.com.tw/
- 公開資訊觀測站: https://mops.twse.com.tw/
- FinMind API: https://finmindtrade.com/

**技術文檔**:
- PostgreSQL 15 官方文檔: https://www.postgresql.org/docs/15/
- Spring Data JPA: https://spring.io/projects/spring-data-jpa
- MyBatis: https://mybatis.org/mybatis-3/
- Redis: https://redis.io/documentation

**總綱文檔**:
- DOC-00-MASTER 總綱規範 v02

---

### B. PostgreSQL 特性速查

**JSONB 操作符**:
| 操作符 | 說明 | 範例 |
|-------|------|------|
| -> | 取得 JSON 物件欄位（返回 JSONB） | data->'name' |
| ->> | 取得 JSON 物件欄位（返回文字） | data->>'name' |
| @> | 包含（左邊包含右邊） | data @> '{"key":"value"}' |
| <@ | 被包含（右邊包含左邊） | '{"key":"value"}' <@ data |
| ? | 是否存在 key | data ? 'key' |
| ?& | 是否存在所有 key | data ?& ARRAY['key1','key2'] |
| ?| | 是否存在任一 key | data ?| ARRAY['key1','key2'] |

**陣列操作符**:
| 操作符 | 說明 | 範例 |
|-------|------|------|
| = ANY | 等於陣列中任一元素 | 'AI' = ANY(tags) |
| && | 陣列重疊（有共同元素） | tags && ARRAY['AI','半導體'] |
| @> | 包含（左邊包含右邊） | tags @> ARRAY['AI'] |
| <@ | 被包含（右邊包含左邊） | ARRAY['AI'] <@ tags |

---

### C. 變更歷史

| 版本 | 日期 | 修改者 | 修改內容 |
|-----|------|-------|---------|
| v1.0 | 2025-12-22 | chris | 初始版本（MySQL） |
| v2.0 | 2025-12-24 | chris | 升級至 PostgreSQL + JPA + MyBatis |

---

### D. 待辦事項

- [ ] 補充 FinMind API 整合細節
- [ ] 補充財報 XBRL 解析邏輯細節
- [ ] 完成效能測試基準
- [ ] 建立監控儀表板（Grafana）
- [ ] 撰寫資料歸檔腳本

---

## 文件結束

**文件編號**: DOC-01-M06  
**版本**: v2.0  
**最後更新**: 2025-12-24  
**審核狀態**: 待審核  

**下一步**: 
1. 團隊審核本文件
2. 開始實作 M06 模組
3. 撰寫 DOC-02-M07 技術分析模組文件（v2.0）
