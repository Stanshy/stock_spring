# M14-選股引擎 資料庫設計

> **文件編號**: DB-M14
> **模組名稱**: 選股引擎 (Stock Screening Engine)
> **版本**: v1.0
> **最後更新**: 2026-01-14
> **狀態**: Draft

---

## 1. 設計概述

### 1.1 設計目標

- 儲存用戶自訂選股策略與條件
- 記錄選股執行歷史與結果
- 追蹤選股績效表現
- 支援動態多維度篩選查詢

### 1.2 持久層策略

| 操作類型 | 技術選擇 | 說明 |
|---------|---------|------|
| 策略 CRUD | MyBatis | 標準增刪改查 + JSONB 處理 |
| 動態篩選查詢 | MyBatis | 動態 SQL 建構多維度查詢 |
| 歷史記錄 | MyBatis | 批次寫入、查詢 |
| 績效計算 | MyBatis | 複雜聚合統計 |

### 1.3 表格總覽

| # | 表格名稱 | 說明 | 預估資料量 |
|---|---------|------|-----------|
| 1 | screening_strategies | 選股策略定義 | 1 萬筆 |
| 2 | screening_templates | 快速選股模板 | 20 筆 |
| 3 | screening_executions | 選股執行記錄 | 100 萬筆/年 |
| 4 | screening_results | 選股結果明細 | 3000 萬筆/年 |
| 5 | screening_performance | 績效追蹤記錄 | 3000 萬筆/年 |
| 6 | condition_definitions | 篩選條件定義 | 50 筆 |

---

## 2. 表格詳細設計

### 2.1 screening_strategies（選股策略表）

儲存用戶定義的選股策略。

```sql
CREATE TABLE screening_strategies (
    id                  BIGSERIAL PRIMARY KEY,
    strategy_id         VARCHAR(50) NOT NULL UNIQUE,
    strategy_name       VARCHAR(100) NOT NULL,
    description         VARCHAR(500),
    owner_id            VARCHAR(50) NOT NULL,
    is_public           BOOLEAN DEFAULT FALSE,
    conditions          JSONB NOT NULL,
    condition_summary   VARCHAR(500),
    market              VARCHAR(10) DEFAULT 'ALL',
    sectors             JSONB,
    min_price           DECIMAL(10,2),
    max_price           DECIMAL(10,2),
    min_volume          INTEGER,
    sort_by             JSONB,
    sort_direction      JSONB,
    default_limit       INTEGER DEFAULT 50,
    execution_count     INTEGER DEFAULT 0,
    copy_count          INTEGER DEFAULT 0,
    last_executed_at    TIMESTAMP WITH TIME ZONE,
    status              VARCHAR(20) DEFAULT 'ACTIVE',
    created_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_market CHECK (market IN ('ALL', 'TWSE', 'OTC')),
    CONSTRAINT chk_status CHECK (status IN ('ACTIVE', 'DELETED', 'ARCHIVED'))
);

-- 索引
CREATE INDEX idx_strategies_owner ON screening_strategies(owner_id, status);
CREATE INDEX idx_strategies_public ON screening_strategies(is_public, status) WHERE is_public = TRUE;
CREATE INDEX idx_strategies_name ON screening_strategies(strategy_name);
CREATE INDEX idx_strategies_execution ON screening_strategies(last_executed_at DESC);

COMMENT ON TABLE screening_strategies IS '選股策略定義表';
COMMENT ON COLUMN screening_strategies.conditions IS '篩選條件組合（JSONB）';
COMMENT ON COLUMN screening_strategies.condition_summary IS '條件摘要（人類可讀）';
```

**Conditions JSONB 結構**:
```json
{
  "logic": "AND",
  "conditions": [
    {
      "condition_code": "F_PE",
      "operator": "<=",
      "values": [15]
    },
    {
      "logic": "OR",
      "conditions": [
        {
          "condition_code": "C_FOREIGN_CONT",
          "operator": ">=",
          "values": [3]
        },
        {
          "condition_code": "C_TRUST_CONT",
          "operator": ">=",
          "values": [3]
        }
      ]
    }
  ]
}
```

**MyBatis Mapper**:
```java
@Mapper
public interface ScreeningStrategyMapper {

    @Insert("""
        INSERT INTO screening_strategies
        (strategy_id, strategy_name, description, owner_id, is_public,
         conditions, condition_summary, market, sectors, sort_by, sort_direction, default_limit)
        VALUES
        (#{strategyId}, #{strategyName}, #{description}, #{ownerId}, #{isPublic},
         #{conditions}::jsonb, #{conditionSummary}, #{market}, #{sectors}::jsonb,
         #{sortBy}::jsonb, #{sortDirection}::jsonb, #{defaultLimit})
        """)
    int insert(ScreeningStrategy strategy);

    @Select("""
        SELECT * FROM screening_strategies
        WHERE strategy_id = #{strategyId} AND status = 'ACTIVE'
        """)
    ScreeningStrategy findByStrategyId(String strategyId);

    @Select("""
        SELECT * FROM screening_strategies
        WHERE owner_id = #{ownerId} AND status = 'ACTIVE'
        ORDER BY updated_at DESC
        LIMIT #{limit} OFFSET #{offset}
        """)
    List<ScreeningStrategy> findByOwnerId(String ownerId, int limit, int offset);

    @Update("""
        UPDATE screening_strategies
        SET execution_count = execution_count + 1,
            last_executed_at = NOW()
        WHERE strategy_id = #{strategyId}
        """)
    int incrementExecutionCount(String strategyId);
}
```

---

### 2.2 screening_templates（快速選股模板表）

儲存系統預設的快速選股模板。

```sql
CREATE TABLE screening_templates (
    id                  BIGSERIAL PRIMARY KEY,
    template_code       VARCHAR(20) NOT NULL UNIQUE,
    template_name       VARCHAR(50) NOT NULL,
    description         VARCHAR(200),
    category            VARCHAR(30) NOT NULL,
    conditions          JSONB NOT NULL,
    condition_summary   VARCHAR(200),
    sort_by             JSONB,
    sort_direction      JSONB,
    default_limit       INTEGER DEFAULT 50,
    display_order       INTEGER DEFAULT 0,
    is_active           BOOLEAN DEFAULT TRUE,
    created_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_category CHECK (category IN ('信號', '籌碼', '基本面', '技術面', '綜合'))
);

-- 初始資料
INSERT INTO screening_templates (template_code, template_name, description, category, conditions, condition_summary, display_order) VALUES
('QUICK_01', '強勢股', 'M13 高評級買入信號股票', '信號',
 '{"logic":"AND","conditions":[{"condition_code":"S_GRADE","operator":">=","values":["A"]},{"condition_code":"S_DIRECTION","operator":"=","values":["BUY"]}]}',
 '信號評級 >= A, 方向 = BUY', 1),

('QUICK_02', '外資連買', '外資連續買超的股票', '籌碼',
 '{"logic":"AND","conditions":[{"condition_code":"C_FOREIGN_CONT","operator":">=","values":[3]}]}',
 '外資連續買超 >= 3 日', 2),

('QUICK_03', '低估價值股', '低估值高殖利率股票', '基本面',
 '{"logic":"AND","conditions":[{"condition_code":"F_PE","operator":"<","values":[15]},{"condition_code":"F_ROE","operator":">","values":[15]},{"condition_code":"F_DIVIDEND_YIELD","operator":">","values":[3]}]}',
 'PE < 15, ROE > 15%, 股利率 > 3%', 3),

('QUICK_04', '技術突破', '突破均線且量增', '技術面',
 '{"logic":"AND","conditions":[{"condition_code":"T_MA20","operator":"=","values":["CROSS_ABOVE"]},{"condition_code":"T_VOLUME_RATIO","operator":">","values":[1.5]}]}',
 '突破 20 日均線, 成交量放大 > 50%', 4),

('QUICK_05', '動能選股', '動能指標轉強', '技術面',
 '{"logic":"AND","conditions":[{"condition_code":"T_RSI","operator":">","values":[50]},{"condition_code":"T_MACD_SIGNAL","operator":"=","values":["GOLDEN_CROSS"]}]}',
 'RSI > 50, MACD 黃金交叉', 5),

('QUICK_06', '績優成長', '營收與獲利成長股', '基本面',
 '{"logic":"AND","conditions":[{"condition_code":"F_REVENUE_GROWTH","operator":">","values":[10]},{"condition_code":"F_EPS_GROWTH","operator":">","values":[15]}]}',
 '營收 YoY > 10%, EPS 成長 > 15%', 6),

('QUICK_07', '籌碼集中', '主力連續買超', '籌碼',
 '{"logic":"AND","conditions":[{"condition_code":"C_INST_TOTAL","operator":">","values":[0]},{"condition_code":"C_CONCENTRATION","operator":">","values":[0]}]}',
 '法人買超, 籌碼集中度增加', 7),

('QUICK_08', '多頭排列', '均線多頭排列', '技術面',
 '{"logic":"AND","conditions":[{"condition_code":"T_MA_ALIGNMENT","operator":"=","values":["BULLISH"]}]}',
 'MA5 > MA10 > MA20 > MA60', 8);

COMMENT ON TABLE screening_templates IS '快速選股模板表';
```

---

### 2.3 screening_executions（選股執行記錄表）

記錄每次選股執行的資訊。

```sql
CREATE TABLE screening_executions (
    id                  BIGSERIAL PRIMARY KEY,
    execution_id        VARCHAR(50) NOT NULL UNIQUE,
    execution_type      VARCHAR(20) NOT NULL,
    template_code       VARCHAR(20),
    strategy_id         VARCHAR(50),
    name                VARCHAR(100),
    user_id             VARCHAR(50) NOT NULL,
    conditions_snapshot JSONB NOT NULL,
    condition_summary   VARCHAR(500),
    market              VARCHAR(10),
    sectors             JSONB,
    sort_by             JSONB,
    sort_direction      JSONB,
    result_limit        INTEGER,
    total_candidates    INTEGER NOT NULL,
    matched_count       INTEGER NOT NULL,
    execution_time_ms   INTEGER NOT NULL,
    executed_at         TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_exec_type CHECK (execution_type IN ('QUICK', 'CUSTOM', 'SIGNAL', 'STRATEGY')),
    CONSTRAINT fk_exec_template FOREIGN KEY (template_code)
        REFERENCES screening_templates(template_code),
    CONSTRAINT fk_exec_strategy FOREIGN KEY (strategy_id)
        REFERENCES screening_strategies(strategy_id) ON DELETE SET NULL
);

-- 索引
CREATE INDEX idx_executions_user_date ON screening_executions(user_id, executed_at DESC);
CREATE INDEX idx_executions_strategy ON screening_executions(strategy_id, executed_at DESC);
CREATE INDEX idx_executions_date ON screening_executions(executed_at DESC);
CREATE INDEX idx_executions_template ON screening_executions(template_code);

COMMENT ON TABLE screening_executions IS '選股執行記錄表';
COMMENT ON COLUMN screening_executions.conditions_snapshot IS '執行時的條件快照';
```

**MyBatis Mapper**:
```java
@Mapper
public interface ScreeningExecutionMapper {

    @Insert("""
        INSERT INTO screening_executions
        (execution_id, execution_type, template_code, strategy_id, name, user_id,
         conditions_snapshot, condition_summary, market, sectors, sort_by, sort_direction,
         result_limit, total_candidates, matched_count, execution_time_ms, executed_at)
        VALUES
        (#{executionId}, #{executionType}, #{templateCode}, #{strategyId}, #{name}, #{userId},
         #{conditionsSnapshot}::jsonb, #{conditionSummary}, #{market}, #{sectors}::jsonb,
         #{sortBy}::jsonb, #{sortDirection}::jsonb, #{resultLimit}, #{totalCandidates},
         #{matchedCount}, #{executionTimeMs}, #{executedAt})
        """)
    int insert(ScreeningExecution execution);

    @Select("""
        SELECT * FROM screening_executions
        WHERE user_id = #{userId}
          AND executed_at BETWEEN #{startDate} AND #{endDate}
        ORDER BY executed_at DESC
        LIMIT #{limit} OFFSET #{offset}
        """)
    List<ScreeningExecution> findByUserAndDateRange(
        String userId, OffsetDateTime startDate, OffsetDateTime endDate,
        int limit, int offset
    );
}
```

---

### 2.4 screening_results（選股結果明細表）

儲存每次選股的結果股票。

```sql
CREATE TABLE screening_results (
    id                  BIGSERIAL PRIMARY KEY,
    execution_id        VARCHAR(50) NOT NULL,
    rank                INTEGER NOT NULL,
    stock_id            VARCHAR(10) NOT NULL,
    stock_name          VARCHAR(50),
    market              VARCHAR(10),
    sector              VARCHAR(50),
    price_at_execution  DECIMAL(10,2),
    price_change        DECIMAL(10,2),
    price_change_pct    DECIMAL(8,4),
    matched_conditions  JSONB,
    key_metrics         JSONB,
    signal_id           VARCHAR(50),
    signal_score        DECIMAL(5,2),
    signal_grade        VARCHAR(5),
    signal_direction    VARCHAR(10),
    created_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_result_execution FOREIGN KEY (execution_id)
        REFERENCES screening_executions(execution_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_results_execution ON screening_results(execution_id);
CREATE INDEX idx_results_stock ON screening_results(stock_id, created_at DESC);
CREATE INDEX idx_results_execution_rank ON screening_results(execution_id, rank);

-- 分區策略（按月分區）
-- CREATE TABLE screening_results_202412 PARTITION OF screening_results
--     FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');

COMMENT ON TABLE screening_results IS '選股結果明細表';
COMMENT ON COLUMN screening_results.matched_conditions IS '符合的條件列表';
COMMENT ON COLUMN screening_results.key_metrics IS '關鍵指標數值';
```

**Key Metrics JSONB 結構**:
```json
{
  "pe": 12.5,
  "pb": 4.2,
  "roe": 25.3,
  "eps": 46.5,
  "dividend_yield": 2.1,
  "rsi": 55.3,
  "foreign_net_5d": 15000,
  "foreign_cont_days": 8
}
```

**MyBatis Mapper**:
```java
@Mapper
public interface ScreeningResultMapper {

    @Insert("""
        <script>
        INSERT INTO screening_results
        (execution_id, rank, stock_id, stock_name, market, sector,
         price_at_execution, price_change, price_change_pct,
         matched_conditions, key_metrics, signal_id, signal_score, signal_grade, signal_direction)
        VALUES
        <foreach collection="results" item="r" separator=",">
        (#{r.executionId}, #{r.rank}, #{r.stockId}, #{r.stockName}, #{r.market}, #{r.sector},
         #{r.priceAtExecution}, #{r.priceChange}, #{r.priceChangePct},
         #{r.matchedConditions}::jsonb, #{r.keyMetrics}::jsonb,
         #{r.signalId}, #{r.signalScore}, #{r.signalGrade}, #{r.signalDirection})
        </foreach>
        </script>
        """)
    int batchInsert(@Param("results") List<ScreeningResult> results);

    @Select("""
        SELECT * FROM screening_results
        WHERE execution_id = #{executionId}
        ORDER BY rank
        """)
    List<ScreeningResult> findByExecutionId(String executionId);

    @Select("""
        SELECT sr.*, se.executed_at
        FROM screening_results sr
        JOIN screening_executions se ON sr.execution_id = se.execution_id
        WHERE sr.stock_id = #{stockId}
          AND se.executed_at >= #{since}
        ORDER BY se.executed_at DESC
        LIMIT #{limit}
        """)
    List<ScreeningResultWithExecution> findByStockId(
        String stockId, OffsetDateTime since, int limit
    );
}
```

---

### 2.5 screening_performance（績效追蹤記錄表）

追蹤選股結果的後續價格表現。

```sql
CREATE TABLE screening_performance (
    id                  BIGSERIAL PRIMARY KEY,
    execution_id        VARCHAR(50) NOT NULL,
    stock_id            VARCHAR(10) NOT NULL,
    trade_date          DATE NOT NULL,
    price_at_execution  DECIMAL(10,2) NOT NULL,
    price_1d            DECIMAL(10,2),
    return_1d           DECIMAL(8,4),
    price_5d            DECIMAL(10,2),
    return_5d           DECIMAL(8,4),
    price_10d           DECIMAL(10,2),
    return_10d          DECIMAL(8,4),
    price_20d           DECIMAL(10,2),
    return_20d          DECIMAL(8,4),
    max_price           DECIMAL(10,2),
    max_return          DECIMAL(8,4),
    min_price           DECIMAL(10,2),
    min_return          DECIMAL(8,4),
    tracking_days       INTEGER DEFAULT 0,
    last_updated_at     TIMESTAMP WITH TIME ZONE,
    created_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_perf_execution FOREIGN KEY (execution_id)
        REFERENCES screening_executions(execution_id) ON DELETE CASCADE,
    CONSTRAINT uk_perf_execution_stock UNIQUE (execution_id, stock_id)
);

-- 索引
CREATE INDEX idx_performance_execution ON screening_performance(execution_id);
CREATE INDEX idx_performance_stock ON screening_performance(stock_id, trade_date DESC);
CREATE INDEX idx_performance_date ON screening_performance(trade_date);
CREATE INDEX idx_performance_tracking ON screening_performance(tracking_days) WHERE tracking_days < 20;

COMMENT ON TABLE screening_performance IS '選股績效追蹤表';
COMMENT ON COLUMN screening_performance.tracking_days IS '已追蹤天數';
```

**MyBatis Mapper**:
```java
@Mapper
public interface ScreeningPerformanceMapper {

    @Insert("""
        <script>
        INSERT INTO screening_performance
        (execution_id, stock_id, trade_date, price_at_execution)
        VALUES
        <foreach collection="items" item="p" separator=",">
        (#{p.executionId}, #{p.stockId}, #{p.tradeDate}, #{p.priceAtExecution})
        </foreach>
        ON CONFLICT (execution_id, stock_id) DO NOTHING
        </script>
        """)
    int batchInsert(@Param("items") List<ScreeningPerformance> items);

    @Update("""
        UPDATE screening_performance
        SET price_1d = #{price1d},
            return_1d = #{return1d},
            tracking_days = 1,
            last_updated_at = NOW()
        WHERE execution_id = #{executionId}
          AND stock_id = #{stockId}
        """)
    int update1DayPerformance(
        String executionId, String stockId,
        BigDecimal price1d, BigDecimal return1d
    );

    @Update("""
        UPDATE screening_performance
        SET price_5d = #{price5d},
            return_5d = #{return5d},
            tracking_days = 5,
            last_updated_at = NOW()
        WHERE execution_id = #{executionId}
          AND stock_id = #{stockId}
        """)
    int update5DayPerformance(
        String executionId, String stockId,
        BigDecimal price5d, BigDecimal return5d
    );

    @Select("""
        SELECT
            execution_id,
            COUNT(*) as total_stocks,
            AVG(return_1d) as avg_return_1d,
            AVG(return_5d) as avg_return_5d,
            AVG(return_10d) as avg_return_10d,
            COUNT(CASE WHEN return_5d > 0 THEN 1 END)::DECIMAL / COUNT(*) as win_rate_5d,
            MAX(return_5d) as max_return_5d,
            MIN(return_5d) as min_return_5d
        FROM screening_performance
        WHERE execution_id = #{executionId}
        GROUP BY execution_id
        """)
    PerformanceSummary getExecutionPerformanceSummary(String executionId);

    @Select("""
        SELECT
            COUNT(DISTINCT se.execution_id) as total_executions,
            COUNT(*) as total_stocks,
            AVG(sp.return_1d) as avg_return_1d,
            AVG(sp.return_5d) as avg_return_5d,
            COUNT(CASE WHEN sp.return_5d > 0 THEN 1 END)::DECIMAL / COUNT(*) as win_rate_5d
        FROM screening_executions se
        JOIN screening_performance sp ON se.execution_id = sp.execution_id
        WHERE se.strategy_id = #{strategyId}
          AND se.executed_at BETWEEN #{startDate} AND #{endDate}
        """)
    StrategyPerformanceSummary getStrategyPerformanceSummary(
        String strategyId, OffsetDateTime startDate, OffsetDateTime endDate
    );

    @Select("""
        SELECT * FROM screening_performance
        WHERE tracking_days < 20
          AND trade_date <= CURRENT_DATE - INTERVAL '1 day'
        ORDER BY trade_date
        LIMIT #{batchSize}
        """)
    List<ScreeningPerformance> findPendingPerformanceTracking(int batchSize);
}
```

---

### 2.6 condition_definitions（篩選條件定義表）

定義所有可用的篩選條件。

```sql
CREATE TABLE condition_definitions (
    id                  BIGSERIAL PRIMARY KEY,
    condition_code      VARCHAR(30) NOT NULL UNIQUE,
    condition_name      VARCHAR(50) NOT NULL,
    description         VARCHAR(200),
    category            VARCHAR(20) NOT NULL,
    data_source         VARCHAR(10) NOT NULL,
    data_type           VARCHAR(20) NOT NULL,
    operators           JSONB NOT NULL,
    allowed_values      JSONB,
    value_range         JSONB,
    unit                VARCHAR(20),
    example             JSONB,
    display_order       INTEGER DEFAULT 0,
    is_active           BOOLEAN DEFAULT TRUE,
    created_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at          TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT chk_cond_category CHECK (category IN ('FUNDAMENTAL', 'TECHNICAL', 'CHIP', 'SIGNAL', 'ATTRIBUTE')),
    CONSTRAINT chk_cond_source CHECK (data_source IN ('M06', 'M07', 'M08', 'M09', 'M13')),
    CONSTRAINT chk_cond_type CHECK (data_type IN ('NUMBER', 'ENUM', 'BOOLEAN', 'STRING'))
);

-- 初始資料（基本面條件）
INSERT INTO condition_definitions (condition_code, condition_name, description, category, data_source, data_type, operators, unit, example, display_order) VALUES
('F_PE', '本益比', '股價 / 每股盈餘', 'FUNDAMENTAL', 'M08', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', '倍',
 '{"operator": "BETWEEN", "values": [5, 15]}', 1),
('F_PB', '股價淨值比', '股價 / 每股淨值', 'FUNDAMENTAL', 'M08', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', '倍',
 '{"operator": "<=", "values": [2]}', 2),
('F_ROE', '股東權益報酬率', '淨利 / 股東權益', 'FUNDAMENTAL', 'M08', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', '%',
 '{"operator": ">=", "values": [15]}', 3),
('F_EPS', '每股盈餘', '淨利 / 在外流通股數', 'FUNDAMENTAL', 'M08', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', '元',
 '{"operator": ">=", "values": [3]}', 4),
('F_DIVIDEND_YIELD', '股利率', '每股股利 / 股價', 'FUNDAMENTAL', 'M08', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', '%',
 '{"operator": ">=", "values": [3]}', 5);

-- 技術面條件
INSERT INTO condition_definitions (condition_code, condition_name, description, category, data_source, data_type, operators, value_range, unit, example, display_order) VALUES
('T_RSI', 'RSI 指標', '相對強弱指標（14 日）', 'TECHNICAL', 'M07', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', '[0, 100]', NULL,
 '{"operator": "BETWEEN", "values": [30, 70]}', 10),
('T_KD_K', 'KD 指標 K 值', 'KD 隨機指標 K 值', 'TECHNICAL', 'M07', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', '[0, 100]', NULL,
 '{"operator": ">=", "values": [20]}', 11);

-- 籌碼面條件
INSERT INTO condition_definitions (condition_code, condition_name, description, category, data_source, data_type, operators, unit, example, display_order) VALUES
('C_FOREIGN_NET', '外資買賣超', '外資淨買超張數', 'CHIP', 'M09', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', '張',
 '{"operator": ">", "values": [0]}', 20),
('C_FOREIGN_CONT', '外資連續買賣', '外資連續買超天數', 'CHIP', 'M09', 'NUMBER',
 '["<", "<=", "=", ">=", ">"]', '日',
 '{"operator": ">=", "values": [3]}', 21);

-- 信號條件
INSERT INTO condition_definitions (condition_code, condition_name, description, category, data_source, data_type, operators, allowed_values, example, display_order) VALUES
('S_DIRECTION', '信號方向', 'M13 統一信號方向', 'SIGNAL', 'M13', 'ENUM',
 '["="]', '["BUY", "SELL", "HOLD"]',
 '{"operator": "=", "values": ["BUY"]}', 30),
('S_GRADE', '信號評級', 'M13 統一信號評級', 'SIGNAL', 'M13', 'ENUM',
 '["=", ">="]', '["A+", "A", "B+", "B", "C", "D"]',
 '{"operator": ">=", "values": ["B+"]}', 31),
('S_SCORE', '信號評分', 'M13 統一信號評分', 'SIGNAL', 'M13', 'NUMBER',
 '["<", "<=", "=", ">=", ">", "BETWEEN"]', NULL,
 '{"operator": ">=", "values": [70]}', 32);

COMMENT ON TABLE condition_definitions IS '篩選條件定義表';
COMMENT ON COLUMN condition_definitions.operators IS '支援的運算符列表';
COMMENT ON COLUMN condition_definitions.allowed_values IS 'ENUM 類型的允許值';
COMMENT ON COLUMN condition_definitions.value_range IS '數值類型的有效範圍 [min, max]';
```

---

## 3. 動態篩選查詢設計

### 3.1 篩選查詢建構器

```java
@Component
public class ScreeningQueryBuilder {

    /**
     * 建構動態篩選 SQL
     */
    public String buildScreeningQuery(ScreeningCondition conditions) {
        StringBuilder sql = new StringBuilder();

        sql.append("SELECT s.stock_id, s.stock_name, s.market, s.sector_name, ");
        sql.append("       sd.close_price, sd.price_change, sd.price_change_pct ");
        sql.append("FROM stocks s ");
        sql.append("JOIN stock_daily sd ON s.stock_id = sd.stock_id AND sd.trade_date = :tradeDate ");

        // 動態加入各維度 JOIN
        if (hasCondition(conditions, "FUNDAMENTAL")) {
            sql.append("LEFT JOIN fundamental_indicators fi ON s.stock_id = fi.stock_id ");
            sql.append("  AND fi.report_date = (SELECT MAX(report_date) FROM fundamental_indicators WHERE stock_id = s.stock_id) ");
        }

        if (hasCondition(conditions, "TECHNICAL")) {
            sql.append("LEFT JOIN technical_indicators ti ON s.stock_id = ti.stock_id AND ti.trade_date = :tradeDate ");
        }

        if (hasCondition(conditions, "CHIP")) {
            sql.append("LEFT JOIN chip_indicators ci ON s.stock_id = ci.stock_id AND ci.trade_date = :tradeDate ");
        }

        if (hasCondition(conditions, "SIGNAL")) {
            sql.append("LEFT JOIN unified_signals us ON s.stock_id = us.stock_id AND us.trade_date = :tradeDate ");
        }

        sql.append("WHERE s.status = 'ACTIVE' ");

        // 建構 WHERE 條件
        String whereClause = buildWhereClause(conditions);
        sql.append(whereClause);

        return sql.toString();
    }

    private String buildWhereClause(ScreeningCondition conditions) {
        return buildConditionGroup(conditions, "AND");
    }

    private String buildConditionGroup(Object conditionObj, String parentLogic) {
        if (conditionObj instanceof Map) {
            Map<String, Object> condition = (Map<String, Object>) conditionObj;

            if (condition.containsKey("logic")) {
                // 組合邏輯
                String logic = (String) condition.get("logic");
                List<Object> subConditions = (List<Object>) condition.get("conditions");

                List<String> parts = subConditions.stream()
                    .map(sub -> buildConditionGroup(sub, logic))
                    .collect(Collectors.toList());

                return "(" + String.join(" " + logic + " ", parts) + ")";
            } else {
                // 單一條件
                return buildSingleCondition(condition);
            }
        }
        return "";
    }

    private String buildSingleCondition(Map<String, Object> condition) {
        String code = (String) condition.get("condition_code");
        String operator = (String) condition.get("operator");
        List<Object> values = (List<Object>) condition.get("values");

        String column = getColumnMapping(code);

        switch (operator) {
            case "BETWEEN":
                return String.format("%s BETWEEN %s AND %s", column, values.get(0), values.get(1));
            case "IN":
                String inValues = values.stream()
                    .map(v -> "'" + v + "'")
                    .collect(Collectors.joining(","));
                return String.format("%s IN (%s)", column, inValues);
            case ">=":
                if (isEnumGradeComparison(code)) {
                    return buildGradeComparison(column, values.get(0).toString());
                }
                return String.format("%s >= %s", column, formatValue(values.get(0)));
            default:
                return String.format("%s %s %s", column, operator, formatValue(values.get(0)));
        }
    }

    private String getColumnMapping(String code) {
        Map<String, String> mapping = Map.of(
            "F_PE", "fi.pe_ratio",
            "F_ROE", "fi.roe",
            "T_RSI", "ti.rsi_14",
            "C_FOREIGN_CONT", "ci.foreign_cont_days",
            "S_GRADE", "us.grade",
            "S_SCORE", "us.unified_score"
        );
        return mapping.getOrDefault(code, code);
    }
}
```

### 3.2 MyBatis 動態 SQL

```xml
<!-- ScreeningMapper.xml -->
<mapper namespace="com.chris.fin_shark.m14.mapper.ScreeningMapper">

    <select id="executeScreening" resultType="ScreeningResultDto">
        SELECT
            s.stock_id,
            s.stock_name,
            s.market,
            sec.sector_name as sector,
            sd.close_price as price,
            sd.price_change,
            sd.price_change_pct,
            <if test="includeSignal">
            us.signal_id,
            us.unified_score as signal_score,
            us.grade as signal_grade,
            us.unified_direction as signal_direction,
            </if>
            <if test="includeFundamental">
            fi.pe_ratio as pe,
            fi.pb_ratio as pb,
            fi.roe,
            fi.eps,
            fi.dividend_yield,
            </if>
            <if test="includeTechnical">
            ti.rsi_14 as rsi,
            ti.macd,
            ti.ma5,
            ti.ma20,
            </if>
            <if test="includeChip">
            ci.foreign_net,
            ci.foreign_cont_days,
            ci.trust_net,
            ci.inst_total
            </if>
        FROM stocks s
        JOIN stock_daily sd ON s.stock_id = sd.stock_id
            AND sd.trade_date = #{tradeDate}
        LEFT JOIN sectors sec ON s.sector_code = sec.sector_code

        <if test="includeFundamental">
        LEFT JOIN fundamental_indicators fi ON s.stock_id = fi.stock_id
            AND fi.report_date = (
                SELECT MAX(report_date)
                FROM fundamental_indicators
                WHERE stock_id = s.stock_id
            )
        </if>

        <if test="includeTechnical">
        LEFT JOIN technical_indicators ti ON s.stock_id = ti.stock_id
            AND ti.trade_date = #{tradeDate}
        </if>

        <if test="includeChip">
        LEFT JOIN chip_indicators ci ON s.stock_id = ci.stock_id
            AND ci.trade_date = #{tradeDate}
        </if>

        <if test="includeSignal">
        LEFT JOIN unified_signals us ON s.stock_id = us.stock_id
            AND us.trade_date = #{tradeDate}
        </if>

        WHERE s.status = 'ACTIVE'

        <if test="market != null and market != 'ALL'">
            AND s.market = #{market}
        </if>

        <if test="sectors != null and sectors.size() > 0">
            AND s.sector_code IN
            <foreach collection="sectors" item="sec" open="(" separator="," close=")">
                #{sec}
            </foreach>
        </if>

        <if test="minPrice != null">
            AND sd.close_price >= #{minPrice}
        </if>

        <if test="maxPrice != null">
            AND sd.close_price &lt;= #{maxPrice}
        </if>

        <if test="minVolume != null">
            AND sd.volume >= #{minVolume}
        </if>

        <!-- 動態條件（由 Java 建構） -->
        ${dynamicWhereClause}

        <if test="sortBy != null and sortBy.size() > 0">
            ORDER BY
            <foreach collection="sortBy" item="col" index="idx" separator=",">
                ${col} ${sortDirections[idx]}
            </foreach>
        </if>
        <if test="sortBy == null or sortBy.size() == 0">
            ORDER BY sd.close_price DESC
        </if>

        LIMIT #{limit}
    </select>

</mapper>
```

---

## 4. 索引策略

### 4.1 查詢模式分析

| 查詢場景 | 使用頻率 | 關鍵欄位 |
|---------|---------|---------|
| 用戶策略列表 | 高 | owner_id, status |
| 策略執行 | 高 | strategy_id |
| 執行歷史 | 中 | user_id, executed_at |
| 績效查詢 | 中 | execution_id |
| 公開策略 | 中 | is_public, copy_count |

### 4.2 核心索引

```sql
-- 策略查詢
CREATE INDEX idx_strategies_owner_active ON screening_strategies(owner_id, status)
    WHERE status = 'ACTIVE';

-- 執行歷史查詢
CREATE INDEX idx_executions_user_recent ON screening_executions(user_id, executed_at DESC);

-- 績效追蹤
CREATE INDEX idx_performance_pending ON screening_performance(tracking_days, trade_date)
    WHERE tracking_days < 20;
```

---

## 5. 資料保留策略

| 表格 | 保留期限 | 清理策略 |
|-----|---------|---------|
| screening_strategies | 永久 | 標記刪除，不物理刪除 |
| screening_templates | 永久 | 不刪除 |
| screening_executions | 1 年 | 歸檔後刪除 |
| screening_results | 90 天 | 定期清理 |
| screening_performance | 90 天 | 隨執行記錄清理 |

---

## 6. 相關文檔

- [M14 功能需求](../specs/functional/M14-選股引擎功能需求.md)
- [M14 API 規格](../specs/api/M14-API規格.md)
- [M14 ERD](./erd/M14-ERD.md)

---

**文件維護者**: 後端工程師
**最後更新**: 2026-01-14
**下次審核**: 2026-04-14
