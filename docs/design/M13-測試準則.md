# M13-信號判斷引擎 測試準則

> **文件編號**: TEST-M13
> **模組名稱**: 信號判斷引擎 (Signal Judgment Engine)
> **版本**: v1.0
> **最後更新**: 2026-01-14
> **狀態**: Draft

---

## 1. 測試策略總覽

### 1.1 測試金字塔

```
                    ┌─────────────┐
                    │   E2E 測試   │  5%
                    │  整合驗證    │
                    └─────────────┘
               ┌─────────────────────┐
               │     整合測試        │  25%
               │  模組間互動驗證    │
               └─────────────────────┘
          ┌─────────────────────────────┐
          │          單元測試           │  70%
          │    收集/去重/合併/評分     │
          └─────────────────────────────┘
```

### 1.2 測試範圍

| 測試類型 | 涵蓋範圍 | 目標覆蓋率 |
|---------|---------|-----------|
| 單元測試 | 收集器、去重器、合併器、評分器 | 80% |
| 整合測試 | 完整處理流程、API、資料庫 | 70% |
| E2E 測試 | 上下游模組整合 | 關鍵路徑 |

---

## 2. 單元測試

### 2.1 信號收集器測試

```java
@ExtendWith(MockitoExtension.class)
class SignalCollectorTest {

    @Mock
    private TechnicalSignalRepository technicalRepo;

    @Mock
    private ChipSignalRepository chipRepo;

    @InjectMocks
    private SignalCollector collector;

    @Test
    @DisplayName("收集單一模組信號 - 正常情況")
    void collectFromModule_success() {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        List<TechnicalSignal> mockSignals = List.of(
            createTechnicalSignal("2330", "RSI_OVERSOLD", "BUY", 0.75),
            createTechnicalSignal("2454", "MACD_GOLDEN_CROSS", "BUY", 0.82)
        );
        when(technicalRepo.findBySignalDateAndIsCollectedFalse(tradeDate))
            .thenReturn(mockSignals);

        // When
        List<RawSignal> result = collector.collectFromModule("M07", tradeDate);

        // Then
        assertThat(result).hasSize(2);
        assertThat(result.get(0).getSourceModule()).isEqualTo("M07");
        assertThat(result.get(0).getSignalType()).isEqualTo("TECHNICAL");
    }

    @Test
    @DisplayName("收集多模組信號 - 平行收集")
    void collectAllModules_parallel() {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        String batchId = "BATCH_001";

        setupMockSignals(tradeDate);

        // When
        CollectionResult result = collector.collectDailySignals(tradeDate, batchId);

        // Then
        assertThat(result.getTotalCollected()).isGreaterThan(0);
        assertThat(result.getSummary()).containsKeys("M07", "M08", "M09");
    }

    @Test
    @DisplayName("收集信號 - 冪等性檢查")
    void collectSignals_idempotency() {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        String existingSignalId = "TECH_SIG_001";

        // 已存在的信號
        when(rawSignalRepo.existsBySourceSignalId(existingSignalId))
            .thenReturn(true);

        // When
        List<RawSignal> newSignals = collector.filterAlreadyCollected(
            List.of(createRawSignal(existingSignalId))
        );

        // Then
        assertThat(newSignals).isEmpty();
    }

    @Test
    @DisplayName("收集信號 - 格式轉換")
    void transformToUnifiedFormat_correctMapping() {
        // Given
        TechnicalSignal source = createTechnicalSignal(
            "2330", "RSI_OVERSOLD", "BUY", 0.75
        );
        source.setMetadata(Map.of("rsi_value", 25.5, "threshold", 30));

        // When
        RawSignal result = collector.transformToRawSignal(source, "M07");

        // Then
        assertThat(result.getSignalType()).isEqualTo("TECHNICAL");
        assertThat(result.getSignalDirection()).isEqualTo("BUY");
        assertThat(result.getSourceConfidence()).isEqualByComparingTo("0.75");
        assertThat(result.getSignalMetadata()).containsKey("rsi_value");
    }
}
```

### 2.2 信號去重器測試

```java
@ExtendWith(MockitoExtension.class)
class SignalDeduplicatorTest {

    @Mock
    private SemanticGroupRepository semanticGroupRepo;

    @InjectMocks
    private SignalDeduplicator deduplicator;

    @Test
    @DisplayName("完全重複去除 - 保留信心度最高者")
    void removeExactDuplicates_keepHighestConfidence() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignal("2330", "RSI_OVERSOLD", 0.75),
            createRawSignal("2330", "RSI_OVERSOLD", 0.82),  // 應保留
            createRawSignal("2330", "RSI_OVERSOLD", 0.68)
        );

        // When
        List<RawSignal> result = deduplicator.removeExactDuplicates(signals);

        // Then
        assertThat(result).hasSize(1);
        assertThat(result.get(0).getSourceConfidence())
            .isEqualByComparingTo("0.82");
    }

    @Test
    @DisplayName("語義重複合併 - 超賣指標群組")
    void mergeSemanticDuplicates_oversoldGroup() {
        // Given
        when(semanticGroupRepo.findAll()).thenReturn(List.of(
            createSemanticGroup("OVERSOLD_GROUP",
                List.of("RSI_OVERSOLD", "KD_OVERSOLD", "WILLIAMS_OVERSOLD"))
        ));

        List<RawSignal> signals = List.of(
            createRawSignal("2330", "RSI_OVERSOLD", 0.75),
            createRawSignal("2330", "KD_OVERSOLD", 0.70),
            createRawSignal("2330", "WILLIAMS_OVERSOLD", 0.65)
        );

        // When
        List<RawSignal> result = deduplicator.mergeSemanticDuplicates(
            signals, "2330", "BATCH_001"
        );

        // Then
        assertThat(result).hasSize(1);
        assertThat(result.get(0).getDedupStatus()).isEqualTo("MERGED");
    }

    @Test
    @DisplayName("時間窗口去重 - 3日內僅保留最新")
    void removeTemporalDuplicates_keepLatest() {
        // Given
        LocalDate today = LocalDate.of(2024, 12, 24);
        List<RawSignal> signals = List.of(
            createRawSignalWithDate("2330", "RSI_OVERSOLD", today.minusDays(2)),
            createRawSignalWithDate("2330", "RSI_OVERSOLD", today.minusDays(1)),
            createRawSignalWithDate("2330", "RSI_OVERSOLD", today)  // 應保留
        );

        // When
        List<RawSignal> result = deduplicator.removeTemporalDuplicates(
            signals, 3
        );

        // Then
        assertThat(result).hasSize(1);
        assertThat(result.get(0).getSignalDate()).isEqualTo(today);
    }

    @Test
    @DisplayName("去重流程 - 計算去重率")
    void deduplicate_calculateDedupRate() {
        // Given
        List<RawSignal> signals = createSignalsForDedup(10);

        // When
        DedupResult result = deduplicator.deduplicate(signals, "2330", "BATCH_001");

        // Then
        assertThat(result.getBeforeCount()).isEqualTo(10);
        assertThat(result.getAfterCount()).isLessThan(10);
        assertThat(result.getDedupRate()).isGreaterThan(0);
    }
}
```

### 2.3 信號合併器測試

```java
@ExtendWith(MockitoExtension.class)
class SignalMergerTest {

    @InjectMocks
    private SignalMerger merger;

    @Test
    @DisplayName("方向一致性 - STRONG (>=3 BUY, 0 SELL)")
    void calculateDirection_strong() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignal("BUY"),
            createRawSignal("BUY"),
            createRawSignal("BUY"),
            createRawSignal("BUY")
        );

        // When
        DirectionResult result = merger.calculateDirection(signals);

        // Then
        assertThat(result.getDirection()).isEqualTo("BUY");
        assertThat(result.getStrength()).isEqualTo("STRONG");
    }

    @Test
    @DisplayName("方向一致性 - MODERATE (2 BUY, 0-1 SELL)")
    void calculateDirection_moderate() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignal("BUY"),
            createRawSignal("BUY"),
            createRawSignal("SELL")
        );

        // When
        DirectionResult result = merger.calculateDirection(signals);

        // Then
        assertThat(result.getDirection()).isEqualTo("BUY");
        assertThat(result.getStrength()).isEqualTo("MODERATE");
    }

    @Test
    @DisplayName("方向一致性 - CONFLICT (>=2 BUY, >=2 SELL)")
    void calculateDirection_conflict() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignal("BUY"),
            createRawSignal("BUY"),
            createRawSignal("SELL"),
            createRawSignal("SELL")
        );

        // When
        DirectionResult result = merger.calculateDirection(signals);

        // Then
        assertThat(result.getDirection()).isEqualTo("HOLD");
        assertThat(result.getStrength()).isEqualTo("CONFLICT");
    }

    @Test
    @DisplayName("維度覆蓋計算")
    void calculateDimensionCoverage() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignalFromModule("M07"),
            createRawSignalFromModule("M08"),
            createRawSignalFromModule("M09"),
            createRawSignalFromModule("M07")  // 重複模組不重複計算
        );

        // When
        int coverage = merger.calculateDimensionCoverage(signals);

        // Then
        assertThat(coverage).isEqualTo(3);
    }

    @Test
    @DisplayName("統一信心度計算 - 加權平均")
    void calculateUnifiedConfidence_weighted() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignalWithConfidence("M07", 0.80),  // weight 0.20
            createRawSignalWithConfidence("M09", 0.90),  // weight 0.20
            createRawSignalWithConfidence("M08", 0.70)   // weight 0.20
        );

        // When
        double confidence = merger.calculateUnifiedConfidence(signals);

        // Then
        // (0.80*0.20 + 0.90*0.20 + 0.70*0.20) / 0.60 = 0.80
        assertThat(confidence).isCloseTo(0.80, within(0.01));
    }

    @Test
    @DisplayName("關鍵因素提取 - 取前3個")
    void extractKeyFactors_top3() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignalWithName("RSI 超賣反彈", 0.85),
            createRawSignalWithName("外資連買", 0.90),
            createRawSignalWithName("PE 偏低", 0.75),
            createRawSignalWithName("雙底型態", 0.70)
        );

        // When
        List<String> factors = merger.extractKeyFactors(signals);

        // Then
        assertThat(factors).hasSize(3);
        assertThat(factors.get(0)).isEqualTo("外資連買");  // 最高信心度
    }
}
```

### 2.4 信號評分器測試

```java
@ExtendWith(MockitoExtension.class)
class SignalScorerTest {

    @Mock
    private HistoricalAccuracyService historicalService;

    @Mock
    private MarketEnvironmentService marketService;

    @InjectMocks
    private SignalScorer scorer;

    @Test
    @DisplayName("信號強度評分 - STRONG + 高信心度")
    void scoreSignalStrength_strongDirection() {
        // Given
        UnifiedSignal signal = UnifiedSignal.builder()
            .directionStrength("STRONG")
            .unifiedConfidence(BigDecimal.valueOf(0.82))
            .build();

        // When
        double score = scorer.scoreSignalStrength(signal);

        // Then
        // (100 * 0.6) + (82 * 0.4) = 60 + 32.8 = 92.8
        assertThat(score).isCloseTo(92.8, within(0.1));
    }

    @Test
    @DisplayName("維度覆蓋評分 - 5維度+加分")
    void scoreDimensionCoverage_fiveDimensions() {
        // Given
        UnifiedSignal signal = UnifiedSignal.builder()
            .dimensionCoverage(5)
            .sourceModules("M07,M08,M09,M10,M11")
            .build();

        // When
        double score = scorer.scoreDimensionCoverage(signal);

        // Then
        // base: (5/6 * 80) = 66.67
        // bonus: 5+5+5+5 = 20 (技術+基本面+籌碼+策略)
        // total: min(86.67, 100) = 86.67
        assertThat(score).isCloseTo(86.67, within(1.0));
    }

    @Test
    @DisplayName("歷史績效評分 - 高準確率")
    void scoreHistoricalPerformance_highAccuracy() {
        // Given
        UnifiedSignal signal = UnifiedSignal.builder()
            .stockId("2330")
            .unifiedDirection("BUY")
            .signalTypes("MOMENTUM,INSTITUTIONAL")
            .build();

        when(historicalService.getAccuracy(any(), any(), any()))
            .thenReturn(new HistoricalData(0.72, 50));

        // When
        HistoricalResult result = scorer.scoreHistoricalPerformance(signal);

        // Then
        assertThat(result.getScore()).isEqualTo(100);  // >= 0.7 = 100
        assertThat(result.getAccuracy()).isCloseTo(0.72, within(0.01));
    }

    @Test
    @DisplayName("市場環境評分 - 多頭市場+強勢產業")
    void scoreMarketEnvironment_bullishStrong() {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        UnifiedSignal signal = UnifiedSignal.builder()
            .sectorCode("SEMICONDUCTOR")
            .unifiedDirection("BUY")
            .build();

        when(marketService.getMarketTrend(tradeDate)).thenReturn("BULLISH");
        when(marketService.getSectorStrength("SEMICONDUCTOR", tradeDate))
            .thenReturn("STRONG");

        // When
        MarketResult result = scorer.scoreMarketEnvironment(signal, tradeDate);

        // Then
        // trend: 100 * 0.6 = 60
        // strength: 100 * 0.4 = 40
        // bonus: 10 (BUY + BULLISH)
        assertThat(result.getScore()).isCloseTo(110, within(1.0));
    }

    @Test
    @DisplayName("評級分類 - 正確區間")
    void determineGrade_correctRanges() {
        assertThat(scorer.determineGrade(95)).isEqualTo("A+");
        assertThat(scorer.determineGrade(85)).isEqualTo("A");
        assertThat(scorer.determineGrade(75)).isEqualTo("B+");
        assertThat(scorer.determineGrade(65)).isEqualTo("B");
        assertThat(scorer.determineGrade(55)).isEqualTo("C");
        assertThat(scorer.determineGrade(45)).isEqualTo("D");
    }

    @Test
    @DisplayName("完整評分流程")
    void calculateScoringDetail_fullProcess() {
        // Given
        UnifiedSignal signal = createFullSignal();
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);

        setupMocks(tradeDate);

        // When
        SignalScoringDetail detail = scorer.calculateScoringDetail(signal, tradeDate);

        // Then
        assertThat(detail.getFinalScore()).isBetween(
            BigDecimal.ZERO, BigDecimal.valueOf(100)
        );
        assertThat(detail.getGrade()).isIn("A+", "A", "B+", "B", "C", "D");

        // 驗證加權計算
        BigDecimal expectedBase =
            detail.getStrengthWeighted()
            .add(detail.getCoverageWeighted())
            .add(detail.getHistoricalWeighted())
            .add(detail.getMarketWeighted())
            .add(detail.getFreshnessWeighted());
        assertThat(detail.getBaseTotalScore()).isEqualByComparingTo(expectedBase);
    }
}
```

---

## 3. 整合測試

### 3.1 完整處理流程測試

```java
@SpringBootTest
@Transactional
@TestPropertySource(properties = {
    "spring.profiles.active=test"
})
class SignalProcessingIntegrationTest {

    @Autowired
    private SignalProcessingOrchestrator orchestrator;

    @Autowired
    private RawSignalRepository rawSignalRepo;

    @Autowired
    private UnifiedSignalRepository unifiedSignalRepo;

    @Autowired
    private TestDataBuilder testDataBuilder;

    @Test
    @DisplayName("完整處理流程 - 收集到發布")
    void fullPipeline_collectionToPublish() {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        testDataBuilder.setupUpstreamSignals(tradeDate);

        // When
        ProcessingResult result = orchestrator.executeFullPipeline(tradeDate);

        // Then
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getUnifiedSignalsCreated()).isGreaterThan(0);

        // 驗證資料庫
        List<UnifiedSignal> unifiedSignals = unifiedSignalRepo.findByTradeDate(tradeDate);
        assertThat(unifiedSignals).isNotEmpty();

        // 驗證評分完成
        unifiedSignals.forEach(signal -> {
            assertThat(signal.getUnifiedScore()).isNotNull();
            assertThat(signal.getGrade()).isNotNull();
        });
    }

    @Test
    @DisplayName("去重效果驗證")
    void deduplication_effectiveRemoval() {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        testDataBuilder.setupDuplicateSignals(tradeDate, "2330", 5);

        // When
        orchestrator.executeFullPipeline(tradeDate);

        // Then
        List<RawSignal> rawSignals = rawSignalRepo.findBySignalDate(tradeDate);
        long keptCount = rawSignals.stream()
            .filter(s -> s.getDedupStatus().equals("KEPT"))
            .count();

        assertThat(keptCount).isLessThan(5);  // 應有去重效果
    }

    @Test
    @DisplayName("評分結果分布合理性")
    void scoring_reasonableDistribution() {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        testDataBuilder.setupVariedSignals(tradeDate, 100);

        // When
        orchestrator.executeFullPipeline(tradeDate);

        // Then
        List<UnifiedSignal> signals = unifiedSignalRepo.findByTradeDate(tradeDate);

        // 驗證評級分布
        Map<String, Long> gradeDistribution = signals.stream()
            .collect(Collectors.groupingBy(
                UnifiedSignal::getGrade,
                Collectors.counting()
            ));

        // 不應該全部都是 A+ 或全部都是 D
        assertThat(gradeDistribution.keySet().size()).isGreaterThan(2);
    }
}
```

### 3.2 API 整合測試

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class SignalApiIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private TestDataBuilder testDataBuilder;

    @Test
    @DisplayName("查詢統一信號 - 多條件篩選")
    void queryUnifiedSignals_multipleConditions() throws Exception {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        testDataBuilder.setupUnifiedSignals(tradeDate);

        // When & Then
        mockMvc.perform(get("/api/m13/signals/unified")
                .param("trade_date", tradeDate.toString())
                .param("direction", "BUY")
                .param("min_grade", "B+")
                .param("min_score", "70"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.content").isArray())
            .andExpect(jsonPath("$.data.content[0].unified_direction").value("BUY"))
            .andExpect(jsonPath("$.data.content[0].unified_score").value(greaterThan(70.0)));
    }

    @Test
    @DisplayName("每日推薦清單 - Top N")
    void dailyRecommendations_topN() throws Exception {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        testDataBuilder.setupUnifiedSignals(tradeDate);

        // When & Then
        mockMvc.perform(get("/api/m13/recommendations/daily")
                .param("trade_date", tradeDate.toString())
                .param("top_n", "10")
                .param("min_grade", "B"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.buy_recommendations").isArray())
            .andExpect(jsonPath("$.data.buy_recommendations.length()").value(lessThanOrEqualTo(10)))
            .andExpect(jsonPath("$.data.buy_recommendations[0].rank").value(1));
    }

    @Test
    @DisplayName("信號消費標記")
    void consumeSignal_markConsumed() throws Exception {
        // Given
        String signalId = testDataBuilder.createUnifiedSignal().getSignalId();

        // When & Then
        mockMvc.perform(post("/api/m13/signals/unified/{signalId}/consume", signalId)
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                        "consumer_module": "M14",
                        "consumer_action": "STOCK_SCREENING"
                    }
                    """))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.is_consumed").value(true));

        // 驗證資料庫更新
        mockMvc.perform(get("/api/m13/signals/unified/{signalId}", signalId))
            .andExpect(jsonPath("$.data.consumption_status.is_consumed").value(true));
    }

    @Test
    @DisplayName("信號追溯 - 完整鏈路")
    void traceSignal_fullChain() throws Exception {
        // Given
        String signalId = testDataBuilder.createUnifiedSignalWithContributors().getSignalId();

        // When & Then
        mockMvc.perform(get("/api/m13/signals/unified/{signalId}/trace", signalId))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.processing_trace").exists())
            .andExpect(jsonPath("$.data.original_signals").isArray())
            .andExpect(jsonPath("$.data.original_signals.length()").value(greaterThan(0)));
    }
}
```

### 3.3 資料庫整合測試

```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = Replace.NONE)
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class SignalRepositoryIntegrationTest {

    @Autowired
    private UnifiedSignalRepository unifiedSignalRepo;

    @Autowired
    private RawSignalRepository rawSignalRepo;

    @Autowired
    private TestEntityManager entityManager;

    @Test
    @DisplayName("統一信號 - 每日排行榜查詢效能")
    void findDailyTop_performance() {
        // Given
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        createSignalsForPerformanceTest(tradeDate, 500);
        entityManager.flush();
        entityManager.clear();

        // When
        StopWatch watch = new StopWatch();
        watch.start();

        List<UnifiedSignal> top20 = unifiedSignalRepo.findTopByTradeDateAndDirection(
            tradeDate, "BUY", PageRequest.of(0, 20)
        );

        watch.stop();

        // Then
        assertThat(top20).hasSize(20);
        assertThat(watch.getTotalTimeMillis()).isLessThan(100);  // < 100ms

        // 驗證排序正確
        for (int i = 0; i < top20.size() - 1; i++) {
            assertThat(top20.get(i).getUnifiedScore())
                .isGreaterThanOrEqualTo(top20.get(i + 1).getUnifiedScore());
        }
    }

    @Test
    @DisplayName("原始信號 - 批次插入")
    void batchInsert_rawSignals() {
        // Given
        List<RawSignal> signals = createRawSignals(100);

        // When
        rawSignalRepo.saveAll(signals);
        entityManager.flush();

        // Then
        assertThat(rawSignalRepo.count()).isEqualTo(100);
    }
}
```

---

## 4. 特定場景測試

### 4.1 邊界條件測試

```java
@Nested
@DisplayName("邊界條件測試")
class BoundaryConditionTests {

    @Test
    @DisplayName("單一信號股票 - 無需合併")
    void singleSignalStock_noMergeNeeded() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignal("2330", "RSI_OVERSOLD", "BUY", 0.75)
        );

        // When
        UnifiedSignal unified = merger.createUnifiedSignal("2330", signals);

        // Then
        assertThat(unified.getDimensionCoverage()).isEqualTo(1);
        assertThat(unified.getDirectionStrength()).isEqualTo("WEAK");
    }

    @Test
    @DisplayName("全部信號衝突 - CONFLICT 狀態")
    void allConflicting_conflictState() {
        // Given
        List<RawSignal> signals = List.of(
            createRawSignal("2330", "RSI_OVERSOLD", "BUY", 0.75),
            createRawSignal("2330", "MA_DEATH_CROSS", "SELL", 0.80),
            createRawSignal("2330", "FOREIGN_BUY", "BUY", 0.85),
            createRawSignal("2330", "PATTERN_HEAD_SHOULDERS", "SELL", 0.70)
        );

        // When
        DirectionResult result = merger.calculateDirection(signals);

        // Then
        assertThat(result.getDirection()).isEqualTo("HOLD");
        assertThat(result.getStrength()).isEqualTo("CONFLICT");
    }

    @Test
    @DisplayName("極端評分 - 最高分 100")
    void extremeScore_maxScore() {
        // Given
        UnifiedSignal signal = createPerfectSignal();

        // When
        SignalScoringDetail detail = scorer.calculateScoringDetail(signal);

        // Then
        assertThat(detail.getFinalScore()).isLessThanOrEqualTo(BigDecimal.valueOf(100));
    }

    @Test
    @DisplayName("無歷史資料 - 使用預設值")
    void noHistoricalData_useDefault() {
        // Given
        when(historicalService.getAccuracy(any(), any(), any()))
            .thenReturn(null);

        // When
        HistoricalResult result = scorer.scoreHistoricalPerformance(createSignal());

        // Then
        assertThat(result.getScore()).isEqualTo(50);  // 預設分數
        assertThat(result.getSampleCount()).isEqualTo(0);
    }
}
```

### 4.2 錯誤處理測試

```java
@Nested
@DisplayName("錯誤處理測試")
class ErrorHandlingTests {

    @Test
    @DisplayName("上游模組無資料 - 優雅處理")
    void upstreamNoData_gracefulHandling() {
        // Given
        when(technicalRepo.findBySignalDateAndIsCollectedFalse(any()))
            .thenReturn(Collections.emptyList());

        // When
        CollectionResult result = collector.collectFromModule("M07", LocalDate.now());

        // Then
        assertThat(result.getCollected()).isZero();
        assertThat(result.isSuccess()).isTrue();
    }

    @Test
    @DisplayName("部分模組失敗 - 繼續處理其他")
    void partialModuleFailure_continueOthers() {
        // Given
        when(technicalRepo.findBySignalDateAndIsCollectedFalse(any()))
            .thenThrow(new DatabaseException("Connection failed"));

        when(chipRepo.findBySignalDateAndIsCollectedFalse(any()))
            .thenReturn(List.of(createChipSignal()));

        // When
        CollectionResult result = collector.collectDailySignals(LocalDate.now(), "BATCH_001");

        // Then
        assertThat(result.getTotalCollected()).isGreaterThan(0);
        assertThat(result.getFailedModules()).contains("M07");
    }

    @Test
    @DisplayName("評分計算異常 - 記錄並跳過")
    void scoringException_logAndSkip() {
        // Given
        UnifiedSignal problematicSignal = createSignalWithInvalidData();

        // When
        ScoringResult result = scorer.scoreSignals(List.of(problematicSignal));

        // Then
        assertThat(result.getFailedCount()).isEqualTo(1);
        assertThat(result.getErrorMessages()).isNotEmpty();
    }
}
```

---

## 5. 效能測試

### 5.1 負載測試

```java
@SpringBootTest
@Disabled("Manual execution only")
class SignalPerformanceTest {

    @Autowired
    private SignalProcessingOrchestrator orchestrator;

    @Test
    @DisplayName("大量信號處理 - 2000筆在30分鐘內")
    void processLargeVolume_within30Minutes() {
        // Given
        LocalDate tradeDate = LocalDate.now();
        testDataBuilder.setupLargeVolumeSignals(tradeDate, 2000);

        // When
        StopWatch watch = new StopWatch();
        watch.start();

        ProcessingResult result = orchestrator.executeFullPipeline(tradeDate);

        watch.stop();

        // Then
        assertThat(result.isSuccess()).isTrue();
        assertThat(watch.getTotalTimeMillis()).isLessThan(30 * 60 * 1000);  // 30 分鐘
    }

    @Test
    @DisplayName("API 並發查詢 - 200 QPS")
    void concurrentApiQueries_200QPS() throws Exception {
        // Given
        testDataBuilder.setupTestData();
        int concurrentUsers = 50;
        int requestsPerUser = 4;

        ExecutorService executor = Executors.newFixedThreadPool(concurrentUsers);
        CountDownLatch latch = new CountDownLatch(concurrentUsers * requestsPerUser);
        AtomicInteger successCount = new AtomicInteger();

        // When
        StopWatch watch = new StopWatch();
        watch.start();

        for (int i = 0; i < concurrentUsers; i++) {
            executor.submit(() -> {
                for (int j = 0; j < requestsPerUser; j++) {
                    try {
                        mockMvc.perform(get("/api/m13/recommendations/daily"))
                            .andExpect(status().isOk());
                        successCount.incrementAndGet();
                    } catch (Exception e) {
                        // ignore
                    } finally {
                        latch.countDown();
                    }
                }
            });
        }

        latch.await();
        watch.stop();

        // Then
        double qps = (double) successCount.get() / (watch.getTotalTimeMillis() / 1000.0);
        assertThat(qps).isGreaterThan(200);
    }
}
```

---

## 6. 測試資料建構

```java
@Component
public class TestDataBuilder {

    @Autowired
    private RawSignalRepository rawSignalRepo;

    @Autowired
    private UnifiedSignalRepository unifiedSignalRepo;

    public void setupUpstreamSignals(LocalDate tradeDate) {
        // 建立技術信號
        List<RawSignal> techSignals = IntStream.range(0, 50)
            .mapToObj(i -> createRandomTechnicalSignal(tradeDate))
            .toList();

        // 建立籌碼信號
        List<RawSignal> chipSignals = IntStream.range(0, 80)
            .mapToObj(i -> createRandomChipSignal(tradeDate))
            .toList();

        rawSignalRepo.saveAll(techSignals);
        rawSignalRepo.saveAll(chipSignals);
    }

    public void setupDuplicateSignals(LocalDate tradeDate, String stockId, int count) {
        List<RawSignal> duplicates = IntStream.range(0, count)
            .mapToObj(i -> RawSignal.builder()
                .rawSignalId("RAW_" + UUID.randomUUID())
                .stockId(stockId)
                .signalCode("RSI_OVERSOLD")
                .signalDate(tradeDate)
                .signalDirection("BUY")
                .sourceConfidence(BigDecimal.valueOf(0.70 + i * 0.02))
                .build())
            .toList();

        rawSignalRepo.saveAll(duplicates);
    }

    public UnifiedSignal createUnifiedSignalWithContributors() {
        UnifiedSignal signal = UnifiedSignal.builder()
            .signalId("UNI_TEST_" + UUID.randomUUID())
            .stockId("2330")
            .tradeDate(LocalDate.now())
            .unifiedDirection("BUY")
            .directionStrength("STRONG")
            .unifiedScore(BigDecimal.valueOf(85.5))
            .grade("A")
            .dimensionCoverage(4)
            .build();

        // 添加組成明細
        List<SignalContributor> contributors = List.of(
            createContributor(signal, "M07", "RSI_OVERSOLD"),
            createContributor(signal, "M09", "FOREIGN_BUY")
        );
        signal.setContributors(contributors);

        return unifiedSignalRepo.save(signal);
    }
}
```

---

## 7. 相關文檔

- [M13 功能需求](../specs/functional/M13-信號引擎功能需求.md)
- [M13 業務流程](./M13-業務流程.md)
- [M13 API 規格](../specs/api/M13-API規格.md)

---

**文件維護者**: QA 工程師
**最後更新**: 2026-01-14
**下次審核**: 2026-04-14
