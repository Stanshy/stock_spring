# M16-回測系統 測試準則

> **文件編號**: TEST-M16
> **模組名稱**: 回測系統 (Backtesting System)
> **版本**: v1.0
> **最後更新**: 2026-01-15
> **狀態**: Draft

---

## 1. 測試總覽

### 1.1 測試範圍

| 測試類型 | 測試對象 | 測試重點 |
|---------|---------|---------|
| 單元測試 | 引擎元件 | 計算邏輯、交易執行、績效計算 |
| 整合測試 | 回測流程 | 端到端回測、資料載入、結果儲存 |
| API 測試 | REST Controller | 請求/回應、參數驗證 |
| 效能測試 | 回測執行 | 執行時間、記憶體使用 |
| Job 測試 | 排程任務 | 清理、恢復機制 |

### 1.2 測試優先級

```
┌─────────────────────────────────────────────────────────────────┐
│                       M16 測試優先級                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  P0 - 核心功能（必須通過）                                       │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  • 回測執行正確性（買賣邏輯、成本計算）                   │   │
│  │  • 績效指標計算（報酬率、夏普比率、最大回撤）            │   │
│  │  • 停損停利機制                                           │   │
│  │  • 資料一致性                                             │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  P1 - 重要功能                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  • 參數最佳化                                             │   │
│  │  • 多策略比較                                             │   │
│  │  • 基準比較 (Alpha/Beta)                                 │   │
│  │  • 回測任務管理 (建立、查詢、刪除)                       │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  P2 - 一般功能                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  • 回測範本                                               │   │
│  │  • 結果匯出                                               │   │
│  │  • 滾動回測 (Walk-forward)                               │   │
│  │  • 清理 Job                                               │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 單元測試

### 2.1 交易執行測試

```java
@ExtendWith(MockitoExtension.class)
class TradeExecutorTest {

    @InjectMocks
    private TradeExecutor tradeExecutor;

    @Test
    @DisplayName("買入交易 - 正確計算成本")
    void executeBuy_correctCostCalculation() {
        // Given
        TradingCost cost = TradingCost.builder()
            .commissionRate(new BigDecimal("0.001425"))
            .taxRate(new BigDecimal("0.003"))
            .slippage(new BigDecimal("0.001"))
            .build();

        BigDecimal price = new BigDecimal("500.00");
        int shares = 1000;

        // When
        TradeResult result = tradeExecutor.executeBuy(price, shares, cost);

        // Then
        // 交易金額 = 500 * 1000 = 500,000
        // 手續費 = 500,000 * 0.001425 = 712.5
        // 滑價 = 500,000 * 0.001 = 500
        // 總成本 = 500,000 + 712.5 + 500 = 501,212.5

        assertThat(result.getTradeAmount()).isEqualByComparingTo("500000");
        assertThat(result.getCommission()).isEqualByComparingTo("712.50");
        assertThat(result.getSlippage()).isEqualByComparingTo("500");
        assertThat(result.getTax()).isEqualByComparingTo("0");  // 買入無稅
        assertThat(result.getNetAmount()).isEqualByComparingTo("501212.50");
    }

    @Test
    @DisplayName("賣出交易 - 正確計算含稅成本")
    void executeSell_correctCostWithTax() {
        // Given
        TradingCost cost = TradingCost.builder()
            .commissionRate(new BigDecimal("0.001425"))
            .taxRate(new BigDecimal("0.003"))
            .slippage(new BigDecimal("0.001"))
            .build();

        BigDecimal price = new BigDecimal("550.00");
        int shares = 1000;

        // When
        TradeResult result = tradeExecutor.executeSell(price, shares, cost);

        // Then
        // 交易金額 = 550 * 1000 = 550,000
        // 手續費 = 550,000 * 0.001425 = 783.75
        // 交易稅 = 550,000 * 0.003 = 1,650
        // 滑價 = 550,000 * 0.001 = 550
        // 淨收入 = 550,000 - 783.75 - 1,650 - 550 = 547,016.25

        assertThat(result.getTradeAmount()).isEqualByComparingTo("550000");
        assertThat(result.getTax()).isEqualByComparingTo("1650");
        assertThat(result.getNetAmount()).isEqualByComparingTo("547016.25");
    }

    @Test
    @DisplayName("部位大小計算 - 固定金額模式")
    void calculateShares_fixedAmount() {
        // Given
        PositionSizing sizing = PositionSizing.builder()
            .mode(PositionSizingMode.FIXED_AMOUNT)
            .fixedAmount(new BigDecimal("100000"))
            .build();

        BigDecimal price = new BigDecimal("525.00");

        // When
        int shares = tradeExecutor.calculateShares(sizing, price, null);

        // Then
        // shares = floor(100,000 / 525) = 190
        assertThat(shares).isEqualTo(190);
    }

    @Test
    @DisplayName("部位大小計算 - 百分比模式")
    void calculateShares_percentOfCapital() {
        // Given
        PositionSizing sizing = PositionSizing.builder()
            .mode(PositionSizingMode.PERCENT)
            .percentOfCapital(new BigDecimal("0.10"))
            .build();

        BigDecimal price = new BigDecimal("500.00");
        BigDecimal portfolioValue = new BigDecimal("1000000");

        // When
        int shares = tradeExecutor.calculateShares(sizing, price, portfolioValue);

        // Then
        // shares = floor(1,000,000 * 0.10 / 500) = 200
        assertThat(shares).isEqualTo(200);
    }
}
```

### 2.2 風險檢查測試

```java
@ExtendWith(MockitoExtension.class)
class RiskCheckerTest {

    @InjectMocks
    private RiskChecker riskChecker;

    @Test
    @DisplayName("停損檢查 - 觸發停損")
    void checkStopLoss_triggered() {
        // Given
        Position position = Position.builder()
            .stockId("2330")
            .entryPrice(new BigDecimal("500.00"))
            .shares(1000)
            .entryDate(LocalDate.of(2023, 1, 1))
            .build();

        ExitRules rules = ExitRules.builder()
            .stopLoss(new BigDecimal("0.07"))  // 7% 停損
            .build();

        BigDecimal currentPrice = new BigDecimal("460.00");  // 下跌 8%

        // When
        ExitSignal signal = riskChecker.check(position, currentPrice, rules, LocalDate.of(2023, 1, 15));

        // Then
        assertThat(signal.shouldExit()).isTrue();
        assertThat(signal.getReason()).isEqualTo(ExitReason.STOP_LOSS);
    }

    @Test
    @DisplayName("停損檢查 - 未觸發")
    void checkStopLoss_notTriggered() {
        // Given
        Position position = Position.builder()
            .stockId("2330")
            .entryPrice(new BigDecimal("500.00"))
            .shares(1000)
            .build();

        ExitRules rules = ExitRules.builder()
            .stopLoss(new BigDecimal("0.07"))
            .build();

        BigDecimal currentPrice = new BigDecimal("480.00");  // 下跌 4%

        // When
        ExitSignal signal = riskChecker.check(position, currentPrice, rules, LocalDate.now());

        // Then
        assertThat(signal.shouldExit()).isFalse();
    }

    @Test
    @DisplayName("停利檢查 - 觸發停利")
    void checkTakeProfit_triggered() {
        // Given
        Position position = Position.builder()
            .entryPrice(new BigDecimal("500.00"))
            .shares(1000)
            .build();

        ExitRules rules = ExitRules.builder()
            .takeProfit(new BigDecimal("0.15"))  // 15% 停利
            .build();

        BigDecimal currentPrice = new BigDecimal("580.00");  // 上漲 16%

        // When
        ExitSignal signal = riskChecker.check(position, currentPrice, rules, LocalDate.now());

        // Then
        assertThat(signal.shouldExit()).isTrue();
        assertThat(signal.getReason()).isEqualTo(ExitReason.TAKE_PROFIT);
    }

    @Test
    @DisplayName("最大持有天數檢查 - 超過上限")
    void checkMaxHoldingDays_exceeded() {
        // Given
        Position position = Position.builder()
            .entryDate(LocalDate.of(2023, 1, 1))
            .build();

        ExitRules rules = ExitRules.builder()
            .maxHoldingDays(30)
            .build();

        LocalDate currentDate = LocalDate.of(2023, 2, 5);  // 35 天後

        // When
        ExitSignal signal = riskChecker.check(position, new BigDecimal("500"), rules, currentDate);

        // Then
        assertThat(signal.shouldExit()).isTrue();
        assertThat(signal.getReason()).isEqualTo(ExitReason.MAX_HOLDING);
    }

    @Test
    @DisplayName("移動停損檢查 - 高點回落觸發")
    void checkTrailingStop_triggered() {
        // Given
        Position position = Position.builder()
            .entryPrice(new BigDecimal("500.00"))
            .highestPrice(new BigDecimal("600.00"))  // 最高到過 600
            .build();

        ExitRules rules = ExitRules.builder()
            .trailingStop(new BigDecimal("0.10"))  // 10% 移動停損
            .build();

        BigDecimal currentPrice = new BigDecimal("530.00");  // 從高點回落 11.7%

        // When
        ExitSignal signal = riskChecker.check(position, currentPrice, rules, LocalDate.now());

        // Then
        assertThat(signal.shouldExit()).isTrue();
        assertThat(signal.getReason()).isEqualTo(ExitReason.TRAILING_STOP);
    }
}
```

### 2.3 績效計算測試

```java
@ExtendWith(MockitoExtension.class)
class MetricsCalculatorTest {

    @InjectMocks
    private MetricsCalculator calculator;

    @Test
    @DisplayName("總報酬率計算")
    void calculateTotalReturn() {
        // Given
        BigDecimal initialCapital = new BigDecimal("1000000");
        BigDecimal finalValue = new BigDecimal("1234567");

        // When
        BigDecimal totalReturn = calculator.calculateTotalReturn(initialCapital, finalValue);

        // Then
        // (1,234,567 - 1,000,000) / 1,000,000 = 0.234567
        assertThat(totalReturn).isEqualByComparingTo("0.234567");
    }

    @Test
    @DisplayName("年化報酬率計算")
    void calculateAnnualizedReturn() {
        // Given
        BigDecimal totalReturn = new BigDecimal("0.50");  // 50% 總報酬
        int tradingDays = 500;  // 約 2 年

        // When
        BigDecimal annualized = calculator.calculateAnnualizedReturn(totalReturn, tradingDays);

        // Then
        // (1 + 0.50)^(252/500) - 1 ≈ 0.2247
        assertThat(annualized).isCloseTo(new BigDecimal("0.2247"), Offset.offset(new BigDecimal("0.01")));
    }

    @Test
    @DisplayName("夏普比率計算")
    void calculateSharpeRatio() {
        // Given
        BigDecimal annualizedReturn = new BigDecimal("0.15");
        BigDecimal riskFreeRate = new BigDecimal("0.02");
        BigDecimal volatility = new BigDecimal("0.18");

        // When
        BigDecimal sharpe = calculator.calculateSharpeRatio(annualizedReturn, riskFreeRate, volatility);

        // Then
        // (0.15 - 0.02) / 0.18 = 0.7222
        assertThat(sharpe).isEqualByComparingTo("0.7222");
    }

    @Test
    @DisplayName("最大回撤計算")
    void calculateMaxDrawdown() {
        // Given
        List<BigDecimal> portfolioValues = Arrays.asList(
            new BigDecimal("1000000"),
            new BigDecimal("1100000"),  // 新高
            new BigDecimal("1050000"),  // 開始回撤
            new BigDecimal("950000"),   // 谷底 (從 110 萬回撤 13.6%)
            new BigDecimal("1000000"),
            new BigDecimal("1200000")   // 新高
        );

        // When
        BigDecimal maxDrawdown = calculator.calculateMaxDrawdown(portfolioValues);

        // Then
        // (1,100,000 - 950,000) / 1,100,000 = 0.1364
        assertThat(maxDrawdown).isEqualByComparingTo("0.1364");
    }

    @Test
    @DisplayName("勝率計算")
    void calculateWinRate() {
        // Given
        List<BacktestTrade> trades = Arrays.asList(
            createTrade(10000),   // 獲利
            createTrade(5000),    // 獲利
            createTrade(-3000),   // 虧損
            createTrade(8000),    // 獲利
            createTrade(-2000)    // 虧損
        );

        // When
        BigDecimal winRate = calculator.calculateWinRate(trades);

        // Then
        // 3 wins / 5 trades = 0.60
        assertThat(winRate).isEqualByComparingTo("0.60");
    }

    @Test
    @DisplayName("獲利因子計算")
    void calculateProfitFactor() {
        // Given
        List<BacktestTrade> trades = Arrays.asList(
            createTrade(10000),
            createTrade(5000),
            createTrade(-3000),
            createTrade(8000),
            createTrade(-2000)
        );

        // When
        BigDecimal profitFactor = calculator.calculateProfitFactor(trades);

        // Then
        // Total wins = 23,000, Total losses = 5,000
        // Profit Factor = 23,000 / 5,000 = 4.60
        assertThat(profitFactor).isEqualByComparingTo("4.60");
    }

    private BacktestTrade createTrade(int profitLoss) {
        return BacktestTrade.builder()
            .profitLoss(new BigDecimal(profitLoss))
            .build();
    }
}
```

---

## 3. 整合測試

### 3.1 回測執行整合測試

```java
@SpringBootTest
@Transactional
class BacktestExecutionIntegrationTest {

    @Autowired
    private BacktestService backtestService;

    @Autowired
    private BacktestTaskRepository taskRepository;

    @Autowired
    private BacktestResultRepository resultRepository;

    @Autowired
    private TestDataSetup testDataSetup;

    @BeforeEach
    void setUp() {
        testDataSetup.setupHistoricalData();  // 準備測試用歷史數據
    }

    @Test
    @DisplayName("完整回測流程 - 成功執行")
    void executeBacktest_success() {
        // Given
        BacktestTaskRequest request = BacktestTaskRequest.builder()
            .backtestName("整合測試回測")
            .signalSource(SignalSource.SIGNAL)
            .targetStocks(TargetStocks.specific(List.of("2330")))
            .period(Period.of(LocalDate.of(2023, 1, 1), LocalDate.of(2023, 12, 31)))
            .initialCapital(new BigDecimal("1000000"))
            .tradingSettings(TradingSettings.fixedAmount(100000, 5))
            .exitRules(ExitRules.builder()
                .stopLoss(new BigDecimal("0.07"))
                .takeProfit(new BigDecimal("0.15"))
                .build())
            .build();

        // When
        BacktestTask task = backtestService.createBacktest(request);
        backtestService.executeBacktest(task.getBacktestId());

        // Then
        BacktestTask completed = taskRepository.findByBacktestId(task.getBacktestId()).get();
        assertThat(completed.getStatus()).isEqualTo(BacktestStatus.COMPLETED);

        BacktestResult result = resultRepository.findByBacktestId(task.getBacktestId()).get();
        assertThat(result.getTotalTrades()).isGreaterThan(0);
        assertThat(result.getFinalValue()).isNotNull();
        assertThat(result.getSharpeRatio()).isNotNull();
    }

    @Test
    @DisplayName("回測執行 - 無交易信號")
    void executeBacktest_noSignals() {
        // Given: 使用不會產生信號的條件
        BacktestTaskRequest request = BacktestTaskRequest.builder()
            .backtestName("無信號測試")
            .signalSource(SignalSource.SIGNAL)
            .targetStocks(TargetStocks.specific(List.of("9999")))  // 不存在的股票
            .period(Period.of(LocalDate.of(2023, 1, 1), LocalDate.of(2023, 3, 31)))
            .initialCapital(new BigDecimal("1000000"))
            .tradingSettings(TradingSettings.fixedAmount(100000, 5))
            .build();

        // When
        BacktestTask task = backtestService.createBacktest(request);
        backtestService.executeBacktest(task.getBacktestId());

        // Then
        BacktestResult result = resultRepository.findByBacktestId(task.getBacktestId()).get();
        assertThat(result.getTotalTrades()).isZero();
        assertThat(result.getFinalValue()).isEqualByComparingTo("1000000");  // 維持原資金
        assertThat(result.getTotalReturn()).isEqualByComparingTo("0");
    }

    @Test
    @DisplayName("回測執行 - 停損觸發")
    void executeBacktest_stopLossTriggered() {
        // Given: 設定會觸發停損的情境
        testDataSetup.setupDecliningStock("TEST01");  // 準備下跌股票數據

        BacktestTaskRequest request = BacktestTaskRequest.builder()
            .backtestName("停損測試")
            .signalSource(SignalSource.CUSTOM)
            .customEntryDate(LocalDate.of(2023, 1, 3))  // 強制進場
            .targetStocks(TargetStocks.specific(List.of("TEST01")))
            .period(Period.of(LocalDate.of(2023, 1, 1), LocalDate.of(2023, 6, 30)))
            .initialCapital(new BigDecimal("1000000"))
            .tradingSettings(TradingSettings.fixedAmount(500000, 1))
            .exitRules(ExitRules.builder()
                .stopLoss(new BigDecimal("0.07"))
                .build())
            .build();

        // When
        BacktestTask task = backtestService.createBacktest(request);
        backtestService.executeBacktest(task.getBacktestId());

        // Then
        List<BacktestTrade> trades = tradeRepository.findByBacktestId(task.getBacktestId());
        BacktestTrade sellTrade = trades.stream()
            .filter(t -> t.getTradeType() == TradeType.SELL)
            .findFirst()
            .orElseThrow();

        assertThat(sellTrade.getExitReason()).isEqualTo(ExitReason.STOP_LOSS);
        assertThat(sellTrade.getReturnPct()).isLessThan(new BigDecimal("-0.07"));
    }
}
```

### 3.2 參數最佳化整合測試

```java
@SpringBootTest
@Transactional
class OptimizationIntegrationTest {

    @Autowired
    private OptimizationService optimizationService;

    @Test
    @DisplayName("參數最佳化 - 網格搜尋")
    void optimize_gridSearch() {
        // Given
        String backtestId = createBaseBacktest();

        OptimizationRequest request = OptimizationRequest.builder()
            .optimizationMethod(OptimizationMethod.GRID_SEARCH)
            .targetMetric(TargetMetric.SHARPE_RATIO)
            .parameters(List.of(
                ParameterRange.range("stopLoss", 0.05, 0.10, 0.01),  // 6 個值
                ParameterRange.values("maxHoldingDays", 10, 20, 30)   // 3 個值
            ))
            .build();

        // When
        OptimizationResult result = optimizationService.optimize(backtestId, request);

        // Then
        assertThat(result.getTotalCombinations()).isEqualTo(18);  // 6 × 3
        assertThat(result.getCompletedCombinations()).isEqualTo(18);
        assertThat(result.getBestResult()).isNotNull();
        assertThat(result.getBestResult().getParameters()).containsKeys("stopLoss", "maxHoldingDays");
    }
}
```

---

## 4. API 測試

### 4.1 回測建立 API

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class BacktestApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("POST /api/v1/backtests - 建立回測成功")
    void createBacktest_success() throws Exception {
        String requestBody = """
            {
                "backtestName": "API測試回測",
                "signalSource": "SIGNAL",
                "targetStocks": {
                    "mode": "SPECIFIC",
                    "stockIds": ["2330", "2317"]
                },
                "period": {
                    "startDate": "2023-01-01",
                    "endDate": "2023-12-31"
                },
                "initialCapital": 1000000,
                "tradingSettings": {
                    "positionSizing": "FIXED_AMOUNT",
                    "fixedAmount": 100000,
                    "maxPositions": 5
                },
                "exitRules": {
                    "stopLoss": 0.07,
                    "takeProfit": 0.15
                }
            }
            """;

        mockMvc.perform(post("/api/v1/backtests")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.code").value(201))
            .andExpect(jsonPath("$.data.backtestId").exists())
            .andExpect(jsonPath("$.data.status").value("CREATED"));
    }

    @Test
    @DisplayName("POST /api/v1/backtests - 期間超過限制")
    void createBacktest_periodExceeded() throws Exception {
        String requestBody = """
            {
                "backtestName": "超長期間測試",
                "signalSource": "SIGNAL",
                "targetStocks": { "mode": "SPECIFIC", "stockIds": ["2330"] },
                "period": {
                    "startDate": "2010-01-01",
                    "endDate": "2025-12-31"
                },
                "initialCapital": 1000000,
                "tradingSettings": {
                    "positionSizing": "FIXED_AMOUNT",
                    "fixedAmount": 100000,
                    "maxPositions": 5
                }
            }
            """;

        mockMvc.perform(post("/api/v1/backtests")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.error.errorCode").value("M16-003"));
    }

    @Test
    @DisplayName("POST /api/v1/backtests/{id}/execute - 執行回測")
    void executeBacktest_success() throws Exception {
        // Given
        String backtestId = createTestBacktest();

        // When & Then
        mockMvc.perform(post("/api/v1/backtests/" + backtestId + "/execute"))
            .andExpect(status().isAccepted())
            .andExpect(jsonPath("$.data.status").value("RUNNING"));
    }

    @Test
    @DisplayName("GET /api/v1/backtests/{id}/report - 取得報告")
    void getReport_success() throws Exception {
        // Given
        String backtestId = createAndExecuteBacktest();

        // When & Then
        mockMvc.perform(get("/api/v1/backtests/" + backtestId + "/report"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.performanceSummary").exists())
            .andExpect(jsonPath("$.data.tradeStatistics").exists())
            .andExpect(jsonPath("$.data.monthlyReturns").exists());
    }

    @Test
    @DisplayName("GET /api/v1/backtests/{id}/trades - 分頁查詢交易")
    void getTrades_pagination() throws Exception {
        // Given
        String backtestId = createAndExecuteBacktest();

        // When & Then
        mockMvc.perform(get("/api/v1/backtests/" + backtestId + "/trades")
                .param("page", "1")
                .param("size", "10"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.trades").isArray())
            .andExpect(jsonPath("$.data.pagination.page").value(1))
            .andExpect(jsonPath("$.data.pagination.size").value(10));
    }
}
```

---

## 5. 效能測試

### 5.1 回測執行效能測試

```java
@SpringBootTest
class BacktestPerformanceTest {

    @Autowired
    private BacktestService backtestService;

    @Test
    @DisplayName("單股回測效能 - 3年期間")
    void singleStockBacktest_3years() {
        // Given
        BacktestTask task = createTask(
            List.of("2330"),
            LocalDate.of(2021, 1, 1),
            LocalDate.of(2023, 12, 31)
        );

        // When
        long startTime = System.currentTimeMillis();
        backtestService.executeBacktest(task.getBacktestId());
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(5000);  // < 5 秒
        log.info("單股 3 年回測耗時: {} ms", duration);
    }

    @Test
    @DisplayName("多股回測效能 - 10股/3年")
    void multiStockBacktest_10stocks_3years() {
        // Given
        List<String> stocks = List.of(
            "2330", "2317", "2454", "2412", "2308",
            "2881", "2882", "2891", "2886", "2884"
        );
        BacktestTask task = createTask(
            stocks,
            LocalDate.of(2021, 1, 1),
            LocalDate.of(2023, 12, 31)
        );

        // When
        long startTime = System.currentTimeMillis();
        backtestService.executeBacktest(task.getBacktestId());
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(30000);  // < 30 秒
        log.info("10 股 3 年回測耗時: {} ms", duration);
    }

    @Test
    @DisplayName("大規模回測效能 - 100股/1年")
    void largeScaleBacktest_100stocks_1year() {
        // Given
        List<String> stocks = testDataSetup.getTop100Stocks();
        BacktestTask task = createTask(
            stocks,
            LocalDate.of(2023, 1, 1),
            LocalDate.of(2023, 12, 31)
        );

        // When
        long startTime = System.currentTimeMillis();
        backtestService.executeBacktest(task.getBacktestId());
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(180000);  // < 3 分鐘
        log.info("100 股 1 年回測耗時: {} ms", duration);
    }

    @Test
    @DisplayName("參數最佳化效能 - 100 組合")
    void optimization_100combinations() {
        // Given
        String backtestId = createBaseBacktest();
        OptimizationRequest request = createOptimizationRequest(100);

        // When
        long startTime = System.currentTimeMillis();
        optimizationService.optimize(backtestId, request);
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(600000);  // < 10 分鐘
        log.info("100 組合最佳化耗時: {} ms", duration);
    }
}
```

---

## 6. 測試覆蓋率要求

| 模組 | 行覆蓋率 | 分支覆蓋率 | 說明 |
|-----|---------|-----------|------|
| TradeExecutor | ≥ 90% | ≥ 85% | 交易執行核心 |
| RiskChecker | ≥ 90% | ≥ 85% | 停損停利邏輯 |
| MetricsCalculator | ≥ 95% | ≥ 90% | 績效計算必須精確 |
| BacktestEngine | ≥ 85% | ≥ 80% | 回測引擎 |
| Controller | ≥ 80% | ≥ 75% | API 層 |
| Optimization | ≥ 80% | ≥ 75% | 最佳化功能 |

---

## 7. 相關文檔

- [M16 功能需求](../specs/functional/M16-回測系統功能需求.md)
- [M16 API 規格](../specs/api/M16-API規格.md)
- [M16 效能考量](./M16-效能考量.md)

---

**文件維護者**: QA 工程師
**最後更新**: 2026-01-15
**下次審核**: 2026-04-15
