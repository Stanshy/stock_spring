# M13-信號判斷引擎 效能考量

> **文件編號**: PERF-M13
> **模組名稱**: 信號判斷引擎 (Signal Judgment Engine)
> **版本**: v1.0
> **最後更新**: 2026-01-14
> **狀態**: Draft

---

## 1. 效能目標

### 1.1 SLA 定義

| 指標 | 目標值 | 說明 |
|-----|-------|------|
| 每日處理總時間 | < 30 分鐘 | 從收集開始到發布完成 |
| 信號收集時間 | < 10 分鐘 | 6 個模組全部收集完成 |
| 去重處理時間 | < 3 分鐘 | 處理 1000 筆原始信號 |
| 合併處理時間 | < 3 分鐘 | 產生統一信號 |
| 評分處理時間 | < 5 分鐘 | 完成所有信號評分 |
| API 查詢回應時間 | P95 < 100ms | 統一信號查詢 |
| 推薦清單查詢 | P95 < 50ms | 每日推薦 Top N |

### 1.2 容量規劃

| 指標 | 當前預估 | 目標支援 |
|-----|---------|---------|
| 每日原始信號 | 500-800 筆 | 2,000 筆 |
| 去重後信號 | 350-600 筆 | 1,500 筆 |
| 統一信號 | 150-250 筆 | 500 筆 |
| 歷史信號（1年） | 50,000 筆 | 125,000 筆 |
| 並發查詢 | 50 QPS | 200 QPS |

---

## 2. 批次處理優化

### 2.1 信號收集優化

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         信號收集效能優化策略                                   │
└─────────────────────────────────────────────────────────────────────────────┘

策略 1: 平行收集
────────────────────────────────────────────────────────────────────────────
原始方式（串行）:
M07 ──────────▶ M08 ──────────▶ M09 ──────────▶ M10 ──────────▶ ...
    2 min          1 min          3 min          1 min
總計: 約 10 分鐘

優化方式（平行）:
M07 ──────────▶ ┐
    2 min       │
M08 ────▶ ─────│
    1 min       │
M09 ────────────▶ ──────▶ 彙整
    3 min       │
M10 ────▶ ─────│
    1 min       │
M11 ──────▶ ───│
    2 min       │
M12 ────▶ ─────┘
    1 min
總計: 約 3 分鐘（以最長為準 + 彙整時間）
```

**實作程式碼**:
```java
@Service
public class ParallelSignalCollector {

    @Autowired
    private List<ModuleSignalSource> signalSources;

    private final ExecutorService executor = Executors.newFixedThreadPool(6);

    public CollectionResult collectInParallel(LocalDate tradeDate, String batchId) {
        List<CompletableFuture<ModuleResult>> futures = signalSources.stream()
            .map(source -> CompletableFuture.supplyAsync(
                () -> collectFromModule(source, tradeDate, batchId),
                executor
            ))
            .toList();

        // 等待所有收集完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // 彙整結果
        return aggregateResults(futures);
    }

    private ModuleResult collectFromModule(
        ModuleSignalSource source, LocalDate tradeDate, String batchId
    ) {
        StopWatch watch = new StopWatch();
        watch.start();

        try {
            List<RawSignal> signals = source.collect(tradeDate);
            watch.stop();

            return ModuleResult.success(
                source.getModuleCode(),
                signals,
                watch.getTotalTimeMillis()
            );
        } catch (Exception e) {
            watch.stop();
            return ModuleResult.failure(source.getModuleCode(), e);
        }
    }
}
```

### 2.2 去重處理優化

```
策略 2: 分組平行去重
────────────────────────────────────────────────────────────────────────────
                    ┌─────────────────────────────────────────┐
                    │         原始信號 (800 筆)                │
                    └─────────────────────────────────────────┘
                                       │
                                       │ 按股票代碼分組
                                       ▼
        ┌─────────────┬─────────────┬─────────────┬─────────────┐
        │  Group A    │  Group B    │  Group C    │  Group D    │
        │  (200筆)    │  (200筆)    │  (200筆)    │  (200筆)    │
        │  2330,2454  │  2317,2382  │  2884,2412  │  ...        │
        └─────────────┴─────────────┴─────────────┴─────────────┘
               │             │             │             │
               │  平行處理   │  平行處理   │  平行處理   │
               ▼             ▼             ▼             ▼
        ┌─────────────┬─────────────┬─────────────┬─────────────┐
        │  Thread 1   │  Thread 2   │  Thread 3   │  Thread 4   │
        │  去重處理   │  去重處理   │  去重處理   │  去重處理   │
        └─────────────┴─────────────┴─────────────┴─────────────┘
               │             │             │             │
               └─────────────┴─────────────┴─────────────┘
                                       │
                                       ▼
                    ┌─────────────────────────────────────────┐
                    │        去重後信號 (600 筆)               │
                    └─────────────────────────────────────────┘
```

**實作程式碼**:
```java
@Service
public class ParallelDeduplicator {

    private final ForkJoinPool forkJoinPool = new ForkJoinPool(4);

    public DedupResult deduplicateInParallel(List<RawSignal> signals) {
        // 按股票分組
        Map<String, List<RawSignal>> byStock = signals.stream()
            .collect(Collectors.groupingBy(RawSignal::getStockId));

        // 平行處理每組
        List<RawSignal> deduplicated = forkJoinPool.submit(() ->
            byStock.entrySet().parallelStream()
                .flatMap(entry -> deduplicateStock(entry.getValue()).stream())
                .toList()
        ).join();

        return new DedupResult(signals.size(), deduplicated.size());
    }

    private List<RawSignal> deduplicateStock(List<RawSignal> stockSignals) {
        // 完全重複去除
        stockSignals = removeExactDuplicates(stockSignals);

        // 語義重複合併
        stockSignals = mergeSemanticDuplicates(stockSignals);

        // 時間窗口去重
        stockSignals = removeTemporalDuplicates(stockSignals);

        return stockSignals;
    }
}
```

### 2.3 評分處理優化

```java
@Service
public class BatchSignalScorer {

    private static final int BATCH_SIZE = 50;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void scoreBatch(List<UnifiedSignal> signals, LocalDate tradeDate) {
        // 預載入共用資料
        MarketContext marketContext = loadMarketContext(tradeDate);
        Map<String, SectorStrength> sectorStrengths = loadSectorStrengths(tradeDate);
        Map<String, HistoricalAccuracy> historicalData = preloadHistoricalData(signals);

        // 分批平行處理
        Lists.partition(signals, BATCH_SIZE).parallelStream()
            .forEach(batch -> scoreBatchWithContext(
                batch, marketContext, sectorStrengths, historicalData
            ));
    }

    private Map<String, HistoricalAccuracy> preloadHistoricalData(
        List<UnifiedSignal> signals
    ) {
        // 批次查詢歷史準確率，避免 N+1 問題
        Set<String> signalPatterns = signals.stream()
            .map(this::extractSignalPattern)
            .collect(Collectors.toSet());

        return historicalRepository.findByPatterns(signalPatterns).stream()
            .collect(Collectors.toMap(
                HistoricalAccuracy::getPattern,
                Function.identity()
            ));
    }
}
```

---

## 3. 查詢效能優化

### 3.1 索引策略

```sql
-- 核心查詢索引
────────────────────────────────────────────────────────────────────────────

-- 1. 每日推薦排行榜（最高頻查詢）
-- 查詢: WHERE trade_date = ? AND direction = ? ORDER BY unified_score DESC
CREATE INDEX idx_unified_daily_rank
    ON unified_signals(trade_date, unified_direction, unified_score DESC);

-- 2. 股票信號歷史
-- 查詢: WHERE stock_id = ? AND trade_date BETWEEN ? AND ?
CREATE INDEX idx_unified_stock_history
    ON unified_signals(stock_id, trade_date DESC);

-- 3. 評級篩選
-- 查詢: WHERE trade_date = ? AND grade IN ('A+', 'A')
CREATE INDEX idx_unified_grade_filter
    ON unified_signals(trade_date, grade);

-- 4. 消費狀態查詢
-- 查詢: WHERE is_consumed = FALSE AND trade_date = ?
CREATE INDEX idx_unified_unconsumed
    ON unified_signals(is_consumed, trade_date)
    WHERE is_consumed = FALSE;

-- 5. 組合索引 for 複雜查詢
CREATE INDEX idx_unified_composite
    ON unified_signals(trade_date, unified_direction, grade, unified_score DESC);
```

### 3.2 查詢優化

```java
@Repository
public class UnifiedSignalQueryOptimizer {

    /**
     * 每日推薦清單查詢 - 使用覆蓋索引
     */
    @Query(nativeQuery = true, value = """
        SELECT signal_id, stock_id, stock_name, unified_score, grade,
               direction_strength, dimension_coverage, key_factors
        FROM unified_signals
        WHERE trade_date = :tradeDate
          AND unified_direction = :direction
          AND grade IN ('A+', 'A', 'B+', 'B')
        ORDER BY unified_score DESC
        LIMIT :limit
        """)
    List<RecommendationProjection> findDailyRecommendations(
        @Param("tradeDate") LocalDate tradeDate,
        @Param("direction") String direction,
        @Param("limit") int limit
    );

    /**
     * 避免 SELECT * 的投影查詢
     */
    public interface RecommendationProjection {
        String getSignalId();
        String getStockId();
        String getStockName();
        BigDecimal getUnifiedScore();
        String getGrade();
        String getDirectionStrength();
        Integer getDimensionCoverage();
        String getKeyFactors();
    }
}
```

### 3.3 分頁優化

```java
@Service
public class SignalPaginationService {

    /**
     * 使用游標分頁避免 OFFSET 效能問題
     */
    public Page<UnifiedSignal> findWithCursor(
        LocalDate tradeDate,
        String direction,
        String lastSignalId,
        BigDecimal lastScore,
        int limit
    ) {
        // 使用複合游標 (score, id) 實現穩定分頁
        List<UnifiedSignal> signals = jdbcTemplate.query("""
            SELECT *
            FROM unified_signals
            WHERE trade_date = ?
              AND unified_direction = ?
              AND (unified_score, signal_id) < (?, ?)
            ORDER BY unified_score DESC, signal_id DESC
            LIMIT ?
            """,
            signalRowMapper,
            tradeDate, direction, lastScore, lastSignalId, limit + 1
        );

        boolean hasNext = signals.size() > limit;
        if (hasNext) {
            signals = signals.subList(0, limit);
        }

        return new CursorPage<>(signals, hasNext);
    }
}
```

---

## 4. 快取策略

### 4.1 Redis 快取架構

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          M13 快取架構                                        │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                               Redis                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │  每日推薦清單快取                                                       │ │
│  │  Key: m13:reco:{date}:{direction}                                      │ │
│  │  TTL: 24 小時                                                          │ │
│  │  Type: Sorted Set (score = unified_score)                              │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │  統一信號詳情快取                                                       │ │
│  │  Key: m13:signal:{signalId}                                            │ │
│  │  TTL: 2 小時                                                           │ │
│  │  Type: Hash                                                            │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │  統計快取                                                               │ │
│  │  Key: m13:stats:{date}:overview                                        │ │
│  │  TTL: 30 分鐘                                                          │ │
│  │  Type: Hash                                                            │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │  語義群組快取                                                           │ │
│  │  Key: m13:semantic-groups                                               │ │
│  │  TTL: 1 天                                                             │ │
│  │  Type: Hash                                                            │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 快取實作

```java
@Service
public class SignalCacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private static final String RECO_KEY = "m13:reco:%s:%s";
    private static final String SIGNAL_KEY = "m13:signal:%s";
    private static final String STATS_KEY = "m13:stats:%s:overview";

    /**
     * 快取每日推薦清單
     */
    public void cacheRecommendations(
        LocalDate date, String direction, List<UnifiedSignal> signals
    ) {
        String key = String.format(RECO_KEY, date, direction);

        ZSetOperations<String, Object> zSetOps = redisTemplate.opsForZSet();

        signals.forEach(signal ->
            zSetOps.add(key, signal.getSignalId(), signal.getUnifiedScore().doubleValue())
        );

        redisTemplate.expire(key, Duration.ofHours(24));
    }

    /**
     * 從快取取得 Top N 推薦
     */
    public List<String> getTopRecommendations(
        LocalDate date, String direction, int topN
    ) {
        String key = String.format(RECO_KEY, date, direction);

        Set<Object> signalIds = redisTemplate.opsForZSet()
            .reverseRange(key, 0, topN - 1);

        if (signalIds == null || signalIds.isEmpty()) {
            return Collections.emptyList();
        }

        return signalIds.stream()
            .map(Object::toString)
            .toList();
    }

    /**
     * 快取信號詳情
     */
    @Cacheable(value = "signal-detail", key = "#signalId")
    public UnifiedSignalDto getSignalDetail(String signalId) {
        return signalRepository.findBySignalId(signalId)
            .map(this::toDto)
            .orElse(null);
    }

    /**
     * 發布時更新快取
     */
    @CacheEvict(value = {"daily-recommendations", "signal-stats"}, allEntries = true)
    public void onSignalsPublished(LocalDate date) {
        // 快取失效後會重新載入
    }
}
```

### 4.3 快取預熱

```java
@Component
public class SignalCacheWarmer implements ApplicationListener<SignalPublishedEvent> {

    @Autowired
    private SignalCacheService cacheService;

    @Autowired
    private UnifiedSignalRepository signalRepository;

    @Override
    public void onApplicationEvent(SignalPublishedEvent event) {
        LocalDate date = event.getTradeDate();

        // 預熱買入推薦
        List<UnifiedSignal> buySignals = signalRepository.findTopByDirection(
            date, "BUY", 100
        );
        cacheService.cacheRecommendations(date, "BUY", buySignals);

        // 預熱賣出推薦
        List<UnifiedSignal> sellSignals = signalRepository.findTopByDirection(
            date, "SELL", 50
        );
        cacheService.cacheRecommendations(date, "SELL", sellSignals);

        // 預熱統計資料
        SignalStatistics stats = signalRepository.calculateStatistics(date);
        cacheService.cacheStatistics(date, stats);

        log.info("Signal cache warmed for date: {}", date);
    }
}
```

---

## 5. 記憶體優化

### 5.1 批次處理記憶體控制

```java
@Service
public class MemoryEfficientProcessor {

    private static final int STREAM_BATCH_SIZE = 100;

    /**
     * 使用 Stream 處理大量信號，避免 OOM
     */
    public void processLargeDataset(LocalDate date) {
        try (Stream<RawSignal> signalStream = rawSignalRepository
            .streamBySignalDate(date)) {

            // 分批處理，控制記憶體使用
            AtomicInteger counter = new AtomicInteger();
            List<RawSignal> batch = new ArrayList<>(STREAM_BATCH_SIZE);

            signalStream.forEach(signal -> {
                batch.add(signal);

                if (batch.size() >= STREAM_BATCH_SIZE) {
                    processBatch(batch);
                    batch.clear();

                    // 定期清理
                    if (counter.incrementAndGet() % 10 == 0) {
                        entityManager.clear();
                    }
                }
            });

            // 處理剩餘
            if (!batch.isEmpty()) {
                processBatch(batch);
            }
        }
    }

    /**
     * 投影查詢減少記憶體使用
     */
    @Query("SELECT new com.chris.fin_shark.m13.dto.SignalSummary(" +
           "s.signalId, s.stockId, s.unifiedScore, s.grade) " +
           "FROM UnifiedSignal s WHERE s.tradeDate = :date")
    List<SignalSummary> findSummariesByDate(@Param("date") LocalDate date);
}
```

### 5.2 DTO 投影

```java
/**
 * 輕量級 DTO，只包含必要欄位
 */
@Value
public class SignalSummary {
    String signalId;
    String stockId;
    BigDecimal unifiedScore;
    String grade;
}

/**
 * 推薦清單 DTO，排除大欄位
 */
@Value
public class RecommendationDto {
    String signalId;
    String stockId;
    String stockName;
    BigDecimal unifiedScore;
    String grade;
    String directionStrength;
    int dimensionCoverage;
    // 排除 signalMetadata, keyFactors 等大欄位
}
```

---

## 6. 資料庫連線優化

### 6.1 連線池配置

```yaml
spring:
  datasource:
    hikari:
      # 基礎配置
      pool-name: M13-Signal-Pool
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000        # 5 分鐘
      max-lifetime: 1800000       # 30 分鐘
      connection-timeout: 30000   # 30 秒

      # 效能調優
      auto-commit: false
      validation-timeout: 5000
      leak-detection-threshold: 60000

      # 批次操作優化
      data-source-properties:
        reWriteBatchedInserts: true
        prepareThreshold: 5
```

### 6.2 批次寫入優化

```java
@Repository
public class BatchInsertRepository {

    @PersistenceContext
    private EntityManager entityManager;

    private static final int BATCH_SIZE = 50;

    /**
     * 批次插入統一信號
     */
    @Transactional
    public void batchInsert(List<UnifiedSignal> signals) {
        for (int i = 0; i < signals.size(); i++) {
            entityManager.persist(signals.get(i));

            // 每 BATCH_SIZE 筆 flush 一次
            if ((i + 1) % BATCH_SIZE == 0) {
                entityManager.flush();
                entityManager.clear();
            }
        }

        // 處理剩餘
        entityManager.flush();
        entityManager.clear();
    }

    /**
     * JDBC 批次插入（更高效能）
     */
    public void jdbcBatchInsert(List<RawSignal> signals) {
        jdbcTemplate.batchUpdate(
            """
            INSERT INTO raw_signals
            (raw_signal_id, source_signal_id, source_module, signal_type,
             signal_code, signal_name, stock_id, signal_date, signal_direction,
             source_confidence, signal_metadata, batch_id, collected_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?::jsonb, ?, ?)
            """,
            signals,
            BATCH_SIZE,
            (ps, signal) -> {
                ps.setString(1, signal.getRawSignalId());
                ps.setString(2, signal.getSourceSignalId());
                // ... 其他欄位
            }
        );
    }
}
```

---

## 7. 監控與調優

### 7.1 效能監控指標

```java
@Component
public class SignalPerformanceMetrics {

    private final MeterRegistry registry;

    // 處理時間
    private final Timer collectionTimer;
    private final Timer dedupTimer;
    private final Timer mergeTimer;
    private final Timer scoringTimer;
    private final Timer publishTimer;

    // 處理量
    private final Counter signalsCollected;
    private final Counter signalsUnified;

    // 查詢效能
    private final Timer queryTimer;

    public SignalPerformanceMetrics(MeterRegistry registry) {
        this.registry = registry;

        this.collectionTimer = Timer.builder("m13.processing.collection")
            .description("Signal collection duration")
            .register(registry);

        this.dedupTimer = Timer.builder("m13.processing.deduplication")
            .description("Signal deduplication duration")
            .register(registry);

        // ... 其他指標
    }

    public void recordCollection(Duration duration, int count) {
        collectionTimer.record(duration);
        signalsCollected.increment(count);
    }

    public void recordQuery(String queryType, Duration duration) {
        Timer.builder("m13.query.duration")
            .tag("type", queryType)
            .register(registry)
            .record(duration);
    }
}
```

### 7.2 慢查詢監控

```java
@Aspect
@Component
public class SlowQueryMonitor {

    private static final long SLOW_QUERY_THRESHOLD_MS = 500;

    @Autowired
    private AlertService alertService;

    @Around("@annotation(org.springframework.data.jpa.repository.Query)")
    public Object monitorQuery(ProceedingJoinPoint joinPoint) throws Throwable {
        StopWatch watch = new StopWatch();
        watch.start();

        try {
            return joinPoint.proceed();
        } finally {
            watch.stop();

            if (watch.getTotalTimeMillis() > SLOW_QUERY_THRESHOLD_MS) {
                String methodName = joinPoint.getSignature().toShortString();
                Object[] args = joinPoint.getArgs();

                log.warn("Slow query detected: {} took {}ms with args: {}",
                    methodName, watch.getTotalTimeMillis(), Arrays.toString(args));

                // 發送告警
                if (watch.getTotalTimeMillis() > SLOW_QUERY_THRESHOLD_MS * 2) {
                    alertService.sendAlert(AlertLevel.MEDIUM,
                        "M13 Slow Query",
                        String.format("Query %s took %dms",
                            methodName, watch.getTotalTimeMillis())
                    );
                }
            }
        }
    }
}
```

---

## 8. 效能調優檢查清單

### 8.1 開發階段

- [ ] 查詢使用投影而非完整實體
- [ ] 批次操作使用 JDBC batch
- [ ] 避免 N+1 查詢問題
- [ ] 適當使用索引
- [ ] 大量資料使用 Stream 處理

### 8.2 部署階段

- [ ] 連線池大小調優
- [ ] Redis 快取配置
- [ ] JVM 記憶體配置
- [ ] 資料庫參數調優

### 8.3 運維階段

- [ ] 監控慢查詢
- [ ] 定期清理過期資料
- [ ] 索引使用率分析
- [ ] 快取命中率監控

---

## 9. 相關文檔

- [M13 功能需求](../specs/functional/M13-信號引擎功能需求.md)
- [M13 資料庫設計](./M13-資料庫設計.md)
- [M13 Job 排程配置](../deployment/M13-Job排程配置.md)

---

**文件維護者**: 後端工程師
**最後更新**: 2026-01-14
**下次審核**: 2026-04-14
