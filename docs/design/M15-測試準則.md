# M15-警報通知系統 測試準則

> **文件編號**: TEST-M15
> **模組名稱**: 警報通知系統 (Alert Notification System)
> **版本**: v1.0
> **最後更新**: 2026-01-15
> **狀態**: Draft

---

## 1. 測試總覽

### 1.1 測試範圍

| 測試類型 | 測試對象 | 測試重點 |
|---------|---------|---------|
| 單元測試 | RuleMatcher, NotificationSender | 規則比對、發送邏輯 |
| 整合測試 | AlertTriggerService | 端到端警報流程 |
| API 測試 | REST Controller | 請求/回應驗證 |
| 效能測試 | 規則比對、通知發送 | 吞吐量、延遲 |
| Job 測試 | 排程任務 | 監控、重試、清理 |

### 1.2 測試優先級

```
┌─────────────────────────────────────────────────────────────────────┐
│                       M15 測試優先級                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  P0 - 核心功能（必須通過）                                           │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  • 規則比對邏輯正確性                                         │   │
│  │  • 警報觸發流程                                               │   │
│  │  • 通知發送成功                                               │   │
│  │  • 節流機制                                                   │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  P1 - 重要功能                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  • 規則 CRUD 操作                                             │   │
│  │  • 靜音設定                                                   │   │
│  │  • 每日限額控制                                               │   │
│  │  • 重試機制                                                   │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  P2 - 一般功能                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  • 批次通知                                                   │   │
│  │  • 警報歷史查詢                                               │   │
│  │  • Line/FCM 整合                                              │   │
│  │  • 統計功能                                                   │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 單元測試

### 2.1 規則比對測試

```java
@ExtendWith(MockitoExtension.class)
class RuleMatcherTest {

    @InjectMocks
    private RuleMatcher ruleMatcher;

    @Test
    @DisplayName("比對股票 ID - 符合")
    void matchStockId_match() {
        // Given
        AlertRule rule = createRule(List.of("2330", "2317"), null, null, null);
        UnifiedSignal signal = createSignal("2330", "BUY", "A", 85);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isTrue();
    }

    @Test
    @DisplayName("比對股票 ID - 不符合")
    void matchStockId_notMatch() {
        // Given
        AlertRule rule = createRule(List.of("2330", "2317"), null, null, null);
        UnifiedSignal signal = createSignal("2454", "BUY", "A", 85);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isFalse();
    }

    @Test
    @DisplayName("比對股票 ID - 全市場（stockIds 為空）")
    void matchStockId_allMarket() {
        // Given
        AlertRule rule = createRule(null, null, null, null);  // stockIds 為空
        UnifiedSignal signal = createSignal("2454", "BUY", "A", 85);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isTrue();
    }

    @Test
    @DisplayName("比對方向 - 符合")
    void matchDirection_match() {
        // Given
        AlertRule rule = createRule(null, List.of("BUY"), null, null);
        UnifiedSignal signal = createSignal("2330", "BUY", "A", 85);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isTrue();
    }

    @Test
    @DisplayName("比對方向 - 不符合")
    void matchDirection_notMatch() {
        // Given
        AlertRule rule = createRule(null, List.of("BUY"), null, null);
        UnifiedSignal signal = createSignal("2330", "SELL", "A", 85);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isFalse();
    }

    @Test
    @DisplayName("比對評級 - A 符合 minGrade B+")
    void matchGrade_A_match_Bplus() {
        // Given
        AlertRule rule = createRule(null, null, "B+", null);
        UnifiedSignal signal = createSignal("2330", "BUY", "A", 85);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isTrue();  // A > B+
    }

    @Test
    @DisplayName("比對評級 - C 不符合 minGrade B+")
    void matchGrade_C_notMatch_Bplus() {
        // Given
        AlertRule rule = createRule(null, null, "B+", null);
        UnifiedSignal signal = createSignal("2330", "BUY", "C", 55);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isFalse();  // C < B+
    }

    @Test
    @DisplayName("比對評分 - 符合")
    void matchScore_match() {
        // Given
        AlertRule rule = createRule(null, null, null, 70);
        UnifiedSignal signal = createSignal("2330", "BUY", "A", 85);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isTrue();
    }

    @Test
    @DisplayName("比對評分 - 不符合")
    void matchScore_notMatch() {
        // Given
        AlertRule rule = createRule(null, null, null, 80);
        UnifiedSignal signal = createSignal("2330", "BUY", "B", 65);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isFalse();
    }

    @Test
    @DisplayName("複合條件比對")
    void matchMultipleConditions() {
        // Given: 股票 2330, 方向 BUY, 評級 >= B+, 評分 >= 70
        AlertRule rule = createRule(
            List.of("2330"),
            List.of("BUY"),
            "B+",
            70
        );
        UnifiedSignal signal = createSignal("2330", "BUY", "A", 85);

        // When
        boolean result = ruleMatcher.isMatch(rule, signal);

        // Then
        assertThat(result).isTrue();
    }

    // 輔助方法
    private AlertRule createRule(List<String> stockIds, List<String> directions,
                                  String minGrade, Integer minScore) {
        RuleConditions conditions = new RuleConditions();
        conditions.setStockIds(stockIds);
        conditions.setDirections(directions);
        conditions.setMinGrade(minGrade);
        conditions.setMinScore(minScore != null ? BigDecimal.valueOf(minScore) : null);

        AlertRule rule = new AlertRule();
        rule.setConditions(conditions);
        rule.setEnabled(true);
        return rule;
    }

    private UnifiedSignal createSignal(String stockId, String direction,
                                        String grade, int score) {
        UnifiedSignal signal = new UnifiedSignal();
        signal.setStockId(stockId);
        signal.setUnifiedDirection(direction);
        signal.setGrade(grade);
        signal.setUnifiedScore(BigDecimal.valueOf(score));
        return signal;
    }
}
```

### 2.2 節流測試

```java
@ExtendWith(MockitoExtension.class)
class ThrottleServiceTest {

    @InjectMocks
    private ThrottleService throttleService;

    @Mock
    private DailyNotificationCountRepository countRepository;

    @Mock
    private AlertHistoryRepository historyRepository;

    @Test
    @DisplayName("每日限額檢查 - 未超過")
    void dailyLimitCheck_notExceeded() {
        // Given
        String userId = "user001";
        when(countRepository.findTodayCount(userId, NotificationChannel.EMAIL))
            .thenReturn(Optional.of(new DailyNotificationCount(10)));

        UserNotificationSettings settings = new UserNotificationSettings();
        settings.setDailyLimitEmail(20);

        // When
        boolean exceeded = throttleService.isExceededDailyLimit(
            userId, NotificationChannel.EMAIL, settings);

        // Then
        assertThat(exceeded).isFalse();
    }

    @Test
    @DisplayName("每日限額檢查 - 已超過")
    void dailyLimitCheck_exceeded() {
        // Given
        String userId = "user001";
        when(countRepository.findTodayCount(userId, NotificationChannel.EMAIL))
            .thenReturn(Optional.of(new DailyNotificationCount(20)));

        UserNotificationSettings settings = new UserNotificationSettings();
        settings.setDailyLimitEmail(20);

        // When
        boolean exceeded = throttleService.isExceededDailyLimit(
            userId, NotificationChannel.EMAIL, settings);

        // Then
        assertThat(exceeded).isTrue();
    }

    @Test
    @DisplayName("冷卻時間檢查 - 在冷卻中")
    void cooldownCheck_inCooldown() {
        // Given
        String ruleId = "RULE_001";
        String stockId = "2330";
        int cooldownMinutes = 30;

        when(historyRepository.findLastTriggered(ruleId, stockId))
            .thenReturn(Optional.of(OffsetDateTime.now().minusMinutes(15)));

        // When
        boolean inCooldown = throttleService.isInCooldown(ruleId, stockId, cooldownMinutes);

        // Then
        assertThat(inCooldown).isTrue();
    }

    @Test
    @DisplayName("冷卻時間檢查 - 已過冷卻")
    void cooldownCheck_notInCooldown() {
        // Given
        String ruleId = "RULE_001";
        String stockId = "2330";
        int cooldownMinutes = 30;

        when(historyRepository.findLastTriggered(ruleId, stockId))
            .thenReturn(Optional.of(OffsetDateTime.now().minusMinutes(45)));

        // When
        boolean inCooldown = throttleService.isInCooldown(ruleId, stockId, cooldownMinutes);

        // Then
        assertThat(inCooldown).isFalse();
    }
}
```

### 2.3 靜音檢查測試

```java
@ExtendWith(MockitoExtension.class)
class MuteServiceTest {

    @InjectMocks
    private MuteService muteService;

    @Test
    @DisplayName("勿擾時段檢查 - 在勿擾時段內")
    void quietHoursCheck_inQuietHours() {
        // Given
        UserNotificationSettings settings = new UserNotificationSettings();
        settings.setMuteEnabled(true);
        settings.setQuietHoursStart(LocalTime.of(22, 0));
        settings.setQuietHoursEnd(LocalTime.of(8, 0));
        settings.setQuietTimezone("Asia/Taipei");

        LocalTime currentTime = LocalTime.of(23, 30);

        // When
        boolean shouldMute = muteService.isInQuietHours(currentTime, settings);

        // Then
        assertThat(shouldMute).isTrue();
    }

    @Test
    @DisplayName("勿擾時段檢查 - 不在勿擾時段")
    void quietHoursCheck_notInQuietHours() {
        // Given
        UserNotificationSettings settings = new UserNotificationSettings();
        settings.setMuteEnabled(true);
        settings.setQuietHoursStart(LocalTime.of(22, 0));
        settings.setQuietHoursEnd(LocalTime.of(8, 0));
        settings.setQuietTimezone("Asia/Taipei");

        LocalTime currentTime = LocalTime.of(14, 30);

        // When
        boolean shouldMute = muteService.isInQuietHours(currentTime, settings);

        // Then
        assertThat(shouldMute).isFalse();
    }

    @Test
    @DisplayName("週末靜音檢查")
    void weekendMuteCheck() {
        // Given
        UserNotificationSettings settings = new UserNotificationSettings();
        settings.setMuteEnabled(true);
        settings.setWeekendMute(true);

        LocalDate saturday = LocalDate.of(2026, 1, 17);  // 週六
        LocalDate monday = LocalDate.of(2026, 1, 19);    // 週一

        // When & Then
        assertThat(muteService.isWeekendMuted(saturday, settings)).isTrue();
        assertThat(muteService.isWeekendMuted(monday, settings)).isFalse();
    }
}
```

---

## 3. 整合測試

### 3.1 警報觸發整合測試

```java
@SpringBootTest
@Transactional
class AlertTriggerServiceIntegrationTest {

    @Autowired
    private AlertTriggerService alertTriggerService;

    @Autowired
    private AlertRuleRepository ruleRepository;

    @Autowired
    private AlertHistoryRepository historyRepository;

    @Autowired
    private TestDataSetup testDataSetup;

    @BeforeEach
    void setUp() {
        testDataSetup.initializeTestData();
    }

    @Test
    @DisplayName("信號觸發警報 - 成功")
    void signalTriggersAlert_success() {
        // Given
        String userId = "user001";
        AlertRule rule = createAndSaveRule(userId, List.of("2330"), List.of("BUY"), "B+");

        UnifiedSignal signal = createSignal("2330", "BUY", "A", 85);

        // When
        alertTriggerService.processSignals(List.of(signal));

        // Then
        List<AlertHistory> alerts = historyRepository.findByUserId(userId);
        assertThat(alerts).hasSize(1);
        assertThat(alerts.get(0).getStockId()).isEqualTo("2330");
        assertThat(alerts.get(0).getSignalGrade()).isEqualTo("A");
    }

    @Test
    @DisplayName("信號不符合規則 - 無警報")
    void signalNotMatchRule_noAlert() {
        // Given
        String userId = "user001";
        AlertRule rule = createAndSaveRule(userId, List.of("2330"), List.of("BUY"), "B+");

        UnifiedSignal signal = createSignal("2317", "BUY", "A", 85);  // 股票不符

        // When
        alertTriggerService.processSignals(List.of(signal));

        // Then
        List<AlertHistory> alerts = historyRepository.findByUserId(userId);
        assertThat(alerts).isEmpty();
    }

    @Test
    @DisplayName("節流生效 - 同股票冷卻中")
    void throttle_sameStockInCooldown() {
        // Given
        String userId = "user001";
        AlertRule rule = createAndSaveRule(userId, List.of("2330"), List.of("BUY"), "B+");
        rule.setThrottleCooldownMinutes(60);
        ruleRepository.save(rule);

        // 第一次觸發
        UnifiedSignal signal1 = createSignal("2330", "BUY", "A", 85);
        alertTriggerService.processSignals(List.of(signal1));

        // 第二次觸發（在冷卻時間內）
        UnifiedSignal signal2 = createSignal("2330", "BUY", "A+", 90);

        // When
        alertTriggerService.processSignals(List.of(signal2));

        // Then - 應該只有一則警報
        List<AlertHistory> alerts = historyRepository.findByUserId(userId);
        assertThat(alerts).hasSize(1);
    }
}
```

### 3.2 通知發送整合測試

```java
@SpringBootTest
@Transactional
class NotificationDispatcherIntegrationTest {

    @Autowired
    private NotificationDispatcher dispatcher;

    @Autowired
    private NotificationLogRepository logRepository;

    @MockBean
    private EmailSender emailSender;

    @MockBean
    private LineSender lineSender;

    @Test
    @DisplayName("發送 Email 通知 - 成功")
    void sendEmailNotification_success() {
        // Given
        AlertHistory alert = createTestAlert();
        AlertRule rule = createRuleWithChannels(List.of("EMAIL"));
        UserNotificationSettings settings = createSettings("user@test.com", true);

        doNothing().when(emailSender).send(any(), any(), any());

        // When
        dispatcher.dispatch(alert, rule);

        // Then
        verify(emailSender).send(any(), any(), any());

        List<NotificationLog> logs = logRepository.findByAlertId(alert.getAlertId());
        assertThat(logs).hasSize(1);
        assertThat(logs.get(0).getStatus()).isEqualTo(NotificationStatus.SENT);
    }

    @Test
    @DisplayName("發送通知 - 靜音時段跳過")
    void sendNotification_skippedDuringMute() {
        // Given
        AlertHistory alert = createTestAlert();
        AlertRule rule = createRuleWithChannels(List.of("EMAIL"));
        UserNotificationSettings settings = createSettings("user@test.com", true);
        settings.setMuteEnabled(true);
        settings.setQuietHoursStart(LocalTime.of(0, 0));
        settings.setQuietHoursEnd(LocalTime.of(23, 59));  // 全天靜音

        // When
        dispatcher.dispatch(alert, rule);

        // Then
        verify(emailSender, never()).send(any(), any(), any());
    }

    @Test
    @DisplayName("發送通知 - 超過每日限額")
    void sendNotification_dailyLimitExceeded() {
        // Given
        AlertHistory alert = createTestAlert();
        AlertRule rule = createRuleWithChannels(List.of("EMAIL"));
        UserNotificationSettings settings = createSettings("user@test.com", true);
        settings.setDailyLimitEmail(0);  // 限額為 0

        // 預先達到限額
        fillDailyLimit(settings.getUserId(), NotificationChannel.EMAIL, 0);

        // When
        dispatcher.dispatch(alert, rule);

        // Then
        verify(emailSender, never()).send(any(), any(), any());

        List<NotificationLog> logs = logRepository.findByAlertId(alert.getAlertId());
        assertThat(logs).hasSize(1);
        assertThat(logs.get(0).getStatus()).isEqualTo(NotificationStatus.SKIPPED);
    }
}
```

---

## 4. API 測試

### 4.1 規則管理 API

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class AlertRuleApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("POST /api/v1/alerts/rules - 建立規則")
    void createRule_success() throws Exception {
        String requestBody = """
            {
                "ruleName": "測試規則",
                "ruleType": "SIGNAL",
                "conditions": {
                    "stockIds": ["2330"],
                    "directions": ["BUY"],
                    "minGrade": "B+"
                },
                "notifications": {
                    "channels": ["EMAIL"],
                    "priority": "NORMAL"
                }
            }
            """;

        mockMvc.perform(post("/api/v1/alerts/rules")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.code").value(201))
            .andExpect(jsonPath("$.data.ruleId").exists())
            .andExpect(jsonPath("$.data.ruleName").value("測試規則"));
    }

    @Test
    @DisplayName("POST /api/v1/alerts/rules - 超過規則數量限制")
    void createRule_exceedsLimit() throws Exception {
        // 先建立 20 條規則
        for (int i = 0; i < 20; i++) {
            createTestRule("規則" + i);
        }

        // 嘗試建立第 21 條
        String requestBody = """
            {
                "ruleName": "第21條規則",
                "ruleType": "SIGNAL",
                "conditions": { "directions": ["BUY"] },
                "notifications": { "channels": ["EMAIL"] }
            }
            """;

        mockMvc.perform(post("/api/v1/alerts/rules")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.code").value(400))
            .andExpect(jsonPath("$.error.errorCode").value("M15-002"));
    }

    @Test
    @DisplayName("PUT /api/v1/alerts/rules/{ruleId} - 更新規則")
    void updateRule_success() throws Exception {
        // Given
        String ruleId = createTestRule("原始規則");

        String updateBody = """
            {
                "ruleName": "更新後規則",
                "conditions": {
                    "stockIds": ["2330", "2317"],
                    "directions": ["BUY", "SELL"]
                }
            }
            """;

        // When & Then
        mockMvc.perform(put("/api/v1/alerts/rules/" + ruleId)
                .contentType(MediaType.APPLICATION_JSON)
                .content(updateBody))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.ruleName").value("更新後規則"));
    }

    @Test
    @DisplayName("DELETE /api/v1/alerts/rules/{ruleId} - 刪除規則")
    void deleteRule_success() throws Exception {
        // Given
        String ruleId = createTestRule("待刪除規則");

        // When & Then
        mockMvc.perform(delete("/api/v1/alerts/rules/" + ruleId))
            .andExpect(status().isNoContent());

        // 驗證已刪除
        mockMvc.perform(get("/api/v1/alerts/rules/" + ruleId))
            .andExpect(status().isNotFound());
    }
}
```

### 4.2 警報歷史 API

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class AlertHistoryApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("GET /api/v1/alerts/history - 取得歷史列表")
    void getHistory_success() throws Exception {
        mockMvc.perform(get("/api/v1/alerts/history")
                .param("page", "1")
                .param("size", "20"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.alerts").isArray())
            .andExpect(jsonPath("$.data.pagination").exists());
    }

    @Test
    @DisplayName("POST /api/v1/alerts/history/{alertId}/read - 標記已讀")
    void markAsRead_success() throws Exception {
        // Given
        String alertId = createTestAlert();

        // When & Then
        mockMvc.perform(post("/api/v1/alerts/history/" + alertId + "/read"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.readAt").exists());
    }

    @Test
    @DisplayName("POST /api/v1/alerts/history/read-all - 全部標記已讀")
    void markAllAsRead_success() throws Exception {
        // Given
        createTestAlerts(5);

        // When & Then
        mockMvc.perform(post("/api/v1/alerts/history/read-all"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.markedCount").isNumber());
    }
}
```

---

## 5. Job 測試

### 5.1 信號監控 Job 測試

```java
@SpringBootTest
class SignalMonitorJobTest {

    @Autowired
    private SignalMonitorJob job;

    @Autowired
    private AlertHistoryRepository historyRepository;

    @MockBean
    private UnifiedSignalRepository signalRepository;

    @Test
    @DisplayName("信號監控 - 發現新信號觸發警報")
    void monitorNewSignals_triggersAlerts() {
        // Given
        UnifiedSignal signal = createSignal("2330", "BUY", "A", 85);
        when(signalRepository.findNewSignalsSince(any(), any()))
            .thenReturn(List.of(signal));

        // When
        job.execute(null);

        // Then
        List<AlertHistory> alerts = historyRepository.findAll();
        assertThat(alerts).isNotEmpty();
    }
}
```

### 5.2 通知重試 Job 測試

```java
@SpringBootTest
class NotificationRetryJobTest {

    @Autowired
    private NotificationRetryJob job;

    @Autowired
    private NotificationLogRepository logRepository;

    @MockBean
    private EmailSender emailSender;

    @Test
    @DisplayName("重試失敗通知 - 成功")
    void retryFailedNotification_success() {
        // Given
        NotificationLog failedLog = createFailedLog();
        failedLog.setRetryCount(0);
        logRepository.save(failedLog);

        doNothing().when(emailSender).send(any(), any(), any());

        // When
        job.execute(null);

        // Then
        NotificationLog updated = logRepository.findByLogId(failedLog.getLogId()).get();
        assertThat(updated.getStatus()).isEqualTo(NotificationStatus.SENT);
    }

    @Test
    @DisplayName("重試失敗通知 - 達到最大次數")
    void retryFailedNotification_maxRetries() {
        // Given
        NotificationLog failedLog = createFailedLog();
        failedLog.setRetryCount(3);  // 已達最大次數
        logRepository.save(failedLog);

        // When
        job.execute(null);

        // Then - 不應重試
        verify(emailSender, never()).send(any(), any(), any());
    }
}
```

---

## 6. 效能測試

### 6.1 規則比對效能測試

```java
@SpringBootTest
class RuleMatchingPerformanceTest {

    @Autowired
    private AlertTriggerService alertTriggerService;

    @Test
    @DisplayName("規則比對效能 - 1000 條規則")
    void ruleMatchingPerformance() {
        // Given: 建立 1000 條規則
        List<AlertRule> rules = createTestRules(1000);

        // 建立測試信號
        List<UnifiedSignal> signals = createTestSignals(100);

        // When
        long startTime = System.currentTimeMillis();
        alertTriggerService.processSignals(signals);
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(5000);  // 5 秒內完成
        log.info("處理 100 則信號 vs 1000 條規則，耗時 {} ms", duration);
    }
}
```

---

## 7. 測試覆蓋率要求

| 模組 | 行覆蓋率 | 分支覆蓋率 | 說明 |
|-----|---------|-----------|------|
| RuleMatcher | ≥ 90% | ≥ 85% | 核心比對邏輯 |
| NotificationDispatcher | ≥ 85% | ≥ 80% | 派發邏輯 |
| ThrottleService | ≥ 90% | ≥ 85% | 節流邏輯 |
| Controller | ≥ 80% | ≥ 75% | API 層 |
| Job | ≥ 80% | ≥ 75% | 排程任務 |

---

## 8. 相關文檔

- [M15 功能需求](../specs/functional/M15-警報通知系統功能需求.md)
- [M15 API 規格](../specs/api/M15-API規格.md)
- [M15 效能考量](./M15-效能考量.md)

---

**文件維護者**: QA 工程師
**最後更新**: 2026-01-15
**下次審核**: 2026-04-15
