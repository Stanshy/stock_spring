# M14-選股引擎 效能考量

> **文件編號**: PERF-M14
> **模組名稱**: 選股引擎 (Stock Screening Engine)
> **版本**: v1.0
> **最後更新**: 2026-01-15
> **狀態**: Draft

---

## 1. 效能目標

### 1.1 回應時間目標

| 操作類型 | 目標延遲 | P99 延遲 | 說明 |
|---------|---------|---------|------|
| 快速選股 | < 500ms | < 800ms | 使用預設模板 |
| 自訂選股（簡單） | < 1s | < 1.5s | ≤ 5 個條件 |
| 自訂選股（複雜） | < 2s | < 3s | 6-20 個條件 |
| 策略執行 | < 2s | < 3s | 執行已儲存策略 |
| 信號選股 | < 1s | < 1.5s | 依據 M13 信號篩選 |
| 策略 CRUD | < 200ms | < 500ms | 策略管理操作 |
| 績效查詢 | < 500ms | < 1s | 單次執行績效 |

### 1.2 吞吐量目標

| 指標 | 目標值 | 說明 |
|-----|-------|------|
| 並發選股請求 | 100 req/s | 系統整體 |
| 每日選股執行次數 | 50,000 | 所有用戶合計 |
| 策略總數 | 10,000 | 所有用戶策略 |
| 單次篩選候選股數 | 2,000 | 台股市場總數 |

---

## 2. 效能挑戰分析

### 2.1 核心瓶頸

```
┌─────────────────────────────────────────────────────────────────────┐
│                       M14 效能瓶頸分析                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 多表 JOIN 查詢                                                   │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                                                               │   │
│  │  stocks ────┬──► stock_daily                                  │   │
│  │             ├──► fundamental_indicators (M08)                │   │
│  │             ├──► technical_indicators (M07)                  │   │
│  │             ├──► chip_indicators (M09)                       │   │
│  │             └──► unified_signals (M13)                       │   │
│  │                                                               │   │
│  │  最多 5 表 JOIN，每表數據量：                                  │   │
│  │  - stocks: 2,000 筆                                          │   │
│  │  - stock_daily: 2,000 筆/天                                  │   │
│  │  - fundamental: 2,000 筆/季                                  │   │
│  │  - technical: 2,000 筆/天                                    │   │
│  │  - chip: 2,000 筆/天                                         │   │
│  │  - signals: 2,000 筆/天                                      │   │
│  │                                                               │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  2. 動態 WHERE 條件                                                  │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                                                               │   │
│  │  - 最多 20 個條件                                             │   │
│  │  - 支援 AND/OR 組合                                           │   │
│  │  - 最深 3 層巢狀                                              │   │
│  │  - 條件組合複雜度: O(2^n)                                     │   │
│  │                                                               │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  3. 結果排序與分頁                                                   │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                                                               │   │
│  │  - 需要對篩選結果排序                                         │   │
│  │  - 多欄位排序                                                 │   │
│  │  - 返回最多 200 筆結果                                        │   │
│  │                                                               │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 效能風險評估

| 風險 | 影響 | 機率 | 緩解策略 |
|-----|------|------|---------|
| 複雜查詢超時 | 高 | 中 | 查詢優化、超時控制 |
| 並發查詢競爭 | 中 | 中 | 連線池調優、限流 |
| 資料庫 CPU 飆升 | 高 | 低 | 索引優化、查詢快取 |
| 記憶體溢出 | 高 | 低 | 批次處理、結果限制 |

---

## 3. 查詢優化策略

### 3.1 動態 JOIN 優化

```java
@Component
public class OptimizedScreeningQueryBuilder {

    /**
     * 按需 JOIN：只加入有條件需要的表
     */
    public String buildOptimizedQuery(ScreeningRequest request) {
        StringBuilder sql = new StringBuilder();

        // 基礎查詢（必要）
        sql.append("""
            SELECT s.stock_id, s.stock_name, s.market,
                   sd.close_price, sd.price_change_pct, sd.volume
            FROM stocks s
            JOIN stock_daily sd ON s.stock_id = sd.stock_id
                AND sd.trade_date = :tradeDate
            """);

        // 分析條件決定需要的 JOIN
        Set<String> requiredJoins = analyzeRequiredJoins(request.getConditions());

        // 按需 JOIN
        if (requiredJoins.contains("FUNDAMENTAL")) {
            sql.append("""
                LEFT JOIN (
                    SELECT DISTINCT ON (stock_id)
                           stock_id, pe_ratio, pb_ratio, roe, eps, dividend_yield
                    FROM fundamental_indicators
                    ORDER BY stock_id, report_date DESC
                ) fi ON s.stock_id = fi.stock_id
                """);
        }

        if (requiredJoins.contains("TECHNICAL")) {
            sql.append("""
                LEFT JOIN technical_indicators ti
                    ON s.stock_id = ti.stock_id
                    AND ti.trade_date = :tradeDate
                """);
        }

        if (requiredJoins.contains("CHIP")) {
            sql.append("""
                LEFT JOIN chip_indicators ci
                    ON s.stock_id = ci.stock_id
                    AND ci.trade_date = :tradeDate
                """);
        }

        if (requiredJoins.contains("SIGNAL")) {
            sql.append("""
                LEFT JOIN unified_signals us
                    ON s.stock_id = us.stock_id
                    AND us.trade_date = :tradeDate
                """);
        }

        // WHERE 條件
        sql.append("WHERE s.status = 'ACTIVE' ");
        sql.append(buildDynamicWhereClause(request.getConditions()));

        // ORDER BY 和 LIMIT
        sql.append(buildOrderByClause(request.getSortBy()));
        sql.append(" LIMIT :limit");

        return sql.toString();
    }

    private Set<String> analyzeRequiredJoins(ConditionGroup conditions) {
        Set<String> required = new HashSet<>();
        collectRequiredSources(conditions, required);
        return required;
    }

    private void collectRequiredSources(Object condition, Set<String> sources) {
        if (condition instanceof ConditionGroup group) {
            for (Object sub : group.getConditions()) {
                collectRequiredSources(sub, sources);
            }
        } else if (condition instanceof SingleCondition single) {
            String code = single.getConditionCode();
            if (code.startsWith("F_")) sources.add("FUNDAMENTAL");
            else if (code.startsWith("T_")) sources.add("TECHNICAL");
            else if (code.startsWith("C_")) sources.add("CHIP");
            else if (code.startsWith("S_")) sources.add("SIGNAL");
        }
    }
}
```

### 3.2 索引優化

```sql
-- 核心篩選索引

-- 1. 股票基本資料（覆蓋索引）
CREATE INDEX idx_stocks_active_market ON stocks(status, market)
    INCLUDE (stock_id, stock_name, sector_code)
    WHERE status = 'ACTIVE';

-- 2. 日交易資料（最新一天優先）
CREATE INDEX idx_stock_daily_latest ON stock_daily(trade_date DESC, stock_id)
    INCLUDE (close_price, price_change_pct, volume);

-- 3. 技術指標（複合索引）
CREATE INDEX idx_technical_date_stock ON technical_indicators(trade_date, stock_id)
    INCLUDE (rsi_14, macd, ma5, ma20);

-- 4. 籌碼資料（複合索引）
CREATE INDEX idx_chip_date_stock ON chip_indicators(trade_date, stock_id)
    INCLUDE (foreign_net, foreign_cont_days, trust_net);

-- 5. 統一信號（評級篩選）
CREATE INDEX idx_signals_date_grade ON unified_signals(trade_date, grade, unified_direction)
    INCLUDE (stock_id, unified_score);

-- 6. 基本面指標（最新報告）
CREATE INDEX idx_fundamental_stock_date ON fundamental_indicators(stock_id, report_date DESC)
    INCLUDE (pe_ratio, pb_ratio, roe, eps);
```

### 3.3 查詢計畫分析

```sql
-- 預期查詢計畫範例
EXPLAIN ANALYZE
SELECT s.stock_id, s.stock_name, sd.close_price,
       fi.pe_ratio, ti.rsi_14, ci.foreign_cont_days
FROM stocks s
JOIN stock_daily sd ON s.stock_id = sd.stock_id AND sd.trade_date = '2026-01-15'
LEFT JOIN fundamental_indicators fi ON s.stock_id = fi.stock_id
    AND fi.report_date = (SELECT MAX(report_date) FROM fundamental_indicators WHERE stock_id = s.stock_id)
LEFT JOIN technical_indicators ti ON s.stock_id = ti.stock_id AND ti.trade_date = '2026-01-15'
LEFT JOIN chip_indicators ci ON s.stock_id = ci.stock_id AND ci.trade_date = '2026-01-15'
WHERE s.status = 'ACTIVE'
  AND fi.pe_ratio < 15
  AND ti.rsi_14 BETWEEN 30 AND 70
  AND ci.foreign_cont_days >= 3
ORDER BY sd.close_price DESC
LIMIT 50;

-- 目標：
-- - Seq Scan 應轉為 Index Scan
-- - Nested Loop 應有適當的索引支援
-- - 執行時間 < 500ms
```

---

## 4. 快取策略

### 4.1 多層快取架構

```
┌─────────────────────────────────────────────────────────────────────┐
│                       M14 快取架構                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    L1: 本地快取 (Caffeine)                     │   │
│  │  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐  │   │
│  │  │ 條件定義快取   │  │ 模板快取       │  │ 欄位映射快取   │  │   │
│  │  │ TTL: 1 小時   │  │ TTL: 1 小時   │  │ TTL: 永久     │  │   │
│  │  │ Size: 100     │  │ Size: 50      │  │ Size: 200     │  │   │
│  │  └────────────────┘  └────────────────┘  └────────────────┘  │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                │                                     │
│                                ▼                                     │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    L2: 分散式快取 (Redis)                      │   │
│  │  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐  │   │
│  │  │ 熱門策略快取   │  │ 快速選股結果   │  │ 績效摘要快取   │  │   │
│  │  │ TTL: 5 分鐘   │  │ TTL: 5 分鐘   │  │ TTL: 1 小時   │  │   │
│  │  └────────────────┘  └────────────────┘  └────────────────┘  │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                │                                     │
│                                ▼                                     │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    L3: 資料庫 (PostgreSQL)                     │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 快取實作

```java
@Service
@Slf4j
public class ScreeningCacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private ScreeningTemplateMapper templateMapper;

    // 本地快取
    private final Cache<String, ScreeningTemplate> templateCache = Caffeine.newBuilder()
        .maximumSize(50)
        .expireAfterWrite(Duration.ofHours(1))
        .build();

    private final Cache<String, ConditionDefinition> conditionCache = Caffeine.newBuilder()
        .maximumSize(100)
        .expireAfterWrite(Duration.ofHours(1))
        .build();

    // Redis Key 前綴
    private static final String QUICK_RESULT_PREFIX = "screening:quick:";
    private static final String STRATEGY_RESULT_PREFIX = "screening:strategy:";
    private static final String PERFORMANCE_PREFIX = "screening:perf:";

    /**
     * 取得快速選股模板（L1 快取）
     */
    public ScreeningTemplate getTemplate(String templateCode) {
        return templateCache.get(templateCode, key -> {
            log.debug("從資料庫載入模板: {}", key);
            return templateMapper.findByTemplateCode(key);
        });
    }

    /**
     * 快取快速選股結果（L2 快取）
     */
    public void cacheQuickScreeningResult(
            String templateCode,
            LocalDate tradeDate,
            ScreeningResult result) {

        String key = QUICK_RESULT_PREFIX + templateCode + ":" + tradeDate;
        redisTemplate.opsForValue().set(key, result, Duration.ofMinutes(5));
    }

    /**
     * 取得快取的快速選股結果
     */
    public Optional<ScreeningResult> getCachedQuickScreeningResult(
            String templateCode,
            LocalDate tradeDate) {

        String key = QUICK_RESULT_PREFIX + templateCode + ":" + tradeDate;
        ScreeningResult cached = (ScreeningResult) redisTemplate.opsForValue().get(key);
        return Optional.ofNullable(cached);
    }

    /**
     * 清除模板相關快取
     */
    @CacheEvict(value = "templates", key = "#templateCode")
    public void evictTemplateCache(String templateCode) {
        templateCache.invalidate(templateCode);
        // 同時清除 Redis 中的結果快取
        Set<String> keys = redisTemplate.keys(QUICK_RESULT_PREFIX + templateCode + ":*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
}
```

### 4.3 快取命中策略

```java
@Service
public class ScreeningService {

    @Autowired
    private ScreeningCacheService cacheService;

    @Autowired
    private ScreeningQueryExecutor queryExecutor;

    /**
     * 快速選股（帶快取）
     */
    public ScreeningResult quickScreen(String templateCode, LocalDate tradeDate) {
        // 1. 檢查快取
        Optional<ScreeningResult> cached =
            cacheService.getCachedQuickScreeningResult(templateCode, tradeDate);

        if (cached.isPresent()) {
            log.debug("快速選股快取命中: {}", templateCode);
            return cached.get();
        }

        // 2. 執行查詢
        ScreeningTemplate template = cacheService.getTemplate(templateCode);
        ScreeningResult result = queryExecutor.execute(template.getConditions(), tradeDate);

        // 3. 寫入快取
        cacheService.cacheQuickScreeningResult(templateCode, tradeDate, result);

        return result;
    }
}
```

---

## 5. 並發控制

### 5.1 限流策略

```java
@Component
public class ScreeningRateLimiter {

    // 全域限流：100 req/s
    private final RateLimiter globalLimiter = RateLimiter.create(100);

    // 單用戶限流：10 req/s
    private final LoadingCache<String, RateLimiter> userLimiters = CacheBuilder.newBuilder()
        .maximumSize(10000)
        .expireAfterAccess(Duration.ofMinutes(10))
        .build(new CacheLoader<>() {
            @Override
            public RateLimiter load(String userId) {
                return RateLimiter.create(10);
            }
        });

    /**
     * 取得執行許可
     */
    public boolean tryAcquire(String userId) {
        // 全域檢查
        if (!globalLimiter.tryAcquire()) {
            return false;
        }

        // 用戶級檢查
        try {
            return userLimiters.get(userId).tryAcquire();
        } catch (ExecutionException e) {
            return false;
        }
    }

    /**
     * 取得執行許可（帶等待）
     */
    public boolean tryAcquire(String userId, Duration timeout) {
        // 全域檢查
        if (!globalLimiter.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {
            return false;
        }

        // 用戶級檢查
        try {
            return userLimiters.get(userId)
                .tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS);
        } catch (ExecutionException e) {
            return false;
        }
    }
}
```

### 5.2 查詢超時控制

```java
@Service
public class ScreeningQueryExecutor {

    @Autowired
    private SqlSessionFactory sqlSessionFactory;

    @Value("${screening.query.timeout-seconds:5}")
    private int queryTimeoutSeconds;

    /**
     * 執行篩選查詢（帶超時）
     */
    public List<ScreeningResultDto> executeWithTimeout(
            String sql,
            Map<String, Object> params) {

        try (SqlSession session = sqlSessionFactory.openSession()) {
            // 設定查詢超時
            session.getConnection().setNetworkTimeout(
                Executors.newSingleThreadExecutor(),
                queryTimeoutSeconds * 1000
            );

            return session.selectList("executeScreening", params);

        } catch (SQLException e) {
            if (e instanceof SQLTimeoutException) {
                throw new QueryTimeoutException("選股查詢超時，請簡化條件後重試");
            }
            throw new ScreeningException("選股查詢失敗", e);
        }
    }
}
```

---

## 6. 批次處理優化

### 6.1 績效追蹤批次處理

```java
@Service
public class PerformanceTrackingService {

    private static final int BATCH_SIZE = 1000;

    @Autowired
    private ScreeningPerformanceMapper performanceMapper;

    @Autowired
    private StockDailyMapper stockDailyMapper;

    /**
     * 批次更新績效
     */
    @Transactional
    public void batchUpdatePerformance(LocalDate date) {
        int offset = 0;
        int updated = 0;

        while (true) {
            // 分批取得待更新記錄
            List<ScreeningPerformance> batch =
                performanceMapper.findPendingByDate(date, BATCH_SIZE, offset);

            if (batch.isEmpty()) {
                break;
            }

            // 批次取得股價
            Set<String> stockIds = batch.stream()
                .map(ScreeningPerformance::getStockId)
                .collect(Collectors.toSet());

            Map<String, StockDaily> priceMap =
                stockDailyMapper.findByStockIdsAndDate(stockIds, date)
                    .stream()
                    .collect(Collectors.toMap(
                        StockDaily::getStockId,
                        Function.identity()
                    ));

            // 批次更新
            List<PerformanceUpdate> updates = batch.stream()
                .filter(p -> priceMap.containsKey(p.getStockId()))
                .map(p -> buildUpdate(p, priceMap.get(p.getStockId())))
                .collect(Collectors.toList());

            if (!updates.isEmpty()) {
                performanceMapper.batchUpdate(updates);
                updated += updates.size();
            }

            offset += BATCH_SIZE;
        }

        log.info("批次更新績效完成，共更新 {} 筆", updated);
    }
}
```

### 6.2 結果儲存批次處理

```java
@Service
public class ScreeningResultService {

    private static final int INSERT_BATCH_SIZE = 500;

    @Autowired
    private ScreeningResultMapper resultMapper;

    /**
     * 批次儲存選股結果
     */
    @Transactional
    public void saveResults(String executionId, List<ScreeningResultDto> results) {
        if (results.isEmpty()) {
            return;
        }

        // 轉換並設定排名
        List<ScreeningResult> entities = new ArrayList<>();
        for (int i = 0; i < results.size(); i++) {
            ScreeningResult entity = convert(results.get(i));
            entity.setExecutionId(executionId);
            entity.setRank(i + 1);
            entities.add(entity);
        }

        // 分批插入
        Lists.partition(entities, INSERT_BATCH_SIZE).forEach(batch -> {
            resultMapper.batchInsert(batch);
        });
    }
}
```

---

## 7. 資料庫連線池配置

```yaml
# application.yml
spring:
  datasource:
    hikari:
      # 連線池大小
      minimum-idle: 10
      maximum-pool-size: 50

      # 連線超時
      connection-timeout: 10000      # 10 秒
      idle-timeout: 300000           # 5 分鐘
      max-lifetime: 1800000          # 30 分鐘

      # 查詢超時
      validation-timeout: 5000       # 5 秒

      # 連線池名稱（監控用）
      pool-name: M14-HikariPool

      # 效能監控
      register-mbeans: true
```

---

## 8. 效能監控指標

### 8.1 關鍵指標

```java
@Component
public class ScreeningMetrics {

    private final MeterRegistry registry;

    // 查詢延遲
    private final Timer screeningLatency;

    // 查詢成功/失敗計數
    private final Counter screeningSuccess;
    private final Counter screeningFailure;

    // 快取命中率
    private final Counter cacheHit;
    private final Counter cacheMiss;

    // 查詢複雜度分佈
    private final DistributionSummary conditionCount;

    public ScreeningMetrics(MeterRegistry registry) {
        this.registry = registry;

        this.screeningLatency = Timer.builder("m14.screening.latency")
            .description("選股查詢延遲")
            .tags("module", "m14")
            .register(registry);

        this.screeningSuccess = Counter.builder("m14.screening.success")
            .description("選股成功次數")
            .register(registry);

        this.screeningFailure = Counter.builder("m14.screening.failure")
            .description("選股失敗次數")
            .register(registry);

        this.cacheHit = Counter.builder("m14.cache.hit")
            .description("快取命中")
            .register(registry);

        this.cacheMiss = Counter.builder("m14.cache.miss")
            .description("快取未命中")
            .register(registry);

        this.conditionCount = DistributionSummary.builder("m14.screening.conditions")
            .description("篩選條件數量分佈")
            .register(registry);
    }

    public void recordScreening(Duration duration, boolean success, int conditions) {
        screeningLatency.record(duration);
        if (success) {
            screeningSuccess.increment();
        } else {
            screeningFailure.increment();
        }
        conditionCount.record(conditions);
    }
}
```

### 8.2 告警閾值

| 指標 | 警告閾值 | 嚴重閾值 |
|-----|---------|---------|
| 查詢 P99 延遲 | > 2s | > 5s |
| 查詢錯誤率 | > 1% | > 5% |
| 快取命中率 | < 70% | < 50% |
| 連線池使用率 | > 70% | > 90% |
| 查詢超時率 | > 0.5% | > 2% |

---

## 9. 效能測試基準

### 9.1 測試場景

| 場景 | 條件數 | 併發數 | 目標 TPS | 目標延遲 |
|------|-------|-------|---------|---------|
| 快速選股 | 3-5 | 50 | 100 | < 500ms |
| 簡單自訂 | 5-10 | 30 | 50 | < 1s |
| 複雜自訂 | 15-20 | 10 | 20 | < 2s |
| 混合負載 | 混合 | 100 | 80 | < 1.5s |

### 9.2 壓力測試腳本

```java
@Test
void screeningLoadTest() {
    // 準備測試資料
    List<ScreeningRequest> requests = generateTestRequests(1000);

    // 執行壓力測試
    AtomicInteger successCount = new AtomicInteger();
    AtomicInteger failureCount = new AtomicInteger();
    List<Long> latencies = new CopyOnWriteArrayList<>();

    ExecutorService executor = Executors.newFixedThreadPool(50);
    CountDownLatch latch = new CountDownLatch(requests.size());

    long startTime = System.currentTimeMillis();

    for (ScreeningRequest request : requests) {
        executor.submit(() -> {
            try {
                long start = System.currentTimeMillis();
                screeningService.execute(request);
                latencies.add(System.currentTimeMillis() - start);
                successCount.incrementAndGet();
            } catch (Exception e) {
                failureCount.incrementAndGet();
            } finally {
                latch.countDown();
            }
        });
    }

    latch.await(5, TimeUnit.MINUTES);
    long totalTime = System.currentTimeMillis() - startTime;

    // 輸出結果
    double avgLatency = latencies.stream().mapToLong(Long::longValue).average().orElse(0);
    double p99Latency = calculateP99(latencies);
    double tps = successCount.get() * 1000.0 / totalTime;

    log.info("壓力測試結果:");
    log.info("  成功: {}, 失敗: {}", successCount.get(), failureCount.get());
    log.info("  平均延遲: {} ms, P99: {} ms", avgLatency, p99Latency);
    log.info("  TPS: {}", tps);

    // 驗證
    assertThat(failureCount.get()).isLessThan(requests.size() * 0.01);
    assertThat(p99Latency).isLessThan(3000);
    assertThat(tps).isGreaterThan(50);
}
```

---

## 10. 相關文檔

- [M14 功能需求](../specs/functional/M14-選股引擎功能需求.md)
- [M14 資料庫設計](./M14-資料庫設計.md)
- [M14 Job 排程配置](../deployment/M14-Job排程配置.md)

---

**文件維護者**: 後端工程師
**最後更新**: 2026-01-15
**下次審核**: 2026-04-15
