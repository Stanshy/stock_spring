# M14-選股引擎 測試準則

> **文件編號**: TEST-M14
> **模組名稱**: 選股引擎 (Stock Screening Engine)
> **版本**: v1.0
> **最後更新**: 2026-01-15
> **狀態**: Draft

---

## 1. 測試總覽

### 1.1 測試範圍

| 測試類型 | 測試對象 | 測試重點 |
|---------|---------|---------|
| 單元測試 | QueryBuilder, ConditionParser | 條件解析、SQL 建構 |
| 整合測試 | ScreeningService | 端到端篩選流程 |
| API 測試 | REST Controller | 請求/回應驗證 |
| 效能測試 | 篩選查詢 | 延遲、吞吐量 |
| Job 測試 | 排程任務 | 績效追蹤、清理 |

### 1.2 測試優先級

```
┌─────────────────────────────────────────────────────────────────────┐
│                       M14 測試優先級                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  P0 - 核心功能（必須通過）                                           │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  • 條件組合邏輯（AND/OR）正確性                               │   │
│  │  • 動態 SQL 建構正確性                                        │   │
│  │  • 多維度篩選結果準確性                                       │   │
│  │  • 快速選股模板執行                                           │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  P1 - 重要功能                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  • 策略 CRUD 操作                                             │   │
│  │  • 執行記錄儲存                                               │   │
│  │  • 績效追蹤計算                                               │   │
│  │  • 結果排序與分頁                                             │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  P2 - 一般功能                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  • 策略分享功能                                               │   │
│  │  • 歷史記錄查詢                                               │   │
│  │  • 條件定義管理                                               │   │
│  │  • 快取機制                                                   │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 單元測試

### 2.1 條件解析器測試

```java
@ExtendWith(MockitoExtension.class)
class ConditionParserTest {

    @InjectMocks
    private ConditionParser parser;

    @Test
    @DisplayName("解析單一條件")
    void parseSingleCondition() {
        // Given
        String json = """
            {
                "condition_code": "F_PE",
                "operator": "<=",
                "values": [15]
            }
            """;

        // When
        Condition result = parser.parse(json);

        // Then
        assertThat(result).isInstanceOf(SingleCondition.class);
        SingleCondition single = (SingleCondition) result;
        assertThat(single.getConditionCode()).isEqualTo("F_PE");
        assertThat(single.getOperator()).isEqualTo("<=");
        assertThat(single.getValues()).containsExactly(15);
    }

    @Test
    @DisplayName("解析 AND 組合條件")
    void parseAndConditionGroup() {
        // Given
        String json = """
            {
                "logic": "AND",
                "conditions": [
                    {"condition_code": "F_PE", "operator": "<=", "values": [15]},
                    {"condition_code": "F_ROE", "operator": ">=", "values": [15]}
                ]
            }
            """;

        // When
        Condition result = parser.parse(json);

        // Then
        assertThat(result).isInstanceOf(ConditionGroup.class);
        ConditionGroup group = (ConditionGroup) result;
        assertThat(group.getLogic()).isEqualTo("AND");
        assertThat(group.getConditions()).hasSize(2);
    }

    @Test
    @DisplayName("解析巢狀 AND/OR 條件")
    void parseNestedConditions() {
        // Given: PE < 15 AND (外資連買 >= 3 OR 投信連買 >= 3)
        String json = """
            {
                "logic": "AND",
                "conditions": [
                    {"condition_code": "F_PE", "operator": "<", "values": [15]},
                    {
                        "logic": "OR",
                        "conditions": [
                            {"condition_code": "C_FOREIGN_CONT", "operator": ">=", "values": [3]},
                            {"condition_code": "C_TRUST_CONT", "operator": ">=", "values": [3]}
                        ]
                    }
                ]
            }
            """;

        // When
        Condition result = parser.parse(json);

        // Then
        assertThat(result).isInstanceOf(ConditionGroup.class);
        ConditionGroup root = (ConditionGroup) result;
        assertThat(root.getLogic()).isEqualTo("AND");
        assertThat(root.getConditions()).hasSize(2);

        // 驗證巢狀 OR
        assertThat(root.getConditions().get(1)).isInstanceOf(ConditionGroup.class);
        ConditionGroup nested = (ConditionGroup) root.getConditions().get(1);
        assertThat(nested.getLogic()).isEqualTo("OR");
    }

    @Test
    @DisplayName("拒絕超過最大條件數")
    void rejectTooManyConditions() {
        // Given: 21 個條件
        StringBuilder json = new StringBuilder("{\"logic\":\"AND\",\"conditions\":[");
        for (int i = 0; i < 21; i++) {
            if (i > 0) json.append(",");
            json.append("{\"condition_code\":\"F_PE\",\"operator\":\"<\",\"values\":[").append(i + 10).append("]}");
        }
        json.append("]}");

        // When/Then
        assertThatThrownBy(() -> parser.parse(json.toString()))
            .isInstanceOf(TooManyConditionsException.class)
            .hasMessageContaining("20");
    }

    @Test
    @DisplayName("拒絕超過最大巢狀層數")
    void rejectTooDeepNesting() {
        // Given: 4 層巢狀
        String json = """
            {
                "logic": "AND",
                "conditions": [{
                    "logic": "OR",
                    "conditions": [{
                        "logic": "AND",
                        "conditions": [{
                            "logic": "OR",
                            "conditions": [
                                {"condition_code": "F_PE", "operator": "<", "values": [15]}
                            ]
                        }]
                    }]
                }]
            }
            """;

        // When/Then
        assertThatThrownBy(() -> parser.parse(json))
            .isInstanceOf(NestingTooDeepException.class)
            .hasMessageContaining("3");
    }

    @Test
    @DisplayName("驗證無效條件代碼")
    void validateInvalidConditionCode() {
        // Given
        String json = """
            {
                "condition_code": "INVALID_CODE",
                "operator": "<=",
                "values": [15]
            }
            """;

        // When/Then
        assertThatThrownBy(() -> parser.parse(json))
            .isInstanceOf(InvalidConditionException.class)
            .hasMessageContaining("INVALID_CODE");
    }
}
```

### 2.2 查詢建構器測試

```java
@ExtendWith(MockitoExtension.class)
class ScreeningQueryBuilderTest {

    @InjectMocks
    private ScreeningQueryBuilder queryBuilder;

    @Test
    @DisplayName("建構基本面篩選 SQL")
    void buildFundamentalScreeningQuery() {
        // Given
        ConditionGroup conditions = ConditionGroup.builder()
            .logic("AND")
            .conditions(List.of(
                SingleCondition.of("F_PE", "<=", List.of(15)),
                SingleCondition.of("F_ROE", ">=", List.of(15))
            ))
            .build();

        // When
        String sql = queryBuilder.buildScreeningQuery(conditions);

        // Then
        assertThat(sql)
            .contains("LEFT JOIN fundamental_indicators fi")
            .contains("fi.pe_ratio <= 15")
            .contains("fi.roe >= 15")
            .doesNotContain("technical_indicators")
            .doesNotContain("chip_indicators");
    }

    @Test
    @DisplayName("建構多維度篩選 SQL")
    void buildMultiDimensionalQuery() {
        // Given
        ConditionGroup conditions = ConditionGroup.builder()
            .logic("AND")
            .conditions(List.of(
                SingleCondition.of("F_PE", "<=", List.of(15)),
                SingleCondition.of("T_RSI", "BETWEEN", List.of(30, 70)),
                SingleCondition.of("C_FOREIGN_CONT", ">=", List.of(3))
            ))
            .build();

        // When
        String sql = queryBuilder.buildScreeningQuery(conditions);

        // Then
        assertThat(sql)
            .contains("LEFT JOIN fundamental_indicators fi")
            .contains("LEFT JOIN technical_indicators ti")
            .contains("LEFT JOIN chip_indicators ci")
            .contains("fi.pe_ratio <= 15")
            .contains("ti.rsi_14 BETWEEN 30 AND 70")
            .contains("ci.foreign_cont_days >= 3");
    }

    @Test
    @DisplayName("建構 OR 條件 SQL")
    void buildOrConditionQuery() {
        // Given: 外資連買 >= 3 OR 投信連買 >= 3
        ConditionGroup conditions = ConditionGroup.builder()
            .logic("OR")
            .conditions(List.of(
                SingleCondition.of("C_FOREIGN_CONT", ">=", List.of(3)),
                SingleCondition.of("C_TRUST_CONT", ">=", List.of(3))
            ))
            .build();

        // When
        String sql = queryBuilder.buildScreeningQuery(conditions);

        // Then
        assertThat(sql)
            .contains("(ci.foreign_cont_days >= 3 OR ci.trust_cont_days >= 3)");
    }

    @Test
    @DisplayName("建構信號篩選 SQL")
    void buildSignalScreeningQuery() {
        // Given
        ConditionGroup conditions = ConditionGroup.builder()
            .logic("AND")
            .conditions(List.of(
                SingleCondition.of("S_DIRECTION", "=", List.of("BUY")),
                SingleCondition.of("S_GRADE", ">=", List.of("B+"))
            ))
            .build();

        // When
        String sql = queryBuilder.buildScreeningQuery(conditions);

        // Then
        assertThat(sql)
            .contains("LEFT JOIN unified_signals us")
            .contains("us.unified_direction = 'BUY'")
            .contains("us.grade IN ('A+', 'A', 'B+')");  // B+ 以上
    }

    @Test
    @DisplayName("建構 BETWEEN 運算符 SQL")
    void buildBetweenOperator() {
        // Given
        SingleCondition condition = SingleCondition.of("T_RSI", "BETWEEN", List.of(30, 70));

        // When
        String whereClause = queryBuilder.buildSingleCondition(condition);

        // Then
        assertThat(whereClause).isEqualTo("ti.rsi_14 BETWEEN 30 AND 70");
    }
}
```

### 2.3 績效計算測試

```java
@ExtendWith(MockitoExtension.class)
class PerformanceCalculatorTest {

    @InjectMocks
    private PerformanceCalculator calculator;

    @Test
    @DisplayName("計算正報酬")
    void calculatePositiveReturn() {
        // Given
        BigDecimal basePrice = new BigDecimal("100.00");
        BigDecimal currentPrice = new BigDecimal("110.00");

        // When
        BigDecimal returnPct = calculator.calculateReturn(basePrice, currentPrice);

        // Then
        assertThat(returnPct).isEqualByComparingTo("10.00");
    }

    @Test
    @DisplayName("計算負報酬")
    void calculateNegativeReturn() {
        // Given
        BigDecimal basePrice = new BigDecimal("100.00");
        BigDecimal currentPrice = new BigDecimal("95.00");

        // When
        BigDecimal returnPct = calculator.calculateReturn(basePrice, currentPrice);

        // Then
        assertThat(returnPct).isEqualByComparingTo("-5.00");
    }

    @Test
    @DisplayName("計算勝率")
    void calculateWinRate() {
        // Given
        List<BigDecimal> returns = List.of(
            new BigDecimal("5.00"),    // 贏
            new BigDecimal("-3.00"),   // 輸
            new BigDecimal("8.00"),    // 贏
            new BigDecimal("2.00"),    // 贏
            new BigDecimal("-1.00")    // 輸
        );

        // When
        BigDecimal winRate = calculator.calculateWinRate(returns);

        // Then
        assertThat(winRate).isEqualByComparingTo("60.00");  // 3/5 = 60%
    }
}
```

---

## 3. 整合測試

### 3.1 篩選服務整合測試

```java
@SpringBootTest
@Testcontainers
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class ScreeningServiceIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");

    @Autowired
    private ScreeningService screeningService;

    @Autowired
    private TestDataSetup testDataSetup;

    @BeforeEach
    void setUp() {
        testDataSetup.initializeTestData();
    }

    @Test
    @DisplayName("快速選股 - 強勢股模板")
    void quickScreeningStrongStocks() {
        // Given
        String templateCode = "QUICK_01";  // 強勢股
        LocalDate tradeDate = LocalDate.of(2026, 1, 15);

        // When
        ScreeningResult result = screeningService.quickScreen(templateCode, tradeDate);

        // Then
        assertThat(result.getMatchedCount()).isGreaterThan(0);
        assertThat(result.getExecutionTimeMs()).isLessThan(1000);
        assertThat(result.getStocks()).allSatisfy(stock -> {
            assertThat(stock.getSignalGrade()).isIn("A+", "A");
            assertThat(stock.getSignalDirection()).isEqualTo("BUY");
        });
    }

    @Test
    @DisplayName("自訂選股 - 多維度篩選")
    void customScreeningMultiDimensional() {
        // Given: PE < 15, ROE > 15%, RSI 30-70, 外資連買 >= 3
        ScreeningRequest request = ScreeningRequest.builder()
            .conditions(ConditionGroup.builder()
                .logic("AND")
                .conditions(List.of(
                    SingleCondition.of("F_PE", "<", List.of(15)),
                    SingleCondition.of("F_ROE", ">", List.of(15)),
                    SingleCondition.of("T_RSI", "BETWEEN", List.of(30, 70)),
                    SingleCondition.of("C_FOREIGN_CONT", ">=", List.of(3))
                ))
                .build())
            .sortBy(List.of("price_change_pct"))
            .sortDirection(List.of("DESC"))
            .limit(50)
            .build();

        // When
        ScreeningResult result = screeningService.customScreen(request);

        // Then
        assertThat(result.getStocks()).allSatisfy(stock -> {
            assertThat(stock.getPe()).isLessThan(15);
            assertThat(stock.getRoe()).isGreaterThan(15);
            assertThat(stock.getRsi()).isBetween(30.0, 70.0);
            assertThat(stock.getForeignContDays()).isGreaterThanOrEqualTo(3);
        });

        // 驗證排序
        List<Double> changes = result.getStocks().stream()
            .map(ScreeningResultDto::getPriceChangePct)
            .toList();
        assertThat(changes).isSortedAccordingTo(Comparator.reverseOrder());
    }

    @Test
    @DisplayName("自訂選股 - OR 條件組合")
    void customScreeningWithOrCondition() {
        // Given: PE < 15 AND (外資連買 >= 3 OR 投信連買 >= 3)
        ScreeningRequest request = ScreeningRequest.builder()
            .conditions(ConditionGroup.builder()
                .logic("AND")
                .conditions(List.of(
                    SingleCondition.of("F_PE", "<", List.of(15)),
                    ConditionGroup.builder()
                        .logic("OR")
                        .conditions(List.of(
                            SingleCondition.of("C_FOREIGN_CONT", ">=", List.of(3)),
                            SingleCondition.of("C_TRUST_CONT", ">=", List.of(3))
                        ))
                        .build()
                ))
                .build())
            .limit(50)
            .build();

        // When
        ScreeningResult result = screeningService.customScreen(request);

        // Then
        assertThat(result.getStocks()).allSatisfy(stock -> {
            assertThat(stock.getPe()).isLessThan(15);
            assertThat(stock.getForeignContDays() >= 3 || stock.getTrustContDays() >= 3)
                .isTrue();
        });
    }

    @Test
    @DisplayName("信號選股 - BUY 信號")
    void signalScreeningBuy() {
        // Given
        SignalScreeningRequest request = SignalScreeningRequest.builder()
            .direction("BUY")
            .minGrade("B+")
            .limit(30)
            .build();

        // When
        ScreeningResult result = screeningService.signalScreen(request);

        // Then
        assertThat(result.getStocks()).allSatisfy(stock -> {
            assertThat(stock.getSignalDirection()).isEqualTo("BUY");
            assertThat(stock.getSignalGrade()).isIn("A+", "A", "B+");
        });

        // 驗證按評分排序
        List<Double> scores = result.getStocks().stream()
            .map(ScreeningResultDto::getSignalScore)
            .toList();
        assertThat(scores).isSortedAccordingTo(Comparator.reverseOrder());
    }
}
```

### 3.2 策略管理整合測試

```java
@SpringBootTest
@Transactional
class StrategyServiceIntegrationTest {

    @Autowired
    private StrategyService strategyService;

    @Autowired
    private ScreeningStrategyMapper strategyMapper;

    @Test
    @DisplayName("建立策略 - 成功")
    void createStrategySuccess() {
        // Given
        CreateStrategyRequest request = CreateStrategyRequest.builder()
            .strategyName("我的選股策略")
            .description("低估值高品質")
            .conditions(ConditionGroup.builder()
                .logic("AND")
                .conditions(List.of(
                    SingleCondition.of("F_PE", "<", List.of(15)),
                    SingleCondition.of("F_ROE", ">", List.of(15))
                ))
                .build())
            .ownerId("user001")
            .build();

        // When
        StrategyResponse response = strategyService.createStrategy(request);

        // Then
        assertThat(response.getStrategyId()).isNotNull();
        assertThat(response.getStrategyName()).isEqualTo("我的選股策略");
        assertThat(response.getConditionSummary()).contains("PE", "ROE");

        // 驗證資料庫
        ScreeningStrategy saved = strategyMapper.findByStrategyId(response.getStrategyId());
        assertThat(saved).isNotNull();
        assertThat(saved.getStatus()).isEqualTo("ACTIVE");
    }

    @Test
    @DisplayName("執行策略 - 更新統計")
    void executeStrategyUpdatesStats() {
        // Given
        String strategyId = createTestStrategy();
        int originalCount = strategyMapper.findByStrategyId(strategyId).getExecutionCount();

        // When
        strategyService.executeStrategy(strategyId, "user001");

        // Then
        ScreeningStrategy updated = strategyMapper.findByStrategyId(strategyId);
        assertThat(updated.getExecutionCount()).isEqualTo(originalCount + 1);
        assertThat(updated.getLastExecutedAt()).isNotNull();
    }

    @Test
    @DisplayName("刪除策略 - 軟刪除")
    void deleteStrategySoftDelete() {
        // Given
        String strategyId = createTestStrategy();

        // When
        strategyService.deleteStrategy(strategyId, "user001");

        // Then
        ScreeningStrategy deleted = strategyMapper.findByStrategyIdIncludeDeleted(strategyId);
        assertThat(deleted.getStatus()).isEqualTo("DELETED");
    }

    @Test
    @DisplayName("複製策略")
    void copyStrategy() {
        // Given
        String originalId = createTestStrategy();
        strategyService.makePublic(originalId, "user001");

        // When
        StrategyResponse copied = strategyService.copyStrategy(originalId, "user002");

        // Then
        assertThat(copied.getStrategyId()).isNotEqualTo(originalId);
        assertThat(copied.getOwnerId()).isEqualTo("user002");

        // 原策略 copy_count 增加
        ScreeningStrategy original = strategyMapper.findByStrategyId(originalId);
        assertThat(original.getCopyCount()).isEqualTo(1);
    }
}
```

---

## 4. API 測試

### 4.1 快速選股 API

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class QuickScreeningApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("GET /api/v1/screening/quick/{templateCode} - 成功")
    void quickScreeningSuccess() throws Exception {
        mockMvc.perform(get("/api/v1/screening/quick/QUICK_01")
                .param("date", "2026-01-15"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.data.stocks").isArray())
            .andExpect(jsonPath("$.data.matchedCount").isNumber())
            .andExpect(jsonPath("$.data.executionTimeMs").isNumber());
    }

    @Test
    @DisplayName("GET /api/v1/screening/quick/{templateCode} - 無效模板")
    void quickScreeningInvalidTemplate() throws Exception {
        mockMvc.perform(get("/api/v1/screening/quick/INVALID"))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.code").value(404))
            .andExpect(jsonPath("$.message").value(containsString("模板")));
    }
}
```

### 4.2 自訂選股 API

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class CustomScreeningApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("POST /api/v1/screening/custom - 成功")
    void customScreeningSuccess() throws Exception {
        // Given
        CustomScreeningRequest request = CustomScreeningRequest.builder()
            .conditions(ConditionGroup.builder()
                .logic("AND")
                .conditions(List.of(
                    SingleCondition.of("F_PE", "<", List.of(15)),
                    SingleCondition.of("F_ROE", ">", List.of(15))
                ))
                .build())
            .sortBy(List.of("price_change_pct"))
            .limit(50)
            .build();

        // When/Then
        mockMvc.perform(post("/api/v1/screening/custom")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.data.stocks").isArray())
            .andExpect(jsonPath("$.data.conditionSummary").exists());
    }

    @Test
    @DisplayName("POST /api/v1/screening/custom - 條件過多")
    void customScreeningTooManyConditions() throws Exception {
        // Given: 21 個條件
        List<Object> conditions = new ArrayList<>();
        for (int i = 0; i < 21; i++) {
            conditions.add(SingleCondition.of("F_PE", "<", List.of(i + 10)));
        }

        CustomScreeningRequest request = CustomScreeningRequest.builder()
            .conditions(ConditionGroup.builder()
                .logic("AND")
                .conditions(conditions)
                .build())
            .build();

        // When/Then
        mockMvc.perform(post("/api/v1/screening/custom")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.code").value(400))
            .andExpect(jsonPath("$.message").value(containsString("20")));
    }

    @Test
    @DisplayName("POST /api/v1/screening/custom - 無效條件代碼")
    void customScreeningInvalidCondition() throws Exception {
        // Given
        CustomScreeningRequest request = CustomScreeningRequest.builder()
            .conditions(ConditionGroup.builder()
                .logic("AND")
                .conditions(List.of(
                    SingleCondition.of("INVALID_CODE", "<", List.of(15))
                ))
                .build())
            .build();

        // When/Then
        mockMvc.perform(post("/api/v1/screening/custom")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.code").value(400))
            .andExpect(jsonPath("$.message").value(containsString("INVALID_CODE")));
    }
}
```

### 4.3 策略 API

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class StrategyApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("POST /api/v1/strategies - 建立策略")
    void createStrategy() throws Exception {
        String requestBody = """
            {
                "strategyName": "測試策略",
                "description": "測試用途",
                "conditions": {
                    "logic": "AND",
                    "conditions": [
                        {"condition_code": "F_PE", "operator": "<", "values": [15]}
                    ]
                }
            }
            """;

        mockMvc.perform(post("/api/v1/strategies")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.data.strategyId").exists())
            .andExpect(jsonPath("$.data.strategyName").value("測試策略"));
    }

    @Test
    @DisplayName("GET /api/v1/strategies/{strategyId} - 取得策略")
    void getStrategy() throws Exception {
        // Given
        String strategyId = createTestStrategy();

        // When/Then
        mockMvc.perform(get("/api/v1/strategies/" + strategyId))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.strategyId").value(strategyId));
    }

    @Test
    @DisplayName("POST /api/v1/strategies/{strategyId}/execute - 執行策略")
    void executeStrategy() throws Exception {
        // Given
        String strategyId = createTestStrategy();

        // When/Then
        mockMvc.perform(post("/api/v1/strategies/" + strategyId + "/execute"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.stocks").isArray());
    }

    @Test
    @DisplayName("DELETE /api/v1/strategies/{strategyId} - 刪除策略")
    void deleteStrategy() throws Exception {
        // Given
        String strategyId = createTestStrategy();

        // When/Then
        mockMvc.perform(delete("/api/v1/strategies/" + strategyId))
            .andExpect(status().isNoContent());

        // 驗證已刪除
        mockMvc.perform(get("/api/v1/strategies/" + strategyId))
            .andExpect(status().isNotFound());
    }
}
```

---

## 5. Job 測試

### 5.1 績效追蹤 Job 測試

```java
@SpringBootTest
@Transactional
class PerformanceTrackingJobTest {

    @Autowired
    private PerformanceTrackingJob job;

    @Autowired
    private ScreeningPerformanceMapper performanceMapper;

    @Autowired
    private TestDataSetup testDataSetup;

    @Test
    @DisplayName("績效追蹤 - 更新 1 日報酬")
    void trackPerformance1Day() {
        // Given: 昨天執行的選股
        String executionId = testDataSetup.createExecutionWithResults(
            LocalDate.now().minusDays(1)
        );

        // When
        job.execute(null);

        // Then
        List<ScreeningPerformance> performances =
            performanceMapper.findByExecutionId(executionId);

        assertThat(performances).allSatisfy(p -> {
            assertThat(p.getReturn1d()).isNotNull();
            assertThat(p.getTrackingDays()).isEqualTo(1);
        });
    }

    @Test
    @DisplayName("績效追蹤 - 更新 5 日報酬")
    void trackPerformance5Day() {
        // Given: 5 天前執行的選股
        String executionId = testDataSetup.createExecutionWithResults(
            LocalDate.now().minusDays(5)
        );

        // When
        job.execute(null);

        // Then
        List<ScreeningPerformance> performances =
            performanceMapper.findByExecutionId(executionId);

        assertThat(performances).allSatisfy(p -> {
            assertThat(p.getReturn5d()).isNotNull();
            assertThat(p.getTrackingDays()).isGreaterThanOrEqualTo(5);
        });
    }
}
```

### 5.2 歷史清理 Job 測試

```java
@SpringBootTest
@Transactional
class HistoryCleanupJobTest {

    @Autowired
    private HistoryCleanupJob job;

    @Autowired
    private ScreeningResultMapper resultMapper;

    @Autowired
    private ScreeningExecutionMapper executionMapper;

    @Test
    @DisplayName("清理 90 天前的結果")
    void cleanupOldResults() {
        // Given: 建立 100 天前的結果
        String oldExecutionId = createOldExecution(100);
        String recentExecutionId = createOldExecution(30);

        int oldResultCount = resultMapper.countByExecutionId(oldExecutionId);
        int recentResultCount = resultMapper.countByExecutionId(recentExecutionId);

        // When
        job.execute(null);

        // Then
        assertThat(resultMapper.countByExecutionId(oldExecutionId)).isZero();
        assertThat(resultMapper.countByExecutionId(recentExecutionId)).isEqualTo(recentResultCount);
    }
}
```

---

## 6. 效能測試

### 6.1 篩選延遲測試

```java
@SpringBootTest
class ScreeningPerformanceTest {

    @Autowired
    private ScreeningService screeningService;

    @Test
    @DisplayName("快速選股 - P99 延遲 < 800ms")
    void quickScreeningLatency() {
        // Given
        List<Long> latencies = new ArrayList<>();

        // When: 執行 100 次
        for (int i = 0; i < 100; i++) {
            long start = System.currentTimeMillis();
            screeningService.quickScreen("QUICK_01", LocalDate.now());
            latencies.add(System.currentTimeMillis() - start);
        }

        // Then
        Collections.sort(latencies);
        long p99 = latencies.get(98);
        assertThat(p99).isLessThan(800);
    }

    @Test
    @DisplayName("複雜選股 - P99 延遲 < 3s")
    void complexScreeningLatency() {
        // Given: 15 個條件
        ScreeningRequest request = createComplexRequest(15);
        List<Long> latencies = new ArrayList<>();

        // When: 執行 50 次
        for (int i = 0; i < 50; i++) {
            long start = System.currentTimeMillis();
            screeningService.customScreen(request);
            latencies.add(System.currentTimeMillis() - start);
        }

        // Then
        Collections.sort(latencies);
        long p99 = latencies.get(48);
        assertThat(p99).isLessThan(3000);
    }
}
```

---

## 7. 測試資料管理

### 7.1 測試資料設定

```java
@Component
public class TestDataSetup {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void initializeTestData() {
        // 建立測試股票
        createTestStocks(100);

        // 建立測試日資料
        createTestDailyData(LocalDate.now());

        // 建立測試指標
        createTestIndicators(LocalDate.now());

        // 建立測試信號
        createTestSignals(LocalDate.now());
    }

    private void createTestStocks(int count) {
        for (int i = 0; i < count; i++) {
            String stockId = String.format("%04d", 2000 + i);
            jdbcTemplate.update("""
                INSERT INTO stocks (stock_id, stock_name, market, status)
                VALUES (?, ?, ?, 'ACTIVE')
                ON CONFLICT (stock_id) DO NOTHING
                """, stockId, "測試股票" + stockId, i % 2 == 0 ? "TWSE" : "OTC");
        }
    }
}
```

---

## 8. 測試覆蓋率要求

| 模組 | 行覆蓋率 | 分支覆蓋率 | 說明 |
|-----|---------|-----------|------|
| ConditionParser | ≥ 90% | ≥ 85% | 核心解析邏輯 |
| QueryBuilder | ≥ 90% | ≥ 85% | SQL 建構邏輯 |
| ScreeningService | ≥ 85% | ≥ 80% | 業務服務 |
| Controller | ≥ 80% | ≥ 75% | API 層 |
| Job | ≥ 80% | ≥ 75% | 排程任務 |

---

## 9. 相關文檔

- [M14 功能需求](../specs/functional/M14-選股引擎功能需求.md)
- [M14 API 規格](../specs/api/M14-API規格.md)
- [M14 效能考量](./M14-效能考量.md)

---

**文件維護者**: QA 工程師
**最後更新**: 2026-01-15
**下次審核**: 2026-04-15
