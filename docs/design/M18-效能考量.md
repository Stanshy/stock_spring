# M18 投資組合管理 效能考量

## 文件資訊
| 項目 | 內容 |
|------|------|
| 模組代號 | M18 |
| 模組名稱 | 投資組合管理 Portfolio Management |
| 文件版本 | 1.0 |
| 建立日期 | 2026-01-15 |

---

## 效能目標

| 指標 | 目標值 | 說明 |
|------|--------|------|
| API 回應時間 (P95) | < 200ms | 一般查詢 |
| API 回應時間 (P95) | < 500ms | 績效計算 |
| 快照產生時間 | < 5 分鐘 | 1000 個投組 |
| 績效計算時間 | < 15 分鐘 | 全部投組 |
| 資料庫查詢時間 | < 50ms | 單一投組持倉 |
| 記憶體使用 | < 2GB | Job 執行期間 |

---

## 1. 績效計算優化

### 1.1 TWR 計算優化

**問題：** 長期間 TWR 計算需要遍歷所有每日快照，計算量大。

**優化策略：**

#### 增量計算

```java
/**
 * 增量 TWR 計算：僅計算新增天數的報酬
 *
 * 公式：TWR_new = (1 + TWR_old) × (1 + r_new) - 1
 */
public class IncrementalTwrCalculator {

    // 快取已計算的累積因子
    private final Map<String, BigDecimal> cumulativeFactorCache = new ConcurrentHashMap<>();

    public BigDecimal calculateTwrIncremental(String portfolioId, LocalDate startDate, LocalDate endDate) {

        String cacheKey = portfolioId + "_" + startDate;

        // 1. 嘗試取得快取的累積因子
        BigDecimal cachedFactor = cumulativeFactorCache.get(cacheKey);
        LocalDate cachedDate = getCachedDate(cacheKey);

        if (cachedFactor != null && cachedDate != null && cachedDate.isBefore(endDate)) {
            // 只計算 cachedDate 到 endDate 的增量
            BigDecimal incrementalFactor = calculateFactorForRange(
                portfolioId, cachedDate.plusDays(1), endDate);

            BigDecimal newFactor = cachedFactor.multiply(incrementalFactor);
            cumulativeFactorCache.put(cacheKey, newFactor);

            return newFactor.subtract(BigDecimal.ONE);
        }

        // 2. 無快取，完整計算
        BigDecimal factor = calculateFactorForRange(portfolioId, startDate, endDate);
        cumulativeFactorCache.put(cacheKey, factor);

        return factor.subtract(BigDecimal.ONE);
    }

    private BigDecimal calculateFactorForRange(String portfolioId, LocalDate start, LocalDate end) {
        List<Snapshot> snapshots = snapshotRepository
            .findByPortfolioIdAndDateBetween(portfolioId, start, end);

        BigDecimal factor = BigDecimal.ONE;
        Snapshot prev = null;

        for (Snapshot snap : snapshots) {
            if (prev != null) {
                BigDecimal dailyReturn = calculateDailyReturn(prev, snap);
                factor = factor.multiply(BigDecimal.ONE.add(dailyReturn));
            }
            prev = snap;
        }

        return factor;
    }
}
```

#### 預計算常用期間

```java
/**
 * 預計算服務：定期預先計算常用期間的 TWR
 */
@Service
public class PerformancePrecomputeService {

    // 預計算的期間
    private static final List<Period> PRECOMPUTE_PERIODS = List.of(
        Period.ofDays(7),    // 1 週
        Period.ofMonths(1),  // 1 月
        Period.ofMonths(3),  // 3 月
        Period.ofMonths(6),  // 6 月
        Period.ofYears(1)    // 1 年
    );

    @Scheduled(cron = "0 45 14 ? * MON-FRI")
    public void precomputePerformance() {
        List<Portfolio> portfolios = portfolioRepository.findByStatus(PortfolioStatus.ACTIVE);
        LocalDate today = LocalDate.now();

        portfolios.parallelStream().forEach(pf -> {
            for (Period period : PRECOMPUTE_PERIODS) {
                LocalDate startDate = today.minus(period);
                try {
                    BigDecimal twr = calculateTwr(pf.getId(), startDate, today);
                    cachePerformance(pf.getId(), period, twr);
                } catch (Exception e) {
                    log.warn("預計算失敗: portfolioId={}, period={}", pf.getId(), period);
                }
            }
        });
    }
}
```

### 1.2 MWR 計算優化

**問題：** MWR 使用牛頓法迭代求解，可能收斂緩慢或不收斂。

**優化策略：**

```java
public class OptimizedMwrCalculator {

    private static final int MAX_ITERATIONS = 50;
    private static final double TOLERANCE = 1e-9;

    /**
     * 優化的 MWR 計算
     * 1. 使用更好的初始猜測值
     * 2. 加入收斂保護
     * 3. 使用 Brent's method 作為備援
     */
    public BigDecimal calculateMwr(List<CashFlowPoint> cashFlows) {

        // 1. 計算簡單報酬率作為初始猜測
        double initialGuess = estimateInitialGuess(cashFlows);

        // 2. 牛頓法求解
        Double result = newtonRaphson(cashFlows, initialGuess);

        // 3. 若牛頓法不收斂，使用 Brent's method
        if (result == null) {
            result = brentMethod(cashFlows, -0.99, 10.0);
        }

        if (result == null) {
            throw new CalculationException("MWR 計算無法收斂");
        }

        return BigDecimal.valueOf(result).setScale(6, RoundingMode.HALF_UP);
    }

    private double estimateInitialGuess(List<CashFlowPoint> cashFlows) {
        // 使用簡單報酬率作為初始估計
        double totalIn = 0, totalOut = 0;
        for (CashFlowPoint cf : cashFlows) {
            if (cf.getAmount() < 0) totalIn -= cf.getAmount();
            else totalOut += cf.getAmount();
        }
        return (totalOut - totalIn) / totalIn;
    }

    private Double newtonRaphson(List<CashFlowPoint> cashFlows, double guess) {
        double x = guess;

        for (int i = 0; i < MAX_ITERATIONS; i++) {
            double[] npvAndDerivative = calculateNpvAndDerivative(cashFlows, x);
            double npv = npvAndDerivative[0];
            double derivative = npvAndDerivative[1];

            if (Math.abs(npv) < TOLERANCE) {
                return x;
            }

            if (Math.abs(derivative) < TOLERANCE) {
                return null; // 避免除以零
            }

            double newX = x - npv / derivative;

            // 收斂檢查
            if (Math.abs(newX - x) < TOLERANCE) {
                return newX;
            }

            // 邊界保護
            if (newX <= -1) {
                newX = -0.99;
            }

            x = newX;
        }

        return null; // 未收斂
    }
}
```

---

## 2. 快照儲存優化

### 2.1 資料表分區

```sql
-- 按月分區快照表
CREATE TABLE portfolio_snapshots (
    id VARCHAR(32),
    portfolio_id VARCHAR(32) NOT NULL,
    snapshot_date DATE NOT NULL,
    -- ... 其他欄位
    PRIMARY KEY (id, snapshot_date)
) PARTITION BY RANGE (snapshot_date);

-- 建立分區
CREATE TABLE portfolio_snapshots_2026_01 PARTITION OF portfolio_snapshots
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

CREATE TABLE portfolio_snapshots_2026_02 PARTITION OF portfolio_snapshots
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

-- 自動建立分區的函數
CREATE OR REPLACE FUNCTION create_snapshot_partition()
RETURNS void AS $$
DECLARE
    partition_date DATE;
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
BEGIN
    -- 建立未來 3 個月的分區
    FOR i IN 0..2 LOOP
        partition_date := DATE_TRUNC('month', CURRENT_DATE + (i || ' months')::INTERVAL);
        partition_name := 'portfolio_snapshots_' || TO_CHAR(partition_date, 'YYYY_MM');
        start_date := partition_date;
        end_date := partition_date + INTERVAL '1 month';

        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF portfolio_snapshots FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 2.2 快照壓縮儲存

```java
/**
 * 快照壓縮服務：壓縮舊資料以節省儲存空間
 */
@Service
public class SnapshotCompressionService {

    /**
     * 將每日快照壓縮為週/月摘要
     * 保留：期初、期末、最高、最低
     */
    public void compressOldSnapshots(String portfolioId, LocalDate before) {

        // 1. 按月分組
        List<Snapshot> snapshots = snapshotRepository
            .findByPortfolioIdAndDateBefore(portfolioId, before);

        Map<YearMonth, List<Snapshot>> byMonth = snapshots.stream()
            .collect(Collectors.groupingBy(s -> YearMonth.from(s.getSnapshotDate())));

        for (Map.Entry<YearMonth, List<Snapshot>> entry : byMonth.entrySet()) {
            List<Snapshot> monthSnapshots = entry.getValue();

            if (monthSnapshots.size() <= 4) continue; // 已壓縮或資料不足

            // 2. 建立月摘要
            MonthlySummary summary = createMonthlySummary(monthSnapshots);
            monthlySummaryRepository.save(summary);

            // 3. 僅保留關鍵日期的快照
            Set<LocalDate> keepDates = Set.of(
                monthSnapshots.get(0).getSnapshotDate(),                    // 月初
                monthSnapshots.get(monthSnapshots.size() - 1).getSnapshotDate(), // 月末
                findHighestValueDate(monthSnapshots),                       // 最高值日
                findLowestValueDate(monthSnapshots)                         // 最低值日
            );

            // 4. 刪除其他快照
            for (Snapshot snap : monthSnapshots) {
                if (!keepDates.contains(snap.getSnapshotDate())) {
                    snapshotPositionRepository.deleteBySnapshotId(snap.getId());
                    snapshotRepository.delete(snap);
                }
            }
        }
    }
}
```

---

## 3. 持倉查詢優化

### 3.1 覆蓋索引

```sql
-- 持倉總覽查詢的覆蓋索引
CREATE INDEX idx_positions_overview_covering
    ON portfolio_positions (portfolio_id, shares DESC)
    INCLUDE (stock_id, market_value, weight, unrealized_pnl, avg_cost)
    WHERE shares > 0;

-- 查詢可直接從索引獲取所需欄位，無需回表
EXPLAIN ANALYZE
SELECT stock_id, market_value, weight, unrealized_pnl
FROM portfolio_positions
WHERE portfolio_id = 'pf_001' AND shares > 0
ORDER BY weight DESC;
```

### 3.2 持倉快取

```java
@Service
public class PositionCacheService {

    private final RedisTemplate<String, Object> redisTemplate;

    private static final String CACHE_PREFIX = "m18:positions:";
    private static final Duration CACHE_TTL = Duration.ofMinutes(5);

    /**
     * 取得持倉（優先從快取）
     */
    public List<PositionDto> getPositions(String portfolioId) {
        String cacheKey = CACHE_PREFIX + portfolioId;

        // 1. 嘗試從快取取得
        @SuppressWarnings("unchecked")
        List<PositionDto> cached = (List<PositionDto>) redisTemplate.opsForValue().get(cacheKey);

        if (cached != null) {
            return cached;
        }

        // 2. 從資料庫查詢
        List<Position> positions = positionRepository
            .findByPortfolioIdAndSharesGreaterThan(portfolioId, BigDecimal.ZERO);

        List<PositionDto> dtos = positions.stream()
            .map(this::toDto)
            .collect(Collectors.toList());

        // 3. 寫入快取
        redisTemplate.opsForValue().set(cacheKey, dtos, CACHE_TTL);

        return dtos;
    }

    /**
     * 交易完成後清除快取
     */
    @EventListener
    public void onTradeExecuted(TradeExecutedEvent event) {
        String cacheKey = CACHE_PREFIX + event.getPortfolioId();
        redisTemplate.delete(cacheKey);
    }
}
```

---

## 4. Brinson 歸因優化

### 4.1 批次計算

```java
/**
 * Brinson 歸因批次計算器
 * 使用矩陣運算提升效能
 */
public class BatchBrinsonCalculator {

    /**
     * 批次計算多個投組的歸因
     */
    public Map<String, AttributionResult> calculateBatch(
            List<String> portfolioIds, LocalDate startDate, LocalDate endDate) {

        // 1. 批次取得基準資料（共用）
        Map<String, SectorData> benchmarkSectors = benchmarkService
            .getSectorDataMap(startDate, endDate);
        BigDecimal benchmarkReturn = benchmarkService.getReturn(startDate, endDate);

        // 2. 並行計算各投組歸因
        return portfolioIds.parallelStream()
            .collect(Collectors.toMap(
                Function.identity(),
                pId -> calculateSingleAttribution(pId, benchmarkSectors, benchmarkReturn, startDate, endDate)
            ));
    }

    private AttributionResult calculateSingleAttribution(
            String portfolioId,
            Map<String, SectorData> benchmarkSectors,
            BigDecimal benchmarkReturn,
            LocalDate startDate,
            LocalDate endDate) {

        // 取得投組產業資料
        List<SectorData> portfolioSectors = calculatePortfolioSectorData(
            portfolioId, startDate, endDate);

        // 向量化計算
        double[] wpArray = new double[portfolioSectors.size()];
        double[] wbArray = new double[portfolioSectors.size()];
        double[] rpArray = new double[portfolioSectors.size()];
        double[] rbArray = new double[portfolioSectors.size()];

        int i = 0;
        for (SectorData ps : portfolioSectors) {
            SectorData bs = benchmarkSectors.getOrDefault(ps.getSector(),
                new SectorData(ps.getSector(), BigDecimal.ZERO, benchmarkReturn));

            wpArray[i] = ps.getWeight().doubleValue();
            wbArray[i] = bs.getWeight().doubleValue();
            rpArray[i] = ps.getReturn().doubleValue();
            rbArray[i] = bs.getReturn().doubleValue();
            i++;
        }

        // 使用 SIMD 優化的向量運算
        double bmReturn = benchmarkReturn.doubleValue();
        double allocation = 0, selection = 0, interaction = 0;

        for (int j = 0; j < wpArray.length; j++) {
            double weightDiff = wpArray[j] - wbArray[j];
            double returnDiff = rpArray[j] - rbArray[j];

            allocation += weightDiff * (rbArray[j] - bmReturn);
            selection += wbArray[j] * returnDiff;
            interaction += weightDiff * returnDiff;
        }

        return AttributionResult.builder()
            .allocationEffect(BigDecimal.valueOf(allocation))
            .selectionEffect(BigDecimal.valueOf(selection))
            .interactionEffect(BigDecimal.valueOf(interaction))
            .build();
    }
}
```

---

## 5. API 回應優化

### 5.1 投影查詢

```java
/**
 * 使用投影減少資料傳輸量
 */
public interface PositionSummaryProjection {
    String getStockId();
    String getStockName();
    BigDecimal getShares();
    BigDecimal getMarketValue();
    BigDecimal getWeight();
    BigDecimal getUnrealizedPnL();
}

@Repository
public interface PositionRepository extends JpaRepository<Position, String> {

    // 使用投影查詢，只取需要的欄位
    @Query("""
        SELECT p.stockId as stockId,
               s.name as stockName,
               p.shares as shares,
               p.marketValue as marketValue,
               p.weight as weight,
               p.unrealizedPnL as unrealizedPnL
        FROM Position p
        LEFT JOIN Stock s ON p.stockId = s.stockId
        WHERE p.portfolioId = :portfolioId AND p.shares > 0
        ORDER BY p.weight DESC
        """)
    List<PositionSummaryProjection> findPositionSummaries(
        @Param("portfolioId") String portfolioId);
}
```

### 5.2 分頁與懶載入

```java
@RestController
@RequestMapping("/api/v1/portfolios")
public class PortfolioController {

    /**
     * 投組總覽 - 僅載入摘要資料
     */
    @GetMapping("/{id}")
    public PortfolioSummaryResponse getPortfolio(@PathVariable String id) {
        // 只載入基本資訊，持倉摘要
        return portfolioService.getPortfolioSummary(id);
    }

    /**
     * 持倉詳情 - 分頁載入
     */
    @GetMapping("/{id}/positions")
    public Page<PositionDto> getPositions(
            @PathVariable String id,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {

        return positionService.getPositions(id, PageRequest.of(page, size,
            Sort.by(Sort.Direction.DESC, "weight")));
    }

    /**
     * 績效歷史 - 支援採樣
     */
    @GetMapping("/{id}/performance/history")
    public PerformanceHistoryResponse getPerformanceHistory(
            @PathVariable String id,
            @RequestParam LocalDate startDate,
            @RequestParam LocalDate endDate,
            @RequestParam(defaultValue = "DAILY") Interval interval) {

        // 長期間自動降採樣
        if (ChronoUnit.DAYS.between(startDate, endDate) > 365) {
            interval = Interval.WEEKLY;
        }

        return performanceService.getHistory(id, startDate, endDate, interval);
    }
}
```

### 5.3 回應壓縮

```yaml
# application.yml
server:
  compression:
    enabled: true
    min-response-size: 1024
    mime-types:
      - application/json
      - application/xml
      - text/html
```

---

## 6. 批次處理優化

### 6.1 快照產生並行處理

```java
@Service
public class SnapshotBatchService {

    @Value("${m18.snapshot.batch-size:100}")
    private int batchSize;

    @Value("${m18.snapshot.thread-pool-size:4}")
    private int threadPoolSize;

    private final ExecutorService executor;

    @PostConstruct
    public void init() {
        this.executor = Executors.newFixedThreadPool(threadPoolSize,
            new ThreadFactoryBuilder()
                .setNameFormat("snapshot-worker-%d")
                .build());
    }

    /**
     * 並行產生快照
     */
    public void generateSnapshotsParallel(List<Portfolio> portfolios, LocalDate date) {

        // 分批
        List<List<Portfolio>> batches = Lists.partition(portfolios, batchSize);

        List<CompletableFuture<Void>> futures = batches.stream()
            .map(batch -> CompletableFuture.runAsync(
                () -> processBatch(batch, date), executor))
            .collect(Collectors.toList());

        // 等待所有批次完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    }

    @Transactional
    private void processBatch(List<Portfolio> batch, LocalDate date) {
        for (Portfolio portfolio : batch) {
            try {
                snapshotService.generateSnapshot(portfolio, date);
            } catch (Exception e) {
                log.error("快照產生失敗: portfolioId={}", portfolio.getId(), e);
            }
        }
    }
}
```

### 6.2 批次更新持倉價格

```java
/**
 * 使用批次 UPDATE 減少資料庫往返
 */
@Repository
public class PositionBatchRepository {

    @PersistenceContext
    private EntityManager entityManager;

    /**
     * 批次更新持倉價格
     */
    @Transactional
    public int batchUpdatePrices(Map<String, BigDecimal> stockPrices) {

        String sql = """
            UPDATE portfolio_positions p
            SET current_price = :price,
                market_value = shares * :price,
                unrealized_pnl = shares * :price - total_cost,
                unrealized_pnl_pct = CASE
                    WHEN total_cost > 0 THEN (shares * :price - total_cost) / total_cost
                    ELSE 0
                END,
                updated_at = CURRENT_TIMESTAMP
            WHERE stock_id = :stockId AND shares > 0
            """;

        int totalUpdated = 0;

        for (Map.Entry<String, BigDecimal> entry : stockPrices.entrySet()) {
            int updated = entityManager.createNativeQuery(sql)
                .setParameter("stockId", entry.getKey())
                .setParameter("price", entry.getValue())
                .executeUpdate();
            totalUpdated += updated;
        }

        return totalUpdated;
    }
}
```

---

## 7. 記憶體優化

### 7.1 串流處理大量資料

```java
/**
 * 使用串流處理避免載入全部資料到記憶體
 */
@Service
public class PerformanceStreamService {

    /**
     * 串流計算大量快照的績效
     */
    @Transactional(readOnly = true)
    public BigDecimal calculateTwrStreaming(String portfolioId, LocalDate startDate, LocalDate endDate) {

        BigDecimal cumulativeFactor = BigDecimal.ONE;
        AtomicReference<Snapshot> prevRef = new AtomicReference<>();

        try (Stream<Snapshot> stream = snapshotRepository
                .streamByPortfolioIdAndDateBetween(portfolioId, startDate, endDate)) {

            stream.forEach(current -> {
                Snapshot prev = prevRef.get();
                if (prev != null) {
                    BigDecimal dailyReturn = calculateDailyReturn(prev, current);
                    // 累乘計算
                    // 注意：這裡需要同步處理
                }
                prevRef.set(current);
            });
        }

        return cumulativeFactor.subtract(BigDecimal.ONE);
    }
}

// Repository 串流查詢
@Repository
public interface SnapshotRepository extends JpaRepository<Snapshot, String> {

    @Query("SELECT s FROM Snapshot s WHERE s.portfolioId = :portfolioId " +
           "AND s.snapshotDate BETWEEN :start AND :end ORDER BY s.snapshotDate")
    @QueryHints(value = {
        @QueryHint(name = HINT_FETCH_SIZE, value = "100"),
        @QueryHint(name = HINT_CACHEABLE, value = "false")
    })
    Stream<Snapshot> streamByPortfolioIdAndDateBetween(
        @Param("portfolioId") String portfolioId,
        @Param("start") LocalDate start,
        @Param("end") LocalDate end);
}
```

### 7.2 DTO 投影減少記憶體

```java
/**
 * 輕量級 DTO 用於批次處理
 */
@Value
public class SnapshotLightDto {
    LocalDate date;
    BigDecimal totalValue;
    BigDecimal cashInflow;
    BigDecimal cashOutflow;

    public static SnapshotLightDto from(Object[] row) {
        return new SnapshotLightDto(
            (LocalDate) row[0],
            (BigDecimal) row[1],
            (BigDecimal) row[2],
            (BigDecimal) row[3]
        );
    }
}

// 只查詢必要欄位
@Query(value = """
    SELECT snapshot_date, total_value, cash_inflow, cash_outflow
    FROM portfolio_snapshots
    WHERE portfolio_id = :portfolioId
      AND snapshot_date BETWEEN :start AND :end
    ORDER BY snapshot_date
    """, nativeQuery = true)
List<Object[]> findLightSnapshots(
    @Param("portfolioId") String portfolioId,
    @Param("start") LocalDate start,
    @Param("end") LocalDate end);
```

---

## 8. 監控與調優

### 8.1 效能監控指標

```java
@Component
public class PerformanceMetrics {

    private final MeterRegistry meterRegistry;

    // API 延遲
    private final Timer apiLatency;

    // 計算時間
    private final Timer twrCalculationTime;
    private final Timer snapshotGenerationTime;

    // 快取命中率
    private final Counter cacheHits;
    private final Counter cacheMisses;

    @PostConstruct
    public void init() {
        this.apiLatency = Timer.builder("m18.api.latency")
            .description("API 回應延遲")
            .tags("module", "M18")
            .register(meterRegistry);

        this.twrCalculationTime = Timer.builder("m18.twr.calculation.time")
            .description("TWR 計算時間")
            .register(meterRegistry);

        this.cacheHits = Counter.builder("m18.cache.hits")
            .description("快取命中次數")
            .register(meterRegistry);
    }

    public void recordApiLatency(long millis, String endpoint) {
        apiLatency.record(Duration.ofMillis(millis));
    }

    public void recordTwrCalculation(long millis, int dataPoints) {
        twrCalculationTime.record(Duration.ofMillis(millis));
    }
}
```

### 8.2 慢查詢日誌

```yaml
# application.yml
spring:
  jpa:
    properties:
      hibernate:
        session:
          events:
            log:
              LOG_QUERIES_SLOWER_THAN_MS: 100

logging:
  level:
    org.hibernate.SQL_SLOW: WARN
```

---

## 效能檢查清單

| 項目 | 檢查點 | 狀態 |
|------|--------|------|
| 資料庫 | 關鍵查詢有適當索引 | |
| 資料庫 | 快照表已分區 | |
| 快取 | 持倉資料有 Redis 快取 | |
| 快取 | 績效預計算已啟用 | |
| API | 大量資料有分頁 | |
| API | 回應壓縮已啟用 | |
| 批次 | 快照產生使用並行處理 | |
| 批次 | 價格更新使用批次 SQL | |
| 記憶體 | 大量資料使用串流處理 | |
| 監控 | 效能指標已配置 | |
