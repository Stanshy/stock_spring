# M10-æŠ€è¡“å‹æ…‹è¾¨è­˜æ¨¡çµ„æ¸¬è©¦æº–å‰‡

> **æ–‡ä»¶ç·¨è™Ÿ**: TEST-M10
> **æ¨¡çµ„åç¨±**: æŠ€è¡“å‹æ…‹è¾¨è­˜æ¨¡çµ„
> **ç‰ˆæœ¬**: v1.0
> **æœ€å¾Œæ›´æ–°**: 2026-01-12
> **ç‹€æ…‹**: Draft

---

## ğŸ“‹ æ¸¬è©¦æº–å‰‡ç¸½è¦½

æœ¬æ–‡ä»¶å®šç¾©æŠ€è¡“å‹æ…‹è¾¨è­˜æ¨¡çµ„çš„æ¸¬è©¦ç­–ç•¥ã€æ¸¬è©¦æ¡ˆä¾‹è¨­è¨ˆèˆ‡é©—æ”¶æ¨™æº–ã€‚

---

## 1. æ¸¬è©¦ç¯„åœ

### 1.1 æ¸¬è©¦é¡å‹åˆ†å¸ƒ

| æ¸¬è©¦é¡å‹ | è¦†è“‹ç›®æ¨™ | å„ªå…ˆç´š |
|---------|---------|-------|
| å–®å…ƒæ¸¬è©¦ | åµæ¸¬å™¨ã€è¨ˆç®—é‚è¼¯ | P0 |
| æ•´åˆæ¸¬è©¦ | å¼•æ“æµç¨‹ã€è³‡æ–™å­˜å– | P0 |
| API æ¸¬è©¦ | REST ç«¯é» | P0 |
| æ•ˆèƒ½æ¸¬è©¦ | å›æ‡‰æ™‚é–“ã€ååé‡ | P1 |
| æº–ç¢ºåº¦æ¸¬è©¦ | å‹æ…‹è­˜åˆ¥æ­£ç¢ºæ€§ | P0 |

### 1.2 æ¸¬è©¦è¦†è“‹ç‡ç›®æ¨™

| å±¤ç´š | ç›®æ¨™è¦†è“‹ç‡ | æœ€ä½è¦æ±‚ |
|-----|-----------|---------|
| Service å±¤ | > 90% | > 80% |
| Detector å±¤ | > 95% | > 90% |
| Controller å±¤ | > 85% | > 75% |
| Repository å±¤ | > 80% | > 70% |

---

## 2. å–®å…ƒæ¸¬è©¦

### 2.1 K ç·šå‹æ…‹åµæ¸¬å™¨æ¸¬è©¦

#### 2.1.1 éŒ˜å­ç·šåµæ¸¬æ¸¬è©¦

```java
@DisplayName("éŒ˜å­ç·šåµæ¸¬å™¨æ¸¬è©¦")
class HammerDetectorTest {

    private HammerDetector detector;

    @BeforeEach
    void setUp() {
        detector = new HammerDetector();
    }

    @Test
    @DisplayName("æ¨™æº–éŒ˜å­ç·šæ‡‰è¢«æ­£ç¢ºè­˜åˆ¥")
    void shouldDetectStandardHammer() {
        // Given: æ¨™æº–éŒ˜å­ç·š K ç·šè³‡æ–™
        Candle candle = Candle.builder()
            .open(100)
            .high(102)
            .low(90)
            .close(101)
            .build();
        TrendContext context = TrendContext.DOWNTREND;

        // When
        Optional<KLinePattern> result = detector.detect(candle, context);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().getPatternId()).isEqualTo("KLINE001");
        assertThat(result.get().getSignalType()).isEqualTo(SignalType.BULLISH_REVERSAL);
        assertThat(result.get().getStrength()).isGreaterThanOrEqualTo(60);
    }

    @Test
    @DisplayName("ä¸Šæ¼²è¶¨å‹¢ä¸­çš„éŒ˜å½¢ç·šæ‡‰è¢«è­˜åˆ¥ç‚ºä¸ŠåŠç·š")
    void shouldDetectHangingManInUptrend() {
        // Given
        Candle candle = Candle.builder()
            .open(100)
            .high(102)
            .low(90)
            .close(101)
            .build();
        TrendContext context = TrendContext.UPTREND;

        // When
        Optional<KLinePattern> result = detector.detect(candle, context);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().getPatternId()).isEqualTo("KLINE003"); // ä¸ŠåŠç·š
        assertThat(result.get().getSignalType()).isEqualTo(SignalType.BEARISH_REVERSAL);
    }

    @Test
    @DisplayName("ä¸‹å½±ç·šä¸å¤ é•·ä¸æ‡‰è­˜åˆ¥ç‚ºéŒ˜å­ç·š")
    void shouldNotDetectWhenLowerShadowTooShort() {
        // Given: ä¸‹å½±ç·šå¤ªçŸ­
        Candle candle = Candle.builder()
            .open(100)
            .high(105)
            .low(98)
            .close(103)
            .build();
        TrendContext context = TrendContext.DOWNTREND;

        // When
        Optional<KLinePattern> result = detector.detect(candle, context);

        // Then
        assertThat(result).isEmpty();
    }

    @ParameterizedTest
    @DisplayName("é‚Šç•Œæ¢ä»¶æ¸¬è©¦")
    @CsvSource({
        "100, 100.5, 90, 100.3, true",   // å¯¦é«”å¾ˆå°çš„éŒ˜å­ç·š
        "100, 110, 90, 105, false",       // ä¸Šå½±ç·šå¤ªé•·
        "100, 100, 100, 100, false"       // åå­—æ˜Ÿ
    })
    void shouldHandleBoundaryConditions(
            double open, double high, double low, double close, boolean expected) {
        // Given
        Candle candle = Candle.builder()
            .open(open).high(high).low(low).close(close).build();

        // When
        Optional<KLinePattern> result = detector.detect(candle, TrendContext.DOWNTREND);

        // Then
        assertThat(result.isPresent()).isEqualTo(expected);
    }
}
```

#### 2.1.2 åå™¬å‹æ…‹åµæ¸¬æ¸¬è©¦

```java
@DisplayName("åå™¬å‹æ…‹åµæ¸¬å™¨æ¸¬è©¦")
class EngulfingDetectorTest {

    private EngulfingDetector detector;

    @Test
    @DisplayName("çœ‹æ¼²åå™¬æ‡‰è¢«æ­£ç¢ºè­˜åˆ¥")
    void shouldDetectBullishEngulfing() {
        // Given
        Candle prevCandle = Candle.builder()
            .open(105).high(106).low(100).close(101).build(); // é™°ç·š
        Candle currCandle = Candle.builder()
            .open(100).high(108).low(99).close(107).build();  // é™½ç·šåå™¬

        // When
        Optional<KLinePattern> result = detector.detect(
            List.of(prevCandle, currCandle), TrendContext.DOWNTREND);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().getPatternId()).isEqualTo("KLINE020");
        assertThat(result.get().getSignalType()).isEqualTo(SignalType.BULLISH_REVERSAL);
    }

    @Test
    @DisplayName("çœ‹è·Œåå™¬æ‡‰è¢«æ­£ç¢ºè­˜åˆ¥")
    void shouldDetectBearishEngulfing() {
        // Given
        Candle prevCandle = Candle.builder()
            .open(100).high(106).low(99).close(105).build();  // é™½ç·š
        Candle currCandle = Candle.builder()
            .open(106).high(107).low(98).close(99).build();   // é™°ç·šåå™¬

        // When
        Optional<KLinePattern> result = detector.detect(
            List.of(prevCandle, currCandle), TrendContext.UPTREND);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().getPatternId()).isEqualTo("KLINE021");
        assertThat(result.get().getSignalType()).isEqualTo(SignalType.BEARISH_REVERSAL);
    }

    @Test
    @DisplayName("æœªå®Œå…¨åå™¬ä¸æ‡‰è¢«è­˜åˆ¥")
    void shouldNotDetectPartialEngulfing() {
        // Given: é™½ç·šæœªå®Œå…¨åå™¬å‰ä¸€æ ¹é™°ç·š
        Candle prevCandle = Candle.builder()
            .open(105).high(106).low(100).close(101).build();
        Candle currCandle = Candle.builder()
            .open(100).high(104).low(99).close(103).build();  // æœªåå™¬

        // When
        Optional<KLinePattern> result = detector.detect(
            List.of(prevCandle, currCandle), TrendContext.DOWNTREND);

        // Then
        assertThat(result).isEmpty();
    }
}
```

### 2.2 åœ–è¡¨å‹æ…‹åµæ¸¬å™¨æ¸¬è©¦

#### 2.2.1 é›™é‡é ‚åµæ¸¬æ¸¬è©¦

```java
@DisplayName("é›™é‡é ‚åµæ¸¬å™¨æ¸¬è©¦")
class DoubleTopDetectorTest {

    private DoubleTopDetector detector;

    @Test
    @DisplayName("æ¨™æº–é›™é‡é ‚æ‡‰è¢«æ­£ç¢ºè­˜åˆ¥")
    void shouldDetectStandardDoubleTop() {
        // Given: å…©å€‹ç›¸è¿‘é«˜é»ï¼Œä¸­é–“æœ‰æ˜é¡¯å›æª”
        List<PeakTrough> peaksAndTroughs = List.of(
            PeakTrough.peak(LocalDate.of(2024, 11, 25), 598),
            PeakTrough.trough(LocalDate.of(2024, 12, 5), 565),
            PeakTrough.peak(LocalDate.of(2024, 12, 15), 595)
        );

        // When
        Optional<ChartPattern> result = detector.detect(peaksAndTroughs, 580);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().getPatternId()).isEqualTo("CHART003");
        assertThat(result.get().getStatus()).isEqualTo(PatternStatus.FORMING);
        assertThat(result.get().getKeyLevels().getNeckline()).isEqualTo(565);
    }

    @Test
    @DisplayName("å·²ç¢ºèªçš„é›™é‡é ‚")
    void shouldDetectConfirmedDoubleTop() {
        // Given: åƒ¹æ ¼å·²è·Œç ´é ¸ç·š
        List<PeakTrough> peaksAndTroughs = List.of(
            PeakTrough.peak(LocalDate.of(2024, 11, 25), 598),
            PeakTrough.trough(LocalDate.of(2024, 12, 5), 565),
            PeakTrough.peak(LocalDate.of(2024, 12, 15), 595)
        );
        double currentPrice = 560;  // è·Œç ´é ¸ç·š 565

        // When
        Optional<ChartPattern> result = detector.detect(peaksAndTroughs, currentPrice);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().getStatus()).isEqualTo(PatternStatus.CONFIRMED);
        assertThat(result.get().getTargetPrice()).isLessThan(565);
    }

    @Test
    @DisplayName("å…©å€‹é«˜é»å·®è·éå¤§ä¸æ‡‰è­˜åˆ¥")
    void shouldNotDetectWhenPeaksDifferTooMuch() {
        // Given: å…©å€‹é«˜é»å·®è· > 5%
        List<PeakTrough> peaksAndTroughs = List.of(
            PeakTrough.peak(LocalDate.of(2024, 11, 25), 600),
            PeakTrough.trough(LocalDate.of(2024, 12, 5), 550),
            PeakTrough.peak(LocalDate.of(2024, 12, 15), 560)  // å·®è· 6.7%
        );

        // When
        Optional<ChartPattern> result = detector.detect(peaksAndTroughs, 555);

        // Then
        assertThat(result).isEmpty();
    }
}
```

### 2.3 è¶¨å‹¢åˆ†ææ¸¬è©¦

```java
@DisplayName("è¶¨å‹¢åˆ†æå™¨æ¸¬è©¦")
class TrendAnalyzerTest {

    @Test
    @DisplayName("ä¸Šå‡è¶¨å‹¢æ‡‰è¢«æ­£ç¢ºè­˜åˆ¥")
    void shouldIdentifyUptrend() {
        // Given: é€£çºŒçš„æ›´é«˜é«˜é»å’Œæ›´é«˜ä½é»
        List<PeakTrough> structure = List.of(
            PeakTrough.trough(LocalDate.of(2024, 11, 1), 500),
            PeakTrough.peak(LocalDate.of(2024, 11, 10), 530),
            PeakTrough.trough(LocalDate.of(2024, 11, 20), 520),
            PeakTrough.peak(LocalDate.of(2024, 12, 1), 560),
            PeakTrough.trough(LocalDate.of(2024, 12, 10), 545),
            PeakTrough.peak(LocalDate.of(2024, 12, 20), 580)
        );

        // When
        TrendAnalysis result = trendAnalyzer.analyze(structure);

        // Then
        assertThat(result.getPrimaryTrendId()).isEqualTo("TREND001");
        assertThat(result.getHigherHighsCount()).isEqualTo(3);
        assertThat(result.getHigherLowsCount()).isEqualTo(3);
        assertThat(result.getStructureType()).isEqualTo("BULLISH");
    }

    @Test
    @DisplayName("å‡ç·šå¤šé ­æ’åˆ—æ‡‰åŠ å¼·è¶¨å‹¢å¼·åº¦")
    void shouldIncreaseTrendStrengthWithBullishMAAlignment() {
        // Given
        MAData maData = MAData.builder()
            .ma5(580).ma10(575).ma20(565).ma60(545).build();

        // When
        int maScore = trendAnalyzer.calculateMAAlignmentScore(maData);

        // Then
        assertThat(maScore).isGreaterThanOrEqualTo(25);
    }
}
```

---

## 3. æ•´åˆæ¸¬è©¦

### 3.1 å‹æ…‹åµæ¸¬å¼•æ“æ•´åˆæ¸¬è©¦

```java
@SpringBootTest
@Transactional
@DisplayName("å‹æ…‹åµæ¸¬å¼•æ“æ•´åˆæ¸¬è©¦")
class PatternEngineIntegrationTest {

    @Autowired
    private PatternEngine patternEngine;

    @Autowired
    private DailyPriceRepository priceRepository;

    @Test
    @DisplayName("å®Œæ•´å‹æ…‹åµæ¸¬æµç¨‹")
    void shouldCompleteFullDetectionFlow() {
        // Given
        String stockId = "2330";
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        PatternDetectionPlan plan = PatternDetectionPlan.full();

        // When
        PatternDetectionResult result = patternEngine.detect(stockId, tradeDate, plan);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStockId()).isEqualTo(stockId);
        assertThat(result.getKlinePatterns()).isNotNull();
        assertThat(result.getChartPatterns()).isNotNull();
        assertThat(result.getTrendAnalysis()).isNotNull();
        assertThat(result.getSupportResistanceLevels()).isNotNull();
        assertThat(result.getDiagnostics().getCalculationTimeMs()).isLessThan(500);
    }

    @Test
    @DisplayName("æ‰¹æ¬¡åµæ¸¬æ‡‰æ­£ç¢ºè™•ç†")
    void shouldHandleBatchDetection() {
        // Given
        List<String> stockIds = List.of("2330", "2317", "2454");
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);
        PatternDetectionPlan plan = PatternDetectionPlan.quick();

        // When
        List<PatternDetectionResult> results = patternEngine.batchDetect(stockIds, tradeDate, plan);

        // Then
        assertThat(results).hasSize(3);
        assertThat(results).allMatch(r -> r.getKlinePatterns() != null);
    }

    @Test
    @DisplayName("è³‡æ–™ä¸è¶³æ‡‰å›å‚³é©ç•¶éŒ¯èª¤")
    void shouldHandleInsufficientData() {
        // Given: è‚¡ç¥¨åªæœ‰ 10 å¤©è³‡æ–™
        String stockId = "9999";
        LocalDate tradeDate = LocalDate.of(2024, 12, 24);

        // When & Then
        assertThatThrownBy(() -> patternEngine.detect(stockId, tradeDate, PatternDetectionPlan.full()))
            .isInstanceOf(PatternDetectionException.class)
            .hasMessageContaining("è³‡æ–™ä¸è¶³");
    }
}
```

### 3.2 è³‡æ–™å­˜å–å±¤æ•´åˆæ¸¬è©¦

```java
@SpringBootTest
@Transactional
@DisplayName("å‹æ…‹è³‡æ–™å­˜å–æ•´åˆæ¸¬è©¦")
class PatternRepositoryIntegrationTest {

    @Autowired
    private KLinePatternRepository klinePatternRepository;

    @Autowired
    private ChartPatternRepository chartPatternRepository;

    @Test
    @DisplayName("K ç·šå‹æ…‹æ‰¹æ¬¡å„²å­˜èˆ‡æŸ¥è©¢")
    void shouldSaveAndQueryKLinePatterns() {
        // Given
        List<KLinePatternResult> patterns = List.of(
            createKLinePattern("2330", "KLINE020", 85),
            createKLinePattern("2330", "KLINE040", 72),
            createKLinePattern("2317", "KLINE001", 68)
        );

        // When
        klinePatternRepository.batchInsert(patterns);
        List<KLinePatternResult> results = klinePatternRepository
            .findByStockIdAndTradeDate("2330", LocalDate.now());

        // Then
        assertThat(results).hasSize(2);
    }

    @Test
    @DisplayName("åœ–è¡¨å‹æ…‹ç‹€æ…‹æ›´æ–°")
    void shouldUpdateChartPatternStatus() {
        // Given
        ChartPatternResult pattern = createChartPattern("2330", "CHART003", PatternStatus.FORMING);
        chartPatternRepository.save(pattern);

        // When
        pattern.setStatus(PatternStatus.CONFIRMED);
        chartPatternRepository.save(pattern);
        ChartPatternResult updated = chartPatternRepository.findById(pattern.getResultId()).orElseThrow();

        // Then
        assertThat(updated.getStatus()).isEqualTo(PatternStatus.CONFIRMED);
    }
}
```

---

## 4. API æ¸¬è©¦

### 4.1 REST API æ¸¬è©¦

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@DisplayName("å‹æ…‹åˆ†æ API æ¸¬è©¦")
class PatternApiTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    @DisplayName("GET /pattern/{stockId}/kline æ‡‰å›å‚³ K ç·šå‹æ…‹")
    void shouldReturnKLinePatterns() {
        // When
        ResponseEntity<ApiResponse<KLinePatternResponse>> response = restTemplate.exchange(
            "/api/v1/pattern/2330/kline?min_strength=60",
            HttpMethod.GET,
            null,
            new ParameterizedTypeReference<>() {}
        );

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getCode()).isEqualTo(200);
        assertThat(response.getBody().getData().getStockId()).isEqualTo("2330");
    }

    @Test
    @DisplayName("GET /pattern/{stockId}/analysis æ‡‰å›å‚³å®Œæ•´åˆ†æ")
    void shouldReturnFullAnalysis() {
        // When
        ResponseEntity<ApiResponse<PatternAnalysisResponse>> response = restTemplate.exchange(
            "/api/v1/pattern/2330/analysis",
            HttpMethod.GET,
            null,
            new ParameterizedTypeReference<>() {}
        );

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getData().getKlineAnalysis()).isNotNull();
        assertThat(response.getBody().getData().getChartAnalysis()).isNotNull();
        assertThat(response.getBody().getData().getTrendAnalysis()).isNotNull();
    }

    @Test
    @DisplayName("ä¸å­˜åœ¨çš„è‚¡ç¥¨æ‡‰å›å‚³ 404")
    void shouldReturn404ForNonExistentStock() {
        // When
        ResponseEntity<ApiResponse<?>> response = restTemplate.exchange(
            "/api/v1/pattern/9999/kline",
            HttpMethod.GET,
            null,
            new ParameterizedTypeReference<>() {}
        );

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        assertThat(response.getBody().getError().getErrorCode()).isEqualTo("M10_PTN_001");
    }

    @Test
    @DisplayName("GET /pattern/scan/kline æ‡‰å›å‚³æƒæçµæœ")
    void shouldReturnScanResults() {
        // When
        ResponseEntity<ApiResponse<KLineScanResponse>> response = restTemplate.exchange(
            "/api/v1/pattern/scan/kline?min_strength=70&limit=50",
            HttpMethod.GET,
            null,
            new ParameterizedTypeReference<>() {}
        );

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getData().getResults().size()).isLessThanOrEqualTo(50);
    }
}
```

---

## 5. æº–ç¢ºåº¦æ¸¬è©¦

### 5.1 K ç·šå‹æ…‹æº–ç¢ºåº¦æ¸¬è©¦

```java
@DisplayName("K ç·šå‹æ…‹æº–ç¢ºåº¦æ¸¬è©¦")
class KLinePatternAccuracyTest {

    private static final String TEST_DATA_DIR = "src/test/resources/pattern-test-data/";

    @ParameterizedTest
    @DisplayName("éŒ˜å­ç·šè­˜åˆ¥æº–ç¢ºåº¦æ¸¬è©¦")
    @CsvFileSource(resources = "/pattern-test-data/hammer-test-cases.csv", numLinesToSkip = 1)
    void testHammerAccuracy(
            double open, double high, double low, double close,
            String trend, boolean expected, String description) {

        // Given
        Candle candle = Candle.builder()
            .open(open).high(high).low(low).close(close).build();
        TrendContext context = TrendContext.valueOf(trend);

        // When
        Optional<KLinePattern> result = hammerDetector.detect(candle, context);

        // Then
        assertThat(result.isPresent())
            .as(description)
            .isEqualTo(expected);
    }

    @Test
    @DisplayName("æ­·å²è³‡æ–™å‹æ…‹è­˜åˆ¥é©—è­‰")
    void testAgainstHistoricalData() {
        // Given: å·²æ¨™è¨˜çš„æ­·å²å‹æ…‹è³‡æ–™
        List<LabeledPatternData> testData = loadLabeledData("labeled-kline-patterns.json");

        // When
        int correctCount = 0;
        int totalCount = testData.size();

        for (LabeledPatternData data : testData) {
            Optional<KLinePattern> result = klineDetector.detect(data.getCandles(), data.getContext());
            if (result.isPresent() && result.get().getPatternId().equals(data.getExpectedPatternId())) {
                correctCount++;
            }
        }

        // Then
        double accuracy = (double) correctCount / totalCount;
        assertThat(accuracy)
            .as("K ç·šå‹æ…‹è­˜åˆ¥æº–ç¢ºç‡")
            .isGreaterThanOrEqualTo(0.90);  // ç›®æ¨™ 90%
    }
}
```

### 5.2 åœ–è¡¨å‹æ…‹æº–ç¢ºåº¦æ¸¬è©¦

```java
@DisplayName("åœ–è¡¨å‹æ…‹æº–ç¢ºåº¦æ¸¬è©¦")
class ChartPatternAccuracyTest {

    @Test
    @DisplayName("é›™é‡é ‚è­˜åˆ¥æº–ç¢ºåº¦")
    void testDoubleTopAccuracy() {
        // Given: è¼‰å…¥å·²æ¨™è¨˜çš„é›™é‡é ‚æ¸¬è©¦è³‡æ–™
        List<LabeledChartPattern> testData = loadLabeledData("labeled-double-tops.json");

        // When & Then
        int truePositives = 0;
        int falsePositives = 0;
        int falseNegatives = 0;

        for (LabeledChartPattern data : testData) {
            Optional<ChartPattern> result = doubleTopDetector.detect(
                data.getPeaksAndTroughs(), data.getCurrentPrice());

            if (data.isExpectedPattern() && result.isPresent()) {
                truePositives++;
            } else if (!data.isExpectedPattern() && result.isPresent()) {
                falsePositives++;
            } else if (data.isExpectedPattern() && result.isEmpty()) {
                falseNegatives++;
            }
        }

        double precision = (double) truePositives / (truePositives + falsePositives);
        double recall = (double) truePositives / (truePositives + falseNegatives);
        double f1Score = 2 * precision * recall / (precision + recall);

        assertThat(precision).as("ç²¾ç¢ºç‡").isGreaterThanOrEqualTo(0.75);
        assertThat(recall).as("å¬å›ç‡").isGreaterThanOrEqualTo(0.80);
        assertThat(f1Score).as("F1 åˆ†æ•¸").isGreaterThanOrEqualTo(0.77);
    }
}
```

---

## 6. æ•ˆèƒ½æ¸¬è©¦

### 6.1 JMeter æ¸¬è©¦è¨ˆåŠƒ

```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testname="M10 Pattern API Performance Test">
      <stringProp name="TestPlan.comments">å‹æ…‹åˆ†æ API æ•ˆèƒ½æ¸¬è©¦</stringProp>
    </TestPlan>
    <hashTree>
      <!-- K ç·šå‹æ…‹æŸ¥è©¢æ¸¬è©¦ -->
      <ThreadGroup guiclass="ThreadGroupGui" testname="KLine Pattern Query">
        <stringProp name="ThreadGroup.num_threads">50</stringProp>
        <stringProp name="ThreadGroup.ramp_time">10</stringProp>
        <stringProp name="ThreadGroup.duration">120</stringProp>
      </ThreadGroup>

      <!-- å®Œæ•´åˆ†ææŸ¥è©¢æ¸¬è©¦ -->
      <ThreadGroup guiclass="ThreadGroupGui" testname="Full Analysis Query">
        <stringProp name="ThreadGroup.num_threads">30</stringProp>
        <stringProp name="ThreadGroup.ramp_time">10</stringProp>
        <stringProp name="ThreadGroup.duration">120</stringProp>
      </ThreadGroup>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
```

### 6.2 æ•ˆèƒ½é©—æ”¶æ¨™æº–

| æ¸¬è©¦å ´æ™¯ | ä¸¦ç™¼æ•¸ | P50 | P95 | P99 | éŒ¯èª¤ç‡ |
|---------|-------|-----|-----|-----|-------|
| K ç·šå‹æ…‹æŸ¥è©¢ | 50 | < 30ms | < 80ms | < 150ms | < 0.1% |
| å®Œæ•´åˆ†ææŸ¥è©¢ | 30 | < 150ms | < 300ms | < 500ms | < 0.1% |
| å…¨å¸‚å ´æƒæ | 10 | < 500ms | < 1s | < 2s | < 0.1% |

---

## 7. æ¸¬è©¦è³‡æ–™æº–å‚™

### 7.1 æ¸¬è©¦è³‡æ–™é›†

```json
// src/test/resources/pattern-test-data/price-data-2330.json
{
  "stockId": "2330",
  "stockName": "å°ç©é›»",
  "prices": [
    {"date": "2024-12-24", "open": 578, "high": 582, "low": 575, "close": 580, "volume": 25000000},
    {"date": "2024-12-23", "open": 575, "high": 580, "low": 574, "close": 578, "volume": 22000000}
    // ... æ›´å¤šè³‡æ–™
  ]
}
```

### 7.2 å·²æ¨™è¨˜å‹æ…‹è³‡æ–™

```json
// src/test/resources/pattern-test-data/labeled-kline-patterns.json
{
  "patterns": [
    {
      "id": "test-001",
      "patternType": "KLINE020",
      "patternName": "çœ‹æ¼²åå™¬",
      "candles": [
        {"date": "2024-12-22", "open": 105, "high": 106, "low": 100, "close": 101},
        {"date": "2024-12-23", "open": 100, "high": 108, "low": 99, "close": 107}
      ],
      "trendContext": "DOWNTREND",
      "expectedResult": true,
      "expectedStrength": 75
    }
  ]
}
```

---

## 8. é©—æ”¶æ¨™æº–

### 8.1 åŠŸèƒ½é©—æ”¶

- [ ] æ‰€æœ‰ K ç·šå‹æ…‹ï¼ˆ30 ç¨®ï¼‰åµæ¸¬é‚è¼¯æ­£ç¢º
- [ ] æ‰€æœ‰åœ–è¡¨å‹æ…‹ï¼ˆ15 ç¨®ï¼‰åµæ¸¬é‚è¼¯æ­£ç¢º
- [ ] è¶¨å‹¢åˆ†æçµæœæº–ç¢º
- [ ] æ”¯æ’å£“åŠ›ä½è­˜åˆ¥åˆç†
- [ ] å‹æ…‹è¨Šè™Ÿç”¢ç”Ÿæ­£ç¢º
- [ ] API å›æ‡‰æ ¼å¼ç¬¦åˆè¦æ ¼

### 8.2 å“è³ªé©—æ”¶

- [ ] å–®å…ƒæ¸¬è©¦è¦†è“‹ç‡ > 85%
- [ ] æ•´åˆæ¸¬è©¦å…¨éƒ¨é€šé
- [ ] API æ¸¬è©¦å…¨éƒ¨é€šé
- [ ] K ç·šå‹æ…‹è­˜åˆ¥æº–ç¢ºç‡ > 90%
- [ ] åœ–è¡¨å‹æ…‹è­˜åˆ¥ F1 åˆ†æ•¸ > 75%
- [ ] ç„¡ Critical/High ç­‰ç´š bug

### 8.3 æ•ˆèƒ½é©—æ”¶

- [ ] API P95 å›æ‡‰æ™‚é–“ç¬¦åˆç›®æ¨™
- [ ] æ‰¹æ¬¡è™•ç†æ™‚é–“ç¬¦åˆç›®æ¨™
- [ ] è¨˜æ†¶é«”ä½¿ç”¨åœ¨åˆç†ç¯„åœ
- [ ] ç„¡è¨˜æ†¶é«”æ´©æ¼

---

## ğŸ“š ç›¸é—œæ–‡æª”

- [M10 åŠŸèƒ½éœ€æ±‚](../functional/M10-æŠ€è¡“å‹æ…‹è¾¨è­˜åŠŸèƒ½éœ€æ±‚.md)
- [M10 APIè¦æ ¼](../api/M10-APIè¦æ ¼.md)
- [M10 æ•ˆèƒ½è€ƒé‡](./M10-æ•ˆèƒ½è€ƒé‡.md)
- [å…¨ç³»çµ±æ¸¬è©¦è¦ç¯„](./00-å…¨ç³»çµ±å¥‘ç´„.md#7-æ¸¬è©¦è¦ç¯„)

---

**æ–‡ä»¶ç¶­è­·è€…**: QA å·¥ç¨‹å¸«
**æœ€å¾Œæ›´æ–°**: 2026-01-12
**ä¸‹æ¬¡å¯©æ ¸**: 2026-03-31
