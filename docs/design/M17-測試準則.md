# M17-風險管理模組 測試準則

> **文件編號**: TEST-M17
> **模組名稱**: 風險管理模組 (Risk Management Module)
> **版本**: v1.0
> **最後更新**: 2026-01-15
> **狀態**: Draft

---

## 1. 測試策略總覽

### 1.1 測試層次

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        M17 測試金字塔                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│                           ┌───────────┐                                 │
│                           │  E2E 測試  │  5%                            │
│                           │  (UI/API) │                                 │
│                         ┌─┴───────────┴─┐                               │
│                         │   整合測試     │  20%                          │
│                         │ (DB/Service)  │                               │
│                       ┌─┴───────────────┴─┐                             │
│                       │     單元測試       │  75%                        │
│                       │ (Calculator/Engine)│                             │
│                       └───────────────────┘                             │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 測試覆蓋率目標

| 測試類型 | 覆蓋率目標 | 重點範圍 |
|---------|----------|---------|
| 單元測試 | > 85% | 計算邏輯、公式驗證 |
| 整合測試 | > 70% | 服務互動、資料流 |
| API 測試 | > 90% | 所有端點 |
| 效能測試 | 關鍵路徑 | VaR、壓力測試 |

---

## 2. 單元測試

### 2.1 VaR 計算器測試

```java
@ExtendWith(MockitoExtension.class)
class HistoricalVaRCalculatorTest {

    @InjectMocks
    private HistoricalVaRCalculator calculator;

    /**
     * TC-M17-U001: Historical VaR 基本計算
     */
    @Test
    @DisplayName("計算 95% VaR - 正常情況")
    void calculateVaR95_normalCase_shouldReturnCorrectValue() {
        // Given: 252 天歷史報酬率資料
        double[] returns = generateNormalReturns(252, 0.0, 0.02);
        double confidenceLevel = 0.95;

        // When
        VaRResult result = calculator.calculate(returns, confidenceLevel);

        // Then
        assertThat(result.getVar()).isPositive();
        assertThat(result.getConfidenceLevel()).isEqualTo(0.95);
        assertThat(result.getMethod()).isEqualTo("HISTORICAL");

        // 驗證 VaR 在合理範圍內 (約 3.3% for 2% daily vol)
        assertThat(result.getVar()).isBetween(0.025, 0.045);
    }

    /**
     * TC-M17-U002: Historical VaR 99% 信賴水準
     */
    @Test
    @DisplayName("計算 99% VaR - 應大於 95% VaR")
    void calculateVaR99_shouldBeGreaterThanVaR95() {
        // Given
        double[] returns = generateNormalReturns(252, 0.0, 0.02);

        // When
        VaRResult var95 = calculator.calculate(returns, 0.95);
        VaRResult var99 = calculator.calculate(returns, 0.99);

        // Then
        assertThat(var99.getVar()).isGreaterThan(var95.getVar());
    }

    /**
     * TC-M17-U003: CVaR (Expected Shortfall) 計算
     */
    @Test
    @DisplayName("計算 CVaR - 應大於等於 VaR")
    void calculateCVaR_shouldBeGreaterOrEqualToVaR() {
        // Given
        double[] returns = generateNormalReturns(252, 0.0, 0.02);

        // When
        VaRResult result = calculator.calculate(returns, 0.95);

        // Then
        assertThat(result.getCvar()).isGreaterThanOrEqualTo(result.getVar());
    }

    /**
     * TC-M17-U004: 資料不足的情況
     */
    @Test
    @DisplayName("歷史資料不足 - 應拋出異常")
    void calculate_insufficientData_shouldThrowException() {
        // Given: 只有 50 天資料
        double[] returns = generateNormalReturns(50, 0.0, 0.02);

        // When & Then
        assertThatThrownBy(() -> calculator.calculate(returns, 0.95))
            .isInstanceOf(InsufficientDataException.class)
            .hasMessageContaining("至少需要 100 天");
    }

    /**
     * TC-M17-U005: 已知資料集驗證
     */
    @Test
    @DisplayName("使用已知資料集驗證 VaR 計算正確性")
    void calculate_knownDataset_shouldMatchExpectedVaR() {
        // Given: 已知的測試資料集
        double[] returns = new double[] {
            0.01, -0.02, 0.015, -0.03, 0.02, -0.01, 0.005, -0.025,
            0.03, -0.015, 0.01, -0.02, 0.025, -0.01, 0.015, -0.035,
            0.02, -0.02, 0.01, -0.015
            // ... 更多資料
        };
        double expectedVaR = 0.0295; // 預先計算的期望值

        // When
        VaRResult result = calculator.calculate(returns, 0.95);

        // Then
        assertThat(result.getVar()).isCloseTo(expectedVaR, within(0.001));
    }

    private double[] generateNormalReturns(int size, double mean, double stdDev) {
        Random random = new Random(42); // 固定種子確保可重複
        return IntStream.range(0, size)
            .mapToDouble(i -> mean + stdDev * random.nextGaussian())
            .toArray();
    }
}
```

### 2.2 Parametric VaR 測試

```java
@ExtendWith(MockitoExtension.class)
class ParametricVaRCalculatorTest {

    @InjectMocks
    private ParametricVaRCalculator calculator;

    /**
     * TC-M17-U010: Parametric VaR 單資產計算
     */
    @Test
    @DisplayName("單資產 Parametric VaR 計算")
    void calculateSingleAsset_shouldMatchFormula() {
        // Given: 單一資產，日波動度 2%
        double[] weights = {1.0};
        double[][] covMatrix = {{0.0004}}; // 日變異數 = (0.02)^2
        double confidenceLevel = 0.95;

        // Expected: VaR = 1.645 * 0.02 = 0.0329
        double expectedVaR = 0.0329;

        // When
        VaRResult result = calculator.calculate(weights, covMatrix, confidenceLevel);

        // Then
        assertThat(result.getVar()).isCloseTo(expectedVaR, within(0.0005));
    }

    /**
     * TC-M17-U011: 兩資產投組 VaR (考慮相關性)
     */
    @Test
    @DisplayName("兩資產投組 - 考慮相關性")
    void calculateTwoAssets_withCorrelation_shouldReflectDiversification() {
        // Given: 兩資產各 50%，相關係數 0.5
        double[] weights = {0.5, 0.5};
        double vol1 = 0.02, vol2 = 0.03, corr = 0.5;
        double[][] covMatrix = {
            {vol1 * vol1, vol1 * vol2 * corr},
            {vol1 * vol2 * corr, vol2 * vol2}
        };

        // When
        VaRResult result = calculator.calculate(weights, covMatrix, 0.95);

        // Then: 投組 VaR 應小於簡單平均 (分散效果)
        double avgIndividualVaR = 0.5 * 1.645 * vol1 + 0.5 * 1.645 * vol2;
        assertThat(result.getVar()).isLessThan(avgIndividualVaR);
    }

    /**
     * TC-M17-U012: 完全負相關的分散效果
     */
    @Test
    @DisplayName("完全負相關資產 - 最大分散效果")
    void calculatePerfectNegativeCorrelation_shouldMinimizeVaR() {
        // Given: 兩資產完全負相關
        double[] weights = {0.5, 0.5};
        double vol = 0.02;
        double[][] covMatrix = {
            {vol * vol, -vol * vol},
            {-vol * vol, vol * vol}
        };

        // When
        VaRResult result = calculator.calculate(weights, covMatrix, 0.95);

        // Then: VaR 應接近 0
        assertThat(result.getVar()).isCloseTo(0.0, within(0.001));
    }
}
```

### 2.3 Monte Carlo VaR 測試

```java
@ExtendWith(MockitoExtension.class)
class MonteCarloVaRCalculatorTest {

    @InjectMocks
    private MonteCarloVaRCalculator calculator;

    /**
     * TC-M17-U020: Monte Carlo VaR 收斂性測試
     */
    @Test
    @DisplayName("Monte Carlo VaR - 隨模擬次數增加應收斂")
    void calculate_convergence_shouldStabilizeWithMoreSimulations() {
        // Given
        double[] weights = {0.5, 0.3, 0.2};
        double[][] covMatrix = generateRandomCovMatrix(3);

        // When: 不同模擬次數
        VaRResult result1k = calculator.calculate(weights, covMatrix, 1000, 0.95);
        VaRResult result10k = calculator.calculate(weights, covMatrix, 10000, 0.95);
        VaRResult result50k = calculator.calculate(weights, covMatrix, 50000, 0.95);

        // Then: 標準誤差應隨模擬次數減少
        assertThat(result10k.getStandardError())
            .isLessThan(result1k.getStandardError());
        assertThat(result50k.getStandardError())
            .isLessThan(result10k.getStandardError());

        // VaR 值應穩定
        assertThat(result10k.getVar())
            .isCloseTo(result50k.getVar(), within(0.005));
    }

    /**
     * TC-M17-U021: Monte Carlo vs Parametric 比較
     */
    @Test
    @DisplayName("Monte Carlo VaR 應與 Parametric VaR 接近 (常態分布)")
    void calculate_normalDistribution_shouldMatchParametric() {
        // Given: 使用常態分布，兩方法應一致
        double[] weights = {0.4, 0.6};
        double[][] covMatrix = {
            {0.0004, 0.0002},
            {0.0002, 0.0009}
        };

        // When
        VaRResult mcVar = calculator.calculate(weights, covMatrix, 50000, 0.95);
        VaRResult paramVar = parametricCalculator.calculate(weights, covMatrix, 0.95);

        // Then: 差異應在 5% 以內
        double difference = Math.abs(mcVar.getVar() - paramVar.getVar()) / paramVar.getVar();
        assertThat(difference).isLessThan(0.05);
    }
}
```

### 2.4 波動度計算測試

```java
class VolatilityCalculatorTest {

    @InjectMocks
    private VolatilityCalculator calculator;

    /**
     * TC-M17-U030: 日波動度計算
     */
    @Test
    @DisplayName("計算日波動度 - 使用標準差")
    void calculateDailyVolatility_shouldUseStdDev() {
        // Given: 已知標準差的資料
        double[] returns = {0.01, -0.02, 0.015, -0.01, 0.005};
        double expectedStdDev = calculateStdDev(returns);

        // When
        VolatilityResult result = calculator.calculateDaily(returns);

        // Then
        assertThat(result.getDailyVolatility()).isCloseTo(expectedStdDev, within(0.0001));
    }

    /**
     * TC-M17-U031: 年化波動度計算
     */
    @Test
    @DisplayName("年化波動度 = 日波動度 × √252")
    void calculateAnnualizedVolatility_shouldApplyScalingFactor() {
        // Given
        double dailyVol = 0.02;
        double expectedAnnualVol = dailyVol * Math.sqrt(252);

        // When
        double annualVol = calculator.annualize(dailyVol);

        // Then
        assertThat(annualVol).isCloseTo(expectedAnnualVol, within(0.001));
    }

    /**
     * TC-M17-U032: 下行波動度計算
     */
    @Test
    @DisplayName("下行波動度 - 僅考慮負報酬")
    void calculateDownsideVolatility_shouldOnlyUseNegativeReturns() {
        // Given
        double[] returns = {0.03, -0.02, 0.01, -0.03, 0.02, -0.01};

        // When
        VolatilityResult result = calculator.calculateDownside(returns, 0.0);

        // Then: 應只使用 -0.02, -0.03, -0.01
        double[] negativeReturns = {-0.02, -0.03, -0.01};
        double expectedDownside = calculateStdDev(negativeReturns);
        assertThat(result.getDownsideVolatility()).isCloseTo(expectedDownside, within(0.001));
    }

    /**
     * TC-M17-U033: EWMA 波動度
     */
    @Test
    @DisplayName("EWMA 波動度 - 近期資料權重更高")
    void calculateEWMAVolatility_shouldGiveMoreWeightToRecent() {
        // Given: 最近波動加劇
        double[] returns = new double[100];
        Arrays.fill(returns, 0, 80, 0.01);   // 前 80 天低波動
        Arrays.fill(returns, 80, 100, 0.03); // 後 20 天高波動

        // When
        double ewmaVol = calculator.calculateEWMA(returns, 0.94);
        double simpleVol = calculator.calculateDaily(returns).getDailyVolatility();

        // Then: EWMA 應高於簡單波動度 (近期高波動權重大)
        assertThat(ewmaVol).isGreaterThan(simpleVol);
    }
}
```

### 2.5 風險限額檢查測試

```java
class LimitCheckerTest {

    @InjectMocks
    private LimitChecker checker;

    /**
     * TC-M17-U040: 限額狀態判定 - NORMAL
     */
    @Test
    @DisplayName("使用率 < 80% - 狀態為 NORMAL")
    void checkLimit_belowWarning_shouldReturnNormal() {
        // Given
        RiskLimit limit = RiskLimit.builder()
            .limitValue(BigDecimal.valueOf(100000))
            .warningThreshold(BigDecimal.valueOf(0.80))
            .criticalThreshold(BigDecimal.valueOf(0.95))
            .build();
        BigDecimal currentValue = BigDecimal.valueOf(70000); // 70%

        // When
        LimitCheckResult result = checker.check(limit, currentValue);

        // Then
        assertThat(result.getStatus()).isEqualTo(LimitStatus.NORMAL);
        assertThat(result.getUtilization()).isEqualTo(BigDecimal.valueOf(0.70));
    }

    /**
     * TC-M17-U041: 限額狀態判定 - WARNING
     */
    @Test
    @DisplayName("使用率 80-95% - 狀態為 WARNING")
    void checkLimit_betweenWarningAndCritical_shouldReturnWarning() {
        // Given
        RiskLimit limit = createDefaultLimit();
        BigDecimal currentValue = BigDecimal.valueOf(85000); // 85%

        // When
        LimitCheckResult result = checker.check(limit, currentValue);

        // Then
        assertThat(result.getStatus()).isEqualTo(LimitStatus.WARNING);
    }

    /**
     * TC-M17-U042: 限額狀態判定 - CRITICAL
     */
    @Test
    @DisplayName("使用率 95-100% - 狀態為 CRITICAL")
    void checkLimit_betweenCriticalAndBreach_shouldReturnCritical() {
        // Given
        RiskLimit limit = createDefaultLimit();
        BigDecimal currentValue = BigDecimal.valueOf(98000); // 98%

        // When
        LimitCheckResult result = checker.check(limit, currentValue);

        // Then
        assertThat(result.getStatus()).isEqualTo(LimitStatus.CRITICAL);
    }

    /**
     * TC-M17-U043: 限額狀態判定 - BREACHED
     */
    @Test
    @DisplayName("使用率 >= 100% - 狀態為 BREACHED")
    void checkLimit_exceedLimit_shouldReturnBreached() {
        // Given
        RiskLimit limit = createDefaultLimit();
        BigDecimal currentValue = BigDecimal.valueOf(110000); // 110%

        // When
        LimitCheckResult result = checker.check(limit, currentValue);

        // Then
        assertThat(result.getStatus()).isEqualTo(LimitStatus.BREACHED);
        assertThat(result.getUtilization()).isGreaterThan(BigDecimal.ONE);
    }
}
```

### 2.6 壓力測試計算測試

```java
class StressTestCalculatorTest {

    @InjectMocks
    private StressTestCalculator calculator;

    /**
     * TC-M17-U050: 市場衝擊計算
     */
    @Test
    @DisplayName("市場衝擊 - 根據 Beta 調整")
    void calculateMarketShock_shouldAdjustByBeta() {
        // Given: 市場下跌 10%
        Shock marketShock = new Shock("MARKET", -0.10);
        Position position = Position.builder()
            .stockId("2330")
            .beta(1.25)
            .marketValue(BigDecimal.valueOf(1000000))
            .build();

        // When
        double impact = calculator.calculateImpact(position, marketShock);

        // Then: 衝擊 = -10% × 1.25 = -12.5%
        assertThat(impact).isCloseTo(-0.125, within(0.001));
    }

    /**
     * TC-M17-U051: 產業衝擊計算
     */
    @Test
    @DisplayName("產業衝擊 - 只影響該產業股票")
    void calculateSectorShock_shouldOnlyAffectSector() {
        // Given
        Shock sectorShock = new Shock("SECTOR_ELECTRONIC", -0.20);

        Position techStock = Position.builder()
            .stockId("2330")
            .sector("ELECTRONIC")
            .marketValue(BigDecimal.valueOf(1000000))
            .build();

        Position finStock = Position.builder()
            .stockId("2882")
            .sector("FINANCIAL")
            .marketValue(BigDecimal.valueOf(500000))
            .build();

        // When
        double techImpact = calculator.calculateImpact(techStock, sectorShock);
        double finImpact = calculator.calculateImpact(finStock, sectorShock);

        // Then
        assertThat(techImpact).isCloseTo(-0.20, within(0.001));
        assertThat(finImpact).isEqualTo(0.0); // 不受影響
    }

    /**
     * TC-M17-U052: 複合衝擊計算
     */
    @Test
    @DisplayName("複合衝擊 - 疊加多個因子")
    void calculateMultipleShocks_shouldSum() {
        // Given: 市場 -10% + 電子產業 -15%
        List<Shock> shocks = List.of(
            new Shock("MARKET", -0.10),
            new Shock("SECTOR_ELECTRONIC", -0.15)
        );

        Position position = Position.builder()
            .stockId("2330")
            .sector("ELECTRONIC")
            .beta(1.2)
            .build();

        // When
        double totalImpact = calculator.calculateTotalImpact(position, shocks);

        // Then: -10% × 1.2 + -15% = -27%
        assertThat(totalImpact).isCloseTo(-0.27, within(0.01));
    }

    /**
     * TC-M17-U053: 投組衝擊彙總
     */
    @Test
    @DisplayName("投組衝擊 - 加權平均")
    void calculatePortfolioImpact_shouldWeightedSum() {
        // Given
        Shock marketShock = new Shock("MARKET", -0.10);
        List<Position> positions = List.of(
            Position.builder().stockId("2330").beta(1.2).weight(0.6).build(),
            Position.builder().stockId("2882").beta(0.8).weight(0.4).build()
        );

        // When
        double portfolioImpact = calculator.calculatePortfolioImpact(positions, List.of(marketShock));

        // Then: 0.6 × (-10% × 1.2) + 0.4 × (-10% × 0.8) = -10.4%
        assertThat(portfolioImpact).isCloseTo(-0.104, within(0.001));
    }
}
```

---

## 3. 整合測試

### 3.1 Service 層整合測試

```java
@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.properties")
@Transactional
class RiskServiceIntegrationTest {

    @Autowired
    private RiskService riskService;

    @Autowired
    private RiskSnapshotRepository snapshotRepository;

    @Autowired
    private TestDataSetup testDataSetup;

    @BeforeEach
    void setUp() {
        testDataSetup.createTestPortfolio("PF_TEST_001");
        testDataSetup.createHistoricalPrices(252);
    }

    /**
     * TC-M17-I001: 完整風險計算流程
     */
    @Test
    @DisplayName("每日風險計算 - 完整流程")
    void calculateDailyRisk_fullFlow_shouldCreateSnapshot() {
        // Given
        String portfolioId = "PF_TEST_001";
        LocalDate today = LocalDate.now();

        // When
        RiskCalculationResult result = riskService.calculateDailyRisk(portfolioId, today);

        // Then
        assertThat(result.isSuccess()).isTrue();

        RiskSnapshot snapshot = snapshotRepository.findLatest(portfolioId, today);
        assertThat(snapshot).isNotNull();
        assertThat(snapshot.getVar95Daily()).isPositive();
        assertThat(snapshot.getVolatilityAnnualized()).isPositive();
        assertThat(snapshot.getBeta()).isBetween(BigDecimal.ZERO, BigDecimal.valueOf(3));
        assertThat(snapshot.getRiskLevel()).isIn("LOW", "MEDIUM", "MEDIUM_HIGH", "HIGH");
    }

    /**
     * TC-M17-I002: 限額檢查觸發預警
     */
    @Test
    @DisplayName("限額超過警告閾值 - 應觸發預警")
    void checkLimit_exceedWarning_shouldTriggerAlert() {
        // Given
        String portfolioId = "PF_TEST_001";
        testDataSetup.createRiskLimit(portfolioId, "VAR_95", 50000, 0.80, 0.95);
        testDataSetup.createRiskSnapshot(portfolioId, 45000); // 90% 使用率

        // When
        List<LimitCheckResult> results = riskService.checkAllLimits(portfolioId, LocalDate.now());

        // Then
        assertThat(results).hasSize(1);
        assertThat(results.get(0).getStatus()).isEqualTo(LimitStatus.WARNING);
        assertThat(results.get(0).isAlertTriggered()).isTrue();

        // 驗證預警已建立
        List<RiskAlert> alerts = alertRepository.findActiveByPortfolio(portfolioId);
        assertThat(alerts).hasSize(1);
        assertThat(alerts.get(0).getAlertType()).isEqualTo("VAR_THRESHOLD");
    }

    /**
     * TC-M17-I003: 壓力測試完整流程
     */
    @Test
    @DisplayName("壓力測試 - 多情境執行")
    void runStressTest_multipleScenarios_shouldReturnAllResults() {
        // Given
        String portfolioId = "PF_TEST_001";
        List<String> scenarios = List.of("MARKET_CRASH_2008", "COVID_2020");

        // When
        StressTestResult result = riskService.runStressTest(portfolioId, scenarios);

        // Then
        assertThat(result.getScenarioResults()).hasSize(2);
        assertThat(result.getWorstCaseScenario()).isNotBlank();
        assertThat(result.getWorstCaseLoss()).isNegative();
    }
}
```

### 3.2 Repository 整合測試

```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = Replace.NONE)
@TestPropertySource(locations = "classpath:application-test.properties")
class RiskSnapshotRepositoryTest {

    @Autowired
    private RiskSnapshotRepository repository;

    @Autowired
    private TestEntityManager entityManager;

    /**
     * TC-M17-I010: 查詢最新快照
     */
    @Test
    @DisplayName("findLatest - 應返回最新日期的快照")
    void findLatest_shouldReturnMostRecentSnapshot() {
        // Given
        String portfolioId = "PF_001";
        createSnapshot(portfolioId, LocalDate.now().minusDays(2));
        createSnapshot(portfolioId, LocalDate.now().minusDays(1));
        RiskSnapshot latest = createSnapshot(portfolioId, LocalDate.now());

        entityManager.flush();

        // When
        RiskSnapshot result = repository.findLatest(portfolioId, LocalDate.now());

        // Then
        assertThat(result.getSnapshotDate()).isEqualTo(LocalDate.now());
        assertThat(result.getId()).isEqualTo(latest.getId());
    }

    /**
     * TC-M17-I011: 歷史資料查詢
     */
    @Test
    @DisplayName("findHistory - 應返回指定期間資料")
    void findHistory_shouldReturnDataInPeriod() {
        // Given
        String portfolioId = "PF_001";
        LocalDate startDate = LocalDate.now().minusDays(30);

        for (int i = 0; i <= 30; i++) {
            createSnapshot(portfolioId, startDate.plusDays(i));
        }
        entityManager.flush();

        // When
        List<RiskSnapshot> results = repository.findHistory(
            portfolioId, startDate, LocalDate.now(), "DAILY");

        // Then
        assertThat(results).hasSize(31);
        assertThat(results.get(0).getSnapshotDate()).isEqualTo(startDate);
        assertThat(results.get(30).getSnapshotDate()).isEqualTo(LocalDate.now());
    }
}
```

---

## 4. API 測試

### 4.1 REST API 測試

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class RiskApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    /**
     * TC-M17-A001: 取得風險概覽
     */
    @Test
    @DisplayName("GET /portfolios/{id}/risk - 成功")
    void getRiskOverview_success_shouldReturn200() throws Exception {
        mockMvc.perform(get("/api/v1/risk/portfolios/PF_001/risk")
                .header("Authorization", "Bearer " + getTestToken())
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.data.portfolioId").value("PF_001"))
            .andExpect(jsonPath("$.data.riskSummary.riskLevel").exists())
            .andExpect(jsonPath("$.data.keyMetrics.var95Daily").isNumber());
    }

    /**
     * TC-M17-A002: 投組不存在
     */
    @Test
    @DisplayName("GET /portfolios/{id}/risk - 投組不存在")
    void getRiskOverview_portfolioNotFound_shouldReturn404() throws Exception {
        mockMvc.perform(get("/api/v1/risk/portfolios/NOT_EXIST/risk")
                .header("Authorization", "Bearer " + getTestToken()))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.error.errorCode").value("M17-001"));
    }

    /**
     * TC-M17-A003: VaR 計算
     */
    @Test
    @DisplayName("GET /portfolios/{id}/var - 不同方法")
    void getVaR_differentMethods_shouldReturnCorrectResults() throws Exception {
        // Historical
        mockMvc.perform(get("/api/v1/risk/portfolios/PF_001/var")
                .param("method", "HISTORICAL")
                .param("confidenceLevel", "0.95")
                .header("Authorization", "Bearer " + getTestToken()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.varResult.method").value("HISTORICAL"));

        // Parametric
        mockMvc.perform(get("/api/v1/risk/portfolios/PF_001/var")
                .param("method", "PARAMETRIC")
                .header("Authorization", "Bearer " + getTestToken()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.varResult.method").value("PARAMETRIC"));
    }

    /**
     * TC-M17-A010: 建立風險限額
     */
    @Test
    @DisplayName("POST /limits - 建立限額")
    void createLimit_validRequest_shouldReturn201() throws Exception {
        CreateLimitRequest request = CreateLimitRequest.builder()
            .portfolioId("PF_001")
            .limitType("VAR_95")
            .limitValue(BigDecimal.valueOf(150000))
            .warningThreshold(BigDecimal.valueOf(0.80))
            .criticalThreshold(BigDecimal.valueOf(0.95))
            .build();

        mockMvc.perform(post("/api/v1/risk/limits")
                .header("Authorization", "Bearer " + getTestToken())
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.data.limitId").exists())
            .andExpect(jsonPath("$.data.limitType").value("VAR_95"));
    }

    /**
     * TC-M17-A020: 執行壓力測試
     */
    @Test
    @DisplayName("POST /stress-test - 執行壓力測試")
    void runStressTest_validRequest_shouldReturn200() throws Exception {
        StressTestRequest request = StressTestRequest.builder()
            .portfolioId("PF_001")
            .scenarios(List.of("MARKET_CRASH_2008", "COVID_2020"))
            .includeHistoricalWorst(true)
            .build();

        mockMvc.perform(post("/api/v1/risk/stress-test")
                .header("Authorization", "Bearer " + getTestToken())
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.scenarioResults").isArray())
            .andExpect(jsonPath("$.data.summary.scenariosTested").value(2));
    }
}
```

---

## 5. 效能測試

### 5.1 VaR 計算效能測試

```java
@SpringBootTest
@Tag("performance")
class VaRPerformanceTest {

    @Autowired
    private VaRCalculationService varService;

    /**
     * TC-M17-P001: Historical VaR 效能
     */
    @Test
    @DisplayName("Historical VaR - 20 檔股票應在 5 秒內完成")
    void historicalVaR_20Stocks_shouldCompleteWithin5Seconds() {
        // Given
        String portfolioId = "PF_PERF_001";
        setupPortfolioWith20Stocks(portfolioId);

        // When
        long startTime = System.currentTimeMillis();
        VaRResult result = varService.calculate(portfolioId, "HISTORICAL", 0.95, 1);
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(5000);
        assertThat(result.isSuccess()).isTrue();
    }

    /**
     * TC-M17-P002: Monte Carlo VaR 效能
     */
    @Test
    @DisplayName("Monte Carlo VaR - 10000 次模擬應在 30 秒內")
    void monteCarloVaR_10000Simulations_shouldCompleteWithin30Seconds() {
        // Given
        String portfolioId = "PF_PERF_001";

        // When
        long startTime = System.currentTimeMillis();
        VaRResult result = varService.calculate(portfolioId, "MONTE_CARLO", 0.95, 1, 10000);
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(30000);
    }

    /**
     * TC-M17-P003: 批次風險計算效能
     */
    @Test
    @DisplayName("批次計算 - 100 個投組應在 5 分鐘內")
    void batchCalculation_100Portfolios_shouldCompleteWithin5Minutes() {
        // Given
        List<String> portfolioIds = IntStream.range(0, 100)
            .mapToObj(i -> "PF_BATCH_" + i)
            .collect(Collectors.toList());

        portfolioIds.forEach(this::setupPortfolio);

        // When
        long startTime = System.currentTimeMillis();
        List<RiskCalculationResult> results = varService.calculateBatch(portfolioIds, LocalDate.now());
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(300000); // 5 分鐘
        assertThat(results.stream().filter(RiskCalculationResult::isSuccess).count())
            .isGreaterThan(95); // 95% 成功率
    }
}
```

### 5.2 壓力測試效能

```java
@SpringBootTest
@Tag("performance")
class StressTestPerformanceTest {

    /**
     * TC-M17-P010: 壓力測試效能
     */
    @Test
    @DisplayName("10 個情境壓力測試應在 60 秒內")
    void stressTest_10Scenarios_shouldCompleteWithin60Seconds() {
        // Given
        String portfolioId = "PF_STRESS_001";
        List<String> scenarios = List.of(
            "MARKET_CRASH_2008", "COVID_2020", "RATE_HIKE",
            "CURRENCY_CRISIS", "TECH_CRASH", "BLACK_SWAN",
            "CUSTOM_1", "CUSTOM_2", "CUSTOM_3", "CUSTOM_4"
        );

        // When
        long startTime = System.currentTimeMillis();
        StressTestResult result = stressTestService.run(portfolioId, scenarios);
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(60000);
        assertThat(result.getScenarioResults()).hasSize(10);
    }
}
```

---

## 6. 測試資料管理

### 6.1 測試資料集

```java
@Component
public class RiskTestDataSetup {

    /**
     * 建立標準測試投組
     */
    public Portfolio createTestPortfolio(String portfolioId) {
        Portfolio portfolio = Portfolio.builder()
            .portfolioId(portfolioId)
            .portfolioName("測試投組 " + portfolioId)
            .totalValue(BigDecimal.valueOf(5000000))
            .positions(createTestPositions())
            .build();

        return portfolioRepository.save(portfolio);
    }

    /**
     * 建立標準持倉
     */
    private List<Position> createTestPositions() {
        return List.of(
            Position.builder().stockId("2330").stockName("台積電")
                .shares(5000).avgCost(550).weight(0.25).beta(1.2).sector("ELECTRONIC").build(),
            Position.builder().stockId("2317").stockName("鴻海")
                .shares(10000).avgCost(105).weight(0.15).beta(1.1).sector("ELECTRONIC").build(),
            Position.builder().stockId("2882").stockName("國泰金")
                .shares(20000).avgCost(45).weight(0.12).beta(0.9).sector("FINANCIAL").build(),
            Position.builder().stockId("2454").stockName("聯發科")
                .shares(2000).avgCost(750).weight(0.18).beta(1.3).sector("ELECTRONIC").build(),
            Position.builder().stockId("2412").stockName("中華電")
                .shares(8000).avgCost(120).weight(0.10).beta(0.6).sector("TELECOM").build()
        );
    }

    /**
     * 建立歷史價格資料
     */
    public void createHistoricalPrices(int days) {
        List<String> stockIds = List.of("2330", "2317", "2882", "2454", "2412");
        LocalDate today = LocalDate.now();

        for (String stockId : stockIds) {
            for (int i = days; i >= 0; i--) {
                LocalDate date = today.minusDays(i);
                double price = generatePrice(stockId, i);
                double returnRate = i == days ? 0 : (price - generatePrice(stockId, i + 1)) / generatePrice(stockId, i + 1);

                StockDailyPrice priceData = StockDailyPrice.builder()
                    .stockId(stockId)
                    .tradeDate(date)
                    .closePrice(BigDecimal.valueOf(price))
                    .dailyReturn(BigDecimal.valueOf(returnRate))
                    .build();

                priceRepository.save(priceData);
            }
        }
    }
}
```

---

## 7. 測試執行

### 7.1 執行命令

```bash
# 執行所有 M17 測試
./mvnw test -Dtest="**/m17/**/*Test"

# 只執行單元測試
./mvnw test -Dtest="**/m17/**/*Test" -DexcludedGroups="integration,performance"

# 只執行整合測試
./mvnw test -Dtest="**/m17/**/*IntegrationTest"

# 執行效能測試
./mvnw test -Dtest="**/m17/**/*PerformanceTest" -Dgroups="performance"

# 產生覆蓋率報告
./mvnw test jacoco:report -Dtest="**/m17/**/*Test"
```

### 7.2 CI/CD 整合

```yaml
# .github/workflows/test.yml
jobs:
  test-m17:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run Unit Tests
        run: ./mvnw test -Dtest="**/m17/**/*Test" -DexcludedGroups="integration,performance"

      - name: Run Integration Tests
        run: ./mvnw test -Dtest="**/m17/**/*IntegrationTest"

      - name: Upload Coverage
        uses: codecov/codecov-action@v3
        with:
          files: target/site/jacoco/jacoco.xml
          flags: m17
```

---

## 8. 相關文檔

- [M17 功能需求](../specs/functional/M17-風險管理功能需求.md)
- [M17 API 規格](../specs/api/M17-API規格.md)
- [M17 業務流程](./M17-業務流程.md)

---

**文件維護者**: 測試工程師
**最後更新**: 2026-01-15
**下次審核**: 2026-04-15
