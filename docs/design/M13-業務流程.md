# M13-信號判斷引擎 業務流程

> **文件編號**: FLOW-M13
> **模組名稱**: 信號判斷引擎 (Signal Judgment Engine)
> **版本**: v1.0
> **最後更新**: 2026-01-14
> **狀態**: Draft

---

## 1. 核心業務流程

### 1.1 每日信號處理主流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          每日信號處理主流程                                    │
│                     (Daily Signal Processing Pipeline)                       │
└─────────────────────────────────────────────────────────────────────────────┘

  17:00                 17:05                 17:15                 17:25
    │                     │                     │                     │
    ▼                     ▼                     ▼                     ▼
┌─────────┐         ┌─────────┐         ┌─────────┐         ┌─────────┐
│  信號   │         │  信號   │         │  信號   │         │  信號   │
│  收集   │────────▶│  去重   │────────▶│  合併   │────────▶│  評分   │
│         │         │         │         │         │         │         │
└─────────┘         └─────────┘         └─────────┘         └─────────┘
    │                     │                     │                     │
    │ 收集 6 個模組      │ 去除重複            │ 同股票合併          │ 5 維度評分
    │ 約 500-800 信號    │ 約減少 25%          │ 產生統一信號        │ 評級分類
    │                     │                     │                     │
                                                                       │
                              17:30                                    │
                                │                                      │
                                ▼                                      │
                          ┌─────────┐                                  │
                          │  信號   │◀─────────────────────────────────┘
                          │  發布   │
                          │         │
                          └─────────┘
                                │
                                │ 產生推薦清單
                                │ 通知下游模組
                                │
                                ▼
                    ┌─────────────────────┐
                    │   下游模組消費       │
                    │ M14/M15/M16/M17/M18 │
                    └─────────────────────┘
```

---

## 2. 信號收集流程

### 2.1 收集流程演算法

```python
class SignalCollector:
    """信號收集器"""

    def __init__(self):
        self.source_modules = ['M07', 'M08', 'M09', 'M10', 'M11', 'M12']
        self.source_tables = {
            'M07': 'technical_signals',
            'M08': 'fundamental_signals',
            'M09': 'chip_signals',
            'M10': 'pattern_signals',
            'M11': 'strategy_signals',
            'M12': 'industry_signals'
        }

    def collect_daily_signals(self, trade_date: date) -> CollectionResult:
        """每日信號收集主流程"""

        # 1. 建立批次記錄
        batch = self.create_batch(trade_date, 'DAILY_FULL')
        batch.status = 'COLLECTING'
        batch.collection_started_at = now()

        collected_signals = []
        collection_summary = {}

        try:
            # 2. 依序從各模組收集
            for module in self.source_modules:
                module_signals = self.collect_from_module(
                    module=module,
                    trade_date=trade_date,
                    batch_id=batch.batch_id
                )

                # 3. 轉換為統一格式
                unified_format_signals = self.transform_to_unified_format(
                    signals=module_signals,
                    source_module=module
                )

                # 4. 冪等性檢查
                new_signals = self.filter_already_collected(unified_format_signals)

                collected_signals.extend(new_signals)

                collection_summary[module] = {
                    'collected': len(module_signals),
                    'new': len(new_signals),
                    'duplicated': len(module_signals) - len(new_signals)
                }

            # 5. 批次儲存原始信號
            self.batch_save_raw_signals(collected_signals)

            # 6. 更新批次狀態
            batch.raw_signals_collected = len(collected_signals)
            batch.collection_completed_at = now()

            return CollectionResult(
                success=True,
                batch_id=batch.batch_id,
                total_collected=len(collected_signals),
                summary=collection_summary
            )

        except Exception as e:
            batch.status = 'FAILED'
            batch.error_message = str(e)
            raise

    def collect_from_module(self, module: str, trade_date: date, batch_id: str) -> List:
        """從指定模組收集信號"""

        table = self.source_tables[module]

        # 查詢當日未消費的信號
        query = f"""
            SELECT *
            FROM {table}
            WHERE signal_date = :trade_date
              AND is_collected = FALSE
            ORDER BY confidence DESC
        """

        signals = self.db.execute(query, {'trade_date': trade_date})

        # 標記已收集
        self.mark_as_collected(table, [s.id for s in signals])

        return signals

    def transform_to_unified_format(self, signals: List, source_module: str) -> List[RawSignal]:
        """轉換為統一格式"""

        unified = []
        for signal in signals:
            raw_signal = RawSignal(
                raw_signal_id=self.generate_raw_signal_id(signal, source_module),
                source_signal_id=signal.signal_id,
                source_module=source_module,
                signal_type=self.map_signal_type(source_module),
                signal_code=signal.signal_code,
                signal_name=signal.signal_name,
                stock_id=signal.stock_id,
                signal_date=signal.signal_date,
                signal_direction=signal.direction,
                source_confidence=signal.confidence,
                signal_metadata=self.extract_metadata(signal),
                dedup_status='PENDING',
                collected_at=now()
            )
            unified.append(raw_signal)

        return unified

    def map_signal_type(self, module: str) -> str:
        """模組對應信號類型"""
        mapping = {
            'M07': 'TECHNICAL',
            'M08': 'FUNDAMENTAL',
            'M09': 'CHIP',
            'M10': 'PATTERN',
            'M11': 'STRATEGY',
            'M12': 'INDUSTRY'
        }
        return mapping[module]
```

### 2.2 收集流程圖

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            信號收集流程                                       │
└─────────────────────────────────────────────────────────────────────────────┘

                              開始
                                │
                                ▼
                    ┌─────────────────────┐
                    │   建立批次記錄       │
                    │   BatchType: DAILY   │
                    └─────────────────────┘
                                │
                                ▼
              ┌─────────────────────────────────────┐
              │         遍歷 6 個上游模組            │
              │     M07 → M08 → M09 → M10 →        │
              │          M11 → M12                  │
              └─────────────────────────────────────┘
                                │
                    ┌───────────┴───────────┐
                    ▼                       ▼
          ┌─────────────────┐     ┌─────────────────┐
          │  查詢模組當日    │     │  查詢模組當日    │
          │  未收集信號      │     │  未收集信號      │
          │  (M07)          │     │  (M08-M12)      │
          └─────────────────┘     └─────────────────┘
                    │                       │
                    ▼                       ▼
          ┌─────────────────┐     ┌─────────────────┐
          │  轉換統一格式    │     │  轉換統一格式    │
          │  RawSignal      │     │  RawSignal      │
          └─────────────────┘     └─────────────────┘
                    │                       │
                    └───────────┬───────────┘
                                │
                                ▼
                    ┌─────────────────────┐
                    │   冪等性過濾         │
                    │   (排除已收集信號)   │
                    └─────────────────────┘
                                │
                                ▼
                    ┌─────────────────────┐
                    │   批次寫入          │
                    │   raw_signals 表    │
                    └─────────────────────┘
                                │
                                ▼
                    ┌─────────────────────┐
                    │   更新批次統計       │
                    │   回傳收集結果       │
                    └─────────────────────┘
                                │
                                ▼
                              結束
```

---

## 3. 信號去重流程

### 3.1 去重演算法

```python
class SignalDeduplicator:
    """信號去重器"""

    def __init__(self):
        self.semantic_groups = self.load_semantic_groups()
        self.temporal_window_days = 3

    def deduplicate(self, batch_id: str, trade_date: date) -> DedupResult:
        """信號去重主流程"""

        # 載入待處理的原始信號
        raw_signals = self.load_pending_signals(batch_id, trade_date)

        # 按股票分組
        signals_by_stock = self.group_by_stock(raw_signals)

        dedup_logs = []
        deduplicated_signals = []

        for stock_id, signals in signals_by_stock.items():
            # 階段 1: 完全重複去除
            step1_signals, step1_logs = self.remove_exact_duplicates(
                signals, stock_id, batch_id
            )

            # 階段 2: 語義重複合併
            step2_signals, step2_logs = self.merge_semantic_duplicates(
                step1_signals, stock_id, batch_id
            )

            # 階段 3: 時間窗口去重
            step3_signals, step3_logs = self.remove_temporal_duplicates(
                step2_signals, stock_id, batch_id, trade_date
            )

            deduplicated_signals.extend(step3_signals)
            dedup_logs.extend(step1_logs + step2_logs + step3_logs)

        # 儲存去重記錄
        self.save_dedup_logs(dedup_logs)

        # 更新原始信號的去重狀態
        self.update_dedup_status(deduplicated_signals)

        return DedupResult(
            before_count=len(raw_signals),
            after_count=len(deduplicated_signals),
            dedup_rate=(len(raw_signals) - len(deduplicated_signals)) / len(raw_signals)
        )

    def remove_exact_duplicates(
        self, signals: List, stock_id: str, batch_id: str
    ) -> Tuple[List, List]:
        """完全重複去除"""

        # 以 (stock_id, signal_code, signal_date) 為 key
        grouped = {}
        for signal in signals:
            key = (signal.stock_id, signal.signal_code, signal.signal_date)
            if key not in grouped:
                grouped[key] = []
            grouped[key].append(signal)

        result_signals = []
        logs = []

        for key, group in grouped.items():
            if len(group) == 1:
                signal = group[0]
                signal.dedup_status = 'KEPT'
                result_signals.append(signal)
            else:
                # 保留信心度最高者
                best = max(group, key=lambda s: s.source_confidence or 0)
                best.dedup_status = 'KEPT'
                result_signals.append(best)

                # 記錄去重日誌
                logs.append(SignalDedupLog(
                    batch_id=batch_id,
                    trade_date=group[0].signal_date,
                    stock_id=stock_id,
                    dedup_type='EXACT_DUPLICATE',
                    original_signal_ids=','.join([s.raw_signal_id for s in group]),
                    result_action='KEEP_ONE',
                    kept_signal_id=best.raw_signal_id,
                    removed_signal_ids=','.join([
                        s.raw_signal_id for s in group if s != best
                    ])
                ))

                # 標記其他為已移除
                for signal in group:
                    if signal != best:
                        signal.dedup_status = 'REMOVED'

        return result_signals, logs

    def merge_semantic_duplicates(
        self, signals: List, stock_id: str, batch_id: str
    ) -> Tuple[List, List]:
        """語義重複合併"""

        logs = []
        result_signals = []
        processed_ids = set()

        for signal in signals:
            if signal.raw_signal_id in processed_ids:
                continue

            # 查找該信號所屬的語義群組
            semantic_group = self.find_semantic_group(signal.signal_code)

            if semantic_group is None:
                # 無語義群組，直接保留
                result_signals.append(signal)
                processed_ids.add(signal.raw_signal_id)
                continue

            # 找出同群組的其他信號
            group_codes = set(semantic_group.signal_codes)
            related_signals = [
                s for s in signals
                if s.signal_code in group_codes and s.raw_signal_id not in processed_ids
            ]

            if len(related_signals) <= 1:
                result_signals.append(signal)
                processed_ids.add(signal.raw_signal_id)
                continue

            # 合併語義相關信號
            merged_signal = self.merge_signals(
                related_signals, semantic_group.merge_strategy
            )
            result_signals.append(merged_signal)

            # 記錄合併日誌
            logs.append(SignalDedupLog(
                batch_id=batch_id,
                trade_date=signal.signal_date,
                stock_id=stock_id,
                dedup_type='SEMANTIC_DUPLICATE',
                original_signal_ids=','.join([s.raw_signal_id for s in related_signals]),
                result_action='MERGE',
                kept_signal_id=merged_signal.raw_signal_id,
                merge_reason=f'Merged by {semantic_group.group_code}'
            ))

            for s in related_signals:
                s.dedup_status = 'MERGED'
                processed_ids.add(s.raw_signal_id)

        return result_signals, logs

    def find_semantic_group(self, signal_code: str):
        """查找信號代碼對應的語義群組"""
        for group in self.semantic_groups:
            if signal_code in group.signal_codes:
                return group
        return None

    def merge_signals(self, signals: List, strategy: str):
        """合併多個信號"""

        if strategy == 'HIGHEST_CONFIDENCE':
            return max(signals, key=lambda s: s.source_confidence or 0)
        elif strategy == 'AVERAGE':
            avg_confidence = sum(s.source_confidence or 0 for s in signals) / len(signals)
            merged = signals[0].copy()
            merged.source_confidence = avg_confidence
            merged.signal_name = f"合併信號 ({len(signals)} 個來源)"
            return merged
        elif strategy == 'LATEST':
            return max(signals, key=lambda s: s.collected_at)

        return signals[0]
```

### 3.2 去重決策樹

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            去重決策樹                                         │
└─────────────────────────────────────────────────────────────────────────────┘

輸入: 同股票的原始信號列表
                                │
                                ▼
                    ┌─────────────────────┐
                    │  是否有完全重複?    │
                    │ (同代碼 + 同日期)   │
                    └─────────────────────┘
                          │         │
                         Yes        No
                          │         │
                          ▼         │
             ┌────────────────────┐ │
             │ 保留信心度最高者   │ │
             │ 標記其他為 REMOVED │ │
             └────────────────────┘ │
                          │         │
                          └────┬────┘
                               ▼
                    ┌─────────────────────┐
                    │  是否屬於語義群組?  │
                    │ (超買/超賣/交叉等)  │
                    └─────────────────────┘
                          │         │
                         Yes        No
                          │         │
                          ▼         │
             ┌────────────────────┐ │
             │ 找出同群組信號     │ │
             │ 依策略合併         │ │
             │ 標記為 MERGED      │ │
             └────────────────────┘ │
                          │         │
                          └────┬────┘
                               ▼
                    ┌─────────────────────┐
                    │  3日內是否有重複?   │
                    │ (同代碼,不同日期)   │
                    └─────────────────────┘
                          │         │
                         Yes        No
                          │         │
                          ▼         │
             ┌────────────────────┐ │
             │ 僅保留最新者       │ │
             │ 標記舊的為 REMOVED │ │
             └────────────────────┘ │
                          │         │
                          └────┬────┘
                               ▼
                    ┌─────────────────────┐
                    │   輸出: 去重後信號   │
                    │   狀態: KEPT/MERGED │
                    └─────────────────────┘
```

---

## 4. 信號合併流程

### 4.1 合併演算法

```python
class SignalMerger:
    """信號合併器"""

    # 維度權重
    DIMENSION_WEIGHTS = {
        'M07': 0.20,  # 技術分析
        'M08': 0.20,  # 基本面
        'M09': 0.20,  # 籌碼
        'M10': 0.15,  # 型態
        'M11': 0.15,  # 策略
        'M12': 0.10   # 產業
    }

    def merge_signals(self, batch_id: str, trade_date: date) -> MergeResult:
        """信號合併主流程"""

        # 載入去重後的信號
        deduplicated_signals = self.load_deduplicated_signals(batch_id, trade_date)

        # 按股票分組
        signals_by_stock = self.group_by_stock(deduplicated_signals)

        unified_signals = []
        contributors_list = []

        for stock_id, signals in signals_by_stock.items():
            # 建立統一信號
            unified = self.create_unified_signal(
                stock_id=stock_id,
                signals=signals,
                trade_date=trade_date,
                batch_id=batch_id
            )

            unified_signals.append(unified)

            # 建立組成明細
            contributors = self.create_contributors(unified, signals)
            contributors_list.extend(contributors)

        # 批次儲存
        self.batch_save_unified_signals(unified_signals)
        self.batch_save_contributors(contributors_list)

        return MergeResult(
            unified_count=len(unified_signals),
            contributors_count=len(contributors_list)
        )

    def create_unified_signal(
        self, stock_id: str, signals: List, trade_date: date, batch_id: str
    ) -> UnifiedSignal:
        """建立統一信號"""

        # 1. 計算方向一致性
        direction_result = self.calculate_direction(signals)

        # 2. 計算維度覆蓋
        dimension_coverage = self.calculate_dimension_coverage(signals)

        # 3. 計算統一信心度
        unified_confidence = self.calculate_unified_confidence(signals)

        # 4. 提取關鍵因素
        key_factors = self.extract_key_factors(signals)

        # 5. 收集信號類型標籤
        signal_types = self.collect_signal_types(signals)

        # 6. 收集來源模組
        source_modules = list(set(s.source_module for s in signals))

        unified = UnifiedSignal(
            signal_id=self.generate_unified_signal_id(stock_id, trade_date),
            stock_id=stock_id,
            stock_name=self.get_stock_name(stock_id),
            sector_code=self.get_sector_code(stock_id),
            trade_date=trade_date,
            unified_direction=direction_result.direction,
            direction_strength=direction_result.strength,
            unified_confidence=unified_confidence,
            dimension_coverage=dimension_coverage,
            signal_types=','.join(signal_types),
            key_factors='; '.join(key_factors),
            source_modules=','.join(source_modules),
            contributing_count=len(signals),
            batch_id=batch_id
        )

        return unified

    def calculate_direction(self, signals: List) -> DirectionResult:
        """計算方向一致性"""

        buy_count = sum(1 for s in signals if s.signal_direction == 'BUY')
        sell_count = sum(1 for s in signals if s.signal_direction == 'SELL')
        hold_count = len(signals) - buy_count - sell_count

        # 方向判斷
        if buy_count >= 3 and sell_count == 0:
            direction, strength = 'BUY', 'STRONG'
        elif buy_count == 2 and sell_count <= 1:
            direction, strength = 'BUY', 'MODERATE'
        elif buy_count == 1 and sell_count == 0:
            direction, strength = 'BUY', 'WEAK'
        elif sell_count >= 3 and buy_count == 0:
            direction, strength = 'SELL', 'STRONG'
        elif sell_count == 2 and buy_count <= 1:
            direction, strength = 'SELL', 'MODERATE'
        elif sell_count == 1 and buy_count == 0:
            direction, strength = 'SELL', 'WEAK'
        elif buy_count >= 2 and sell_count >= 2:
            direction, strength = 'HOLD', 'CONFLICT'
        else:
            direction, strength = 'HOLD', 'WEAK'

        return DirectionResult(
            direction=direction,
            strength=strength,
            buy_count=buy_count,
            sell_count=sell_count
        )

    def calculate_dimension_coverage(self, signals: List) -> int:
        """計算維度覆蓋數"""
        modules = set(s.source_module for s in signals)
        return len(modules)

    def calculate_unified_confidence(self, signals: List) -> float:
        """計算加權統一信心度"""

        total_weight = 0
        weighted_confidence = 0

        for signal in signals:
            weight = self.DIMENSION_WEIGHTS.get(signal.source_module, 0.10)
            confidence = signal.source_confidence or 0.5
            weighted_confidence += weight * confidence
            total_weight += weight

        if total_weight == 0:
            return 0.5

        return weighted_confidence / total_weight

    def extract_key_factors(self, signals: List) -> List[str]:
        """提取關鍵因素"""

        # 按信心度排序，取前 3 個
        sorted_signals = sorted(
            signals,
            key=lambda s: s.source_confidence or 0,
            reverse=True
        )

        key_factors = []
        for signal in sorted_signals[:3]:
            factor = signal.signal_name
            if signal.signal_metadata:
                # 添加關鍵數值
                if 'value' in signal.signal_metadata:
                    factor += f" ({signal.signal_metadata['value']})"
            key_factors.append(factor)

        return key_factors

    def collect_signal_types(self, signals: List) -> List[str]:
        """收集信號類型標籤"""

        type_mapping = {
            'RSI_OVERSOLD': 'MOMENTUM',
            'MACD_GOLDEN_CROSS': 'MOMENTUM',
            'PE_LOW': 'VALUE',
            'ROE_HIGH': 'VALUE',
            'FOREIGN_BUY': 'INSTITUTIONAL',
            'TRUST_BUY': 'INSTITUTIONAL',
            'HEAD_SHOULDERS': 'PATTERN',
            'DOUBLE_BOTTOM': 'PATTERN',
            'SECTOR_ROTATION': 'SECTOR',
            'STRATEGY_TRIGGER': 'STRATEGY'
        }

        signal_types = set()
        for signal in signals:
            mapped_type = type_mapping.get(signal.signal_code)
            if mapped_type:
                signal_types.add(mapped_type)
            else:
                # 依來源模組推斷
                module_type = {
                    'M07': 'MOMENTUM',
                    'M08': 'VALUE',
                    'M09': 'INSTITUTIONAL',
                    'M10': 'PATTERN',
                    'M11': 'STRATEGY',
                    'M12': 'SECTOR'
                }.get(signal.source_module)
                if module_type:
                    signal_types.add(module_type)

        return list(signal_types)
```

---

## 5. 信號評分流程

### 5.1 評分演算法

```python
class SignalScorer:
    """信號評分器"""

    # 評分維度權重
    SCORING_WEIGHTS = {
        'SIGNAL_STRENGTH': 0.30,
        'DIMENSION_COVERAGE': 0.25,
        'HISTORICAL_PERFORMANCE': 0.20,
        'MARKET_ENVIRONMENT': 0.15,
        'FRESHNESS': 0.10
    }

    def score_signals(self, batch_id: str, trade_date: date) -> ScoringResult:
        """信號評分主流程"""

        # 載入統一信號
        unified_signals = self.load_unified_signals(batch_id)

        scoring_details = []

        for signal in unified_signals:
            # 計算各維度分數
            detail = self.calculate_scoring_detail(signal, trade_date)
            scoring_details.append(detail)

            # 更新統一信號評分
            signal.unified_score = detail.final_score
            signal.grade = detail.grade

        # 批次儲存評分明細
        self.batch_save_scoring_details(scoring_details)

        # 更新統一信號
        self.batch_update_unified_signals(unified_signals)

        return ScoringResult(
            scored_count=len(unified_signals),
            avg_score=sum(s.unified_score for s in unified_signals) / len(unified_signals)
        )

    def calculate_scoring_detail(
        self, signal: UnifiedSignal, trade_date: date
    ) -> SignalScoringDetail:
        """計算評分明細"""

        detail = SignalScoringDetail(unified_signal_id=signal.signal_id)

        # 1. 信號強度評分
        detail.strength_score = self.score_signal_strength(signal)
        detail.strength_weight = self.SCORING_WEIGHTS['SIGNAL_STRENGTH']
        detail.strength_weighted = detail.strength_score * detail.strength_weight

        # 2. 維度覆蓋評分
        detail.coverage_score = self.score_dimension_coverage(signal)
        detail.coverage_weight = self.SCORING_WEIGHTS['DIMENSION_COVERAGE']
        detail.coverage_weighted = detail.coverage_score * detail.coverage_weight

        # 3. 歷史績效評分
        historical_result = self.score_historical_performance(signal)
        detail.historical_score = historical_result.score
        detail.historical_weight = self.SCORING_WEIGHTS['HISTORICAL_PERFORMANCE']
        detail.historical_weighted = detail.historical_score * detail.historical_weight
        detail.historical_accuracy = historical_result.accuracy
        detail.historical_sample_count = historical_result.sample_count

        # 4. 市場環境評分
        market_result = self.score_market_environment(signal, trade_date)
        detail.market_score = market_result.score
        detail.market_weight = self.SCORING_WEIGHTS['MARKET_ENVIRONMENT']
        detail.market_weighted = detail.market_score * detail.market_weight
        detail.market_trend = market_result.trend
        detail.sector_strength = market_result.sector_strength

        # 5. 時效性評分
        freshness_result = self.score_freshness(signal, trade_date)
        detail.freshness_score = freshness_result.score
        detail.freshness_weight = self.SCORING_WEIGHTS['FRESHNESS']
        detail.freshness_weighted = detail.freshness_score * detail.freshness_weight
        detail.signal_age_hours = freshness_result.age_hours

        # 6. 計算基礎總分
        detail.base_total_score = (
            detail.strength_weighted +
            detail.coverage_weighted +
            detail.historical_weighted +
            detail.market_weighted +
            detail.freshness_weighted
        )

        # 7. 應用調整因素
        adjustment, factors = self.apply_adjustments(signal, detail.base_total_score)
        detail.adjustment_factors = factors
        detail.final_score = min(detail.base_total_score + adjustment, 100)

        # 8. 決定評級
        detail.grade = self.determine_grade(detail.final_score)

        return detail

    def score_signal_strength(self, signal: UnifiedSignal) -> float:
        """信號強度評分"""

        # 方向強度分數
        direction_scores = {
            'STRONG': 100,
            'MODERATE': 70,
            'WEAK': 40,
            'CONFLICT': 20
        }
        direction_score = direction_scores.get(signal.direction_strength, 50)

        # 信心度分數
        confidence_score = (signal.unified_confidence or 0.5) * 100

        return direction_score * 0.6 + confidence_score * 0.4

    def score_dimension_coverage(self, signal: UnifiedSignal) -> float:
        """維度覆蓋評分"""

        coverage = signal.dimension_coverage
        max_dimensions = 6

        # 基礎分數
        base_score = (coverage / max_dimensions) * 80

        # 重要維度加分
        bonus = 0
        source_modules = signal.source_modules.split(',') if signal.source_modules else []
        if 'M07' in source_modules: bonus += 5  # 技術
        if 'M09' in source_modules: bonus += 5  # 籌碼
        if 'M08' in source_modules: bonus += 5  # 基本面
        if 'M11' in source_modules: bonus += 5  # 策略

        return min(base_score + bonus, 100)

    def score_historical_performance(self, signal: UnifiedSignal):
        """歷史績效評分"""

        # 查詢類似信號組合的歷史表現
        historical_data = self.query_historical_accuracy(
            stock_id=signal.stock_id,
            direction=signal.unified_direction,
            signal_types=signal.signal_types,
            lookback_days=90
        )

        accuracy = historical_data.accuracy if historical_data else 0.5
        sample_count = historical_data.count if historical_data else 0

        if accuracy >= 0.7:
            score = 100
        elif accuracy >= 0.6:
            score = 80
        elif accuracy >= 0.5:
            score = 60
        else:
            score = 40

        return HistoricalResult(
            score=score,
            accuracy=accuracy,
            sample_count=sample_count
        )

    def score_market_environment(self, signal: UnifiedSignal, trade_date: date):
        """市場環境評分"""

        # 取得大盤趨勢
        market_trend = self.get_market_trend(trade_date)

        # 取得產業強弱
        sector_strength = self.get_sector_strength(signal.sector_code, trade_date)

        # 計算環境分數
        trend_scores = {'BULLISH': 100, 'NEUTRAL': 70, 'BEARISH': 40}
        strength_scores = {'STRONG': 100, 'NEUTRAL': 70, 'WEAK': 40}

        trend_score = trend_scores.get(market_trend, 70)
        strength_score = strength_scores.get(sector_strength, 70)

        # 方向匹配加成
        if signal.unified_direction == 'BUY' and market_trend == 'BULLISH':
            bonus = 10
        elif signal.unified_direction == 'SELL' and market_trend == 'BEARISH':
            bonus = 10
        else:
            bonus = 0

        score = (trend_score * 0.6 + strength_score * 0.4) + bonus

        return MarketResult(
            score=min(score, 100),
            trend=market_trend,
            sector_strength=sector_strength
        )

    def score_freshness(self, signal: UnifiedSignal, trade_date: date):
        """時效性評分"""

        # 計算信號年齡（小時）
        age_hours = (datetime.now() - signal.created_at).total_seconds() / 3600

        if age_hours <= 6:
            score = 100
        elif age_hours <= 12:
            score = 90
        elif age_hours <= 24:
            score = 75
        elif age_hours <= 48:
            score = 50
        else:
            score = 30

        return FreshnessResult(score=score, age_hours=int(age_hours))

    def apply_adjustments(
        self, signal: UnifiedSignal, base_score: float
    ) -> Tuple[float, dict]:
        """應用調整因素"""

        adjustment = 0
        factors = {}

        # 多維度覆蓋加分
        if signal.dimension_coverage >= 5:
            adj = 2.0
            adjustment += adj
            factors['MULTI_DIMENSION_BONUS'] = {
                'adjustment': adj,
                'reason': '5+ dimensions covered'
            }

        # 強方向加分
        if signal.direction_strength == 'STRONG':
            adj = 1.5
            adjustment += adj
            factors['STRONG_DIRECTION_BONUS'] = {
                'adjustment': adj,
                'reason': 'Strong directional consensus'
            }

        # 衝突方向減分
        if signal.direction_strength == 'CONFLICT':
            adj = -3.0
            adjustment += adj
            factors['CONFLICT_PENALTY'] = {
                'adjustment': adj,
                'reason': 'Conflicting signals'
            }

        return adjustment, factors

    def determine_grade(self, score: float) -> str:
        """決定評級"""

        if score >= 90:
            return 'A+'
        elif score >= 80:
            return 'A'
        elif score >= 70:
            return 'B+'
        elif score >= 60:
            return 'B'
        elif score >= 50:
            return 'C'
        else:
            return 'D'
```

### 5.2 評分公式示意

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            評分公式                                           │
└─────────────────────────────────────────────────────────────────────────────┘

基礎總分 =
    0.30 × 信號強度分數 +
    0.25 × 維度覆蓋分數 +
    0.20 × 歷史績效分數 +
    0.15 × 市場環境分數 +
    0.10 × 時效性分數

最終分數 = min(基礎總分 + 調整分數, 100)

┌─────────────────────────────────────────────────────────────────────────────┐
│                          評分計算範例                                         │
│                                                                             │
│  股票: 2330 台積電                                                           │
│  方向: BUY (STRONG)                                                         │
│  覆蓋維度: 5                                                                 │
│                                                                             │
│  信號強度: (100 × 0.6) + (82 × 0.4) = 92.8 → × 0.30 = 27.84               │
│  維度覆蓋: (5/6 × 80) + 20 bonus = 86.7  → × 0.25 = 21.67               │
│  歷史績效: accuracy=0.68 → 80           → × 0.20 = 16.00               │
│  市場環境: BULLISH + STRONG → 95        → × 0.15 = 14.25               │
│  時效性:   age=2h → 100                 → × 0.10 = 10.00               │
│  ─────────────────────────────────────────────────────────────────────    │
│  基礎總分: 89.76                                                            │
│                                                                             │
│  調整:                                                                       │
│    + 2.0 (多維度加分)                                                        │
│    + 1.5 (強方向加分)                                                        │
│  ─────────────────────────────────────────────────────────────────────    │
│  最終分數: 93.26 → 評級: A+                                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 6. 信號發布流程

### 6.1 發布演算法

```python
class SignalPublisher:
    """信號發布器"""

    def publish_signals(self, batch_id: str, trade_date: date) -> PublishResult:
        """信號發布主流程"""

        # 1. 產生每日推薦清單
        buy_recommendations = self.generate_daily_recommendations(
            batch_id, trade_date, direction='BUY'
        )
        sell_recommendations = self.generate_daily_recommendations(
            batch_id, trade_date, direction='SELL'
        )

        # 2. 儲存推薦清單
        self.save_recommendations(buy_recommendations + sell_recommendations)

        # 3. 檢查訂閱條件並發送通知
        triggered_subscriptions = self.check_and_notify_subscriptions(
            batch_id, trade_date
        )

        # 4. 發布統一信號就緒事件
        self.publish_signals_ready_event(batch_id, trade_date)

        return PublishResult(
            buy_count=len(buy_recommendations),
            sell_count=len(sell_recommendations),
            subscriptions_triggered=len(triggered_subscriptions)
        )

    def generate_daily_recommendations(
        self, batch_id: str, trade_date: date, direction: str
    ) -> List[DailyRecommendation]:
        """產生每日推薦清單"""

        # 查詢該方向的統一信號，依分數排序
        signals = self.query_signals_by_direction(
            batch_id=batch_id,
            direction=direction,
            min_grade='B',  # 至少 B 級以上
            limit=50
        )

        recommendations = []
        for rank, signal in enumerate(signals, 1):
            rec = DailyRecommendation(
                trade_date=trade_date,
                direction=direction,
                rank=rank,
                unified_signal_id=signal.signal_id,
                stock_id=signal.stock_id,
                stock_name=signal.stock_name,
                sector_name=self.get_sector_name(signal.sector_code),
                unified_score=signal.unified_score,
                grade=signal.grade,
                direction_strength=signal.direction_strength,
                dimension_coverage=signal.dimension_coverage,
                key_factors=signal.key_factors,
                signal_types=signal.signal_types,
                generated_at=now()
            )
            recommendations.append(rec)

        return recommendations

    def check_and_notify_subscriptions(
        self, batch_id: str, trade_date: date
    ) -> List[str]:
        """檢查訂閱條件並發送通知"""

        # 載入活躍訂閱
        subscriptions = self.load_active_subscriptions()
        triggered = []

        for sub in subscriptions:
            # 檢查是否有符合條件的信號
            matching_signals = self.find_matching_signals(
                batch_id, sub.conditions
            )

            if matching_signals:
                # 發送通知
                self.send_notification(sub, matching_signals, trade_date)

                # 更新訂閱統計
                sub.triggered_count += 1
                sub.last_triggered_at = now()
                self.update_subscription(sub)

                triggered.append(sub.subscription_id)

        return triggered

    def send_notification(
        self, subscription, matching_signals: List, trade_date: date
    ):
        """發送通知"""

        if subscription.notification_channel == 'EVENT':
            # 發布 Spring Event
            self.publish_event(SignalSubscriptionTriggeredEvent(
                subscription_id=subscription.subscription_id,
                consumer_module=subscription.consumer_module,
                trade_date=trade_date,
                matching_count=len(matching_signals),
                signal_ids=[s.signal_id for s in matching_signals]
            ))

        elif subscription.notification_channel == 'WEBHOOK':
            # 發送 Webhook
            self.send_webhook(
                url=subscription.webhook_url,
                payload={
                    'subscription_id': subscription.subscription_id,
                    'trade_date': str(trade_date),
                    'matching_signals': [s.to_dict() for s in matching_signals]
                }
            )

    def publish_signals_ready_event(self, batch_id: str, trade_date: date):
        """發布統一信號就緒事件"""

        # 統計信號
        summary = self.get_signal_summary(batch_id)

        event = UnifiedSignalsReadyEvent(
            batch_id=batch_id,
            trade_date=trade_date,
            summary=summary,
            timestamp=now()
        )

        self.event_publisher.publish(event)
```

---

## 7. 信號消費流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            信號消費流程                                       │
└─────────────────────────────────────────────────────────────────────────────┘

                    ┌─────────────────────┐
                    │  M13 發布統一信號    │
                    │  UNIFIED_SIGNALS_    │
                    │  READY Event         │
                    └─────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
              ▼               ▼               ▼
    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
    │    M14      │  │    M15      │  │    M16      │
    │  選股引擎   │  │  警報通知   │  │  回測系統   │
    │            │  │            │  │            │
    │ 消費 A+ 級 │  │ 消費訂閱   │  │ 消費歷史   │
    │ 買入信號   │  │ 觸發信號   │  │ 信號       │
    └─────────────┘  └─────────────┘  └─────────────┘
           │               │               │
           ▼               ▼               ▼
    ┌─────────────────────────────────────────────┐
    │           標記信號已消費                     │
    │    POST /api/m13/signals/unified/{id}/      │
    │         consume                             │
    │                                             │
    │   記錄至 signal_consumption_log             │
    └─────────────────────────────────────────────┘

──────────────────────────────────────────────────────────────────────────────

下游模組消費信號範例（M14 選股引擎）:

public class M14StockScreeningService {

    @Autowired
    private M13SignalClient signalClient;

    @EventListener
    public void onUnifiedSignalsReady(UnifiedSignalsReadyEvent event) {
        // 1. 查詢符合條件的買入信號
        List<UnifiedSignal> buySignals = signalClient.querySignals(
            QueryRequest.builder()
                .tradeDate(event.getTradeDate())
                .direction("BUY")
                .minGrade("A")
                .minScore(80.0)
                .build()
        );

        // 2. 執行選股邏輯
        List<ScreeningResult> results = performScreening(buySignals);

        // 3. 標記信號已消費
        signalClient.consumeBatch(
            buySignals.stream().map(s -> s.getSignalId()).toList(),
            "M14",
            "STOCK_SCREENING"
        );
    }
}
```

---

## 8. 相關文檔

- [M13 功能需求](../specs/functional/M13-信號引擎功能需求.md)
- [M13 API 規格](../specs/api/M13-API規格.md)
- [M13 資料庫設計](./M13-資料庫設計.md)
- [M13 ERD](./erd/M13-ERD.md)

---

**文件維護者**: 後端工程師
**最後更新**: 2026-01-14
**下次審核**: 2026-04-14
