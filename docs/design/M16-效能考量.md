# M16-回測系統 效能考量

> **文件編號**: PERF-M16
> **模組名稱**: 回測系統 (Backtesting System)
> **版本**: v1.0
> **最後更新**: 2026-01-15
> **狀態**: Draft

---

## 1. 效能目標

### 1.1 回應時間目標

| 操作類型 | P50 | P95 | P99 | 說明 |
|---------|-----|-----|-----|------|
| 建立回測 | < 100ms | < 200ms | < 500ms | 參數驗證與任務建立 |
| 單股回測 (3年) | < 3s | < 5s | < 8s | ~750 交易日 |
| 多股回測 (10股/3年) | < 15s | < 30s | < 45s | 中型回測 |
| 全市場回測 (100股/1年) | < 1min | < 2min | < 3min | 大型回測 |
| 參數最佳化 (100組合) | < 5min | < 8min | < 10min | 網格搜尋 |
| 淨值曲線查詢 | < 200ms | < 500ms | < 1s | 報告資料 |
| 交易明細查詢 | < 100ms | < 200ms | < 500ms | 分頁查詢 |

### 1.2 吞吐量目標

| 指標 | 目標值 | 說明 |
|-----|-------|------|
| 並行回測數 | 8 | 系統同時執行上限 |
| 每日回測處理量 | 500 | 每日可處理的回測任務數 |
| 每用戶並行數 | 2 | 單一用戶同時執行上限 |

### 1.3 資源限制

| 資源 | 限制值 | 說明 |
|-----|-------|------|
| 單次回測最大期間 | 10 年 | 約 2,500 交易日 |
| 單次回測最大股票數 | 200 檔 | 避免記憶體溢出 |
| 參數最佳化最大組合 | 1,000 組 | 避免執行過久 |
| 淨值曲線資料點 | 2,500 點 | 每日一點最多 10 年 |

---

## 2. 資料載入最佳化

### 2.1 批次載入策略

```
┌─────────────────────────────────────────────────────────────────┐
│                    資料載入最佳化策略                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  問題：回測需載入大量歷史數據，逐日查詢效率低                     │
│                                                                  │
│  ❌ 錯誤做法：                                                   │
│  for each day in backtest_period:                               │
│    price = SELECT * FROM stock_daily WHERE date = day  // N 次  │
│                                                                  │
│  ✅ 正確做法：                                                   │
│  一次載入整個期間的資料，存入記憶體 Map                          │
│                                                                  │
│  Map<StockId, Map<Date, DailyPrice>> priceCache =               │
│    SELECT * FROM stock_daily                                    │
│    WHERE stock_id IN (:stockIds)                                │
│      AND trade_date BETWEEN :startDate AND :endDate             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**批次載入實作**

```java
@Service
public class BacktestDataLoader {

    private final StockDailyMapper stockDailyMapper;
    private final TechnicalIndicatorMapper indicatorMapper;
    private final UnifiedSignalMapper signalMapper;

    /**
     * 一次性載入回測所需的所有資料
     */
    public BacktestDataSet loadData(BacktestTask task) {
        List<String> stockIds = task.getTargetStockIds();
        LocalDate startDate = task.getStartDate();
        LocalDate endDate = task.getEndDate();

        // 平行載入不同類型的資料
        CompletableFuture<Map<String, List<StockDaily>>> pricesFuture =
            CompletableFuture.supplyAsync(() ->
                loadPrices(stockIds, startDate, endDate));

        CompletableFuture<Map<String, List<TechnicalIndicator>>> indicatorsFuture =
            CompletableFuture.supplyAsync(() ->
                loadIndicators(stockIds, startDate, endDate));

        CompletableFuture<Map<String, List<UnifiedSignal>>> signalsFuture =
            CompletableFuture.supplyAsync(() ->
                loadSignals(stockIds, startDate, endDate));

        // 等待所有資料載入完成
        return BacktestDataSet.builder()
            .prices(pricesFuture.join())
            .indicators(indicatorsFuture.join())
            .signals(signalsFuture.join())
            .build();
    }

    private Map<String, List<StockDaily>> loadPrices(
            List<String> stockIds, LocalDate start, LocalDate end) {
        return stockDailyMapper.findByStockIdsAndPeriod(stockIds, start, end)
            .stream()
            .collect(Collectors.groupingBy(StockDaily::getStockId));
    }
}
```

### 2.2 資料快取架構

```
┌─────────────────────────────────────────────────────────────────┐
│                    回測資料快取架構                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    L1: 執行緒本地快取                    │    │
│  │                                                          │    │
│  │  BacktestDataSet (執行期間保持)                         │    │
│  │  • prices: Map<StockId, Map<Date, Price>>               │    │
│  │  • indicators: Map<StockId, Map<Date, Indicators>>      │    │
│  │  • signals: Map<StockId, Map<Date, Signal>>             │    │
│  │                                                          │    │
│  │  生命週期：單次回測執行期間                              │    │
│  │  大小限制：依回測規模動態調整                            │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                           │ Cache Miss                          │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    L2: Redis 快取                        │    │
│  │                                                          │    │
│  │  Key Pattern:                                           │    │
│  │  backtest:price:{stockId}:{year}                        │    │
│  │  backtest:indicator:{stockId}:{year}                    │    │
│  │                                                          │    │
│  │  TTL: 24 小時                                           │    │
│  │  用途：跨回測共享熱門股票數據                           │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                           │ Cache Miss                          │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    L3: Database                          │    │
│  │                                                          │    │
│  │  stock_daily, technical_indicators, unified_signals     │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 回測執行最佳化

### 3.1 演算法最佳化

```
┌─────────────────────────────────────────────────────────────────┐
│                    回測演算法最佳化                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 避免重複計算                                                 │
│  ────────────────────────────────────────────────────────────   │
│                                                                  │
│  ❌ 每日重新計算持倉市值：                                       │
│  for each position:                                             │
│    value = getPrice(stock, date) * shares   // 每日都查詢       │
│                                                                  │
│  ✅ 增量更新：                                                   │
│  portfolioValue = previousValue                                 │
│  for each position:                                             │
│    dailyChange = (todayPrice - yesterdayPrice) * shares        │
│    portfolioValue += dailyChange                               │
│                                                                  │
│  ────────────────────────────────────────────────────────────   │
│                                                                  │
│  2. 停損停利檢查最佳化                                           │
│  ────────────────────────────────────────────────────────────   │
│                                                                  │
│  ❌ 每個持倉都檢查停損停利：                                     │
│  for each position:                                             │
│    if currentPrice <= entryPrice * (1 - stopLoss): sell()      │
│                                                                  │
│  ✅ 預先計算觸發價位：                                           │
│  class Position:                                                │
│    stopLossPrice = entryPrice * (1 - stopLoss)  // 買入時計算  │
│    takeProfitPrice = entryPrice * (1 + takeProfit)             │
│                                                                  │
│  if currentPrice <= position.stopLossPrice: sell()             │
│                                                                  │
│  ────────────────────────────────────────────────────────────   │
│                                                                  │
│  3. 信號查找最佳化                                               │
│  ────────────────────────────────────────────────────────────   │
│                                                                  │
│  ❌ 遍歷所有信號：                                               │
│  for each signal in allSignals:                                │
│    if signal.date == today && signal.stockId in targetStocks:  │
│                                                                  │
│  ✅ 預先建立索引：                                               │
│  Map<Date, Map<StockId, Signal>> signalIndex                   │
│  todaySignals = signalIndex.get(today)  // O(1) 查找           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 記憶體管理

```java
/**
 * 記憶體效率的回測執行器
 */
public class MemoryEfficientBacktestEngine {

    // 使用原始型別陣列減少物件開銷
    private double[] portfolioValues;   // 每日淨值
    private double[] dailyReturns;      // 每日報酬

    // 使用 int 而非 LocalDate 儲存日期索引
    private int[] tradeDates;           // 日期索引

    // 批次寫入快照，避免頻繁 DB 操作
    private static final int SNAPSHOT_BATCH_SIZE = 100;
    private List<DailySnapshot> snapshotBuffer = new ArrayList<>(SNAPSHOT_BATCH_SIZE);

    public void recordSnapshot(DailySnapshot snapshot) {
        snapshotBuffer.add(snapshot);
        if (snapshotBuffer.size() >= SNAPSHOT_BATCH_SIZE) {
            flushSnapshots();
        }
    }

    private void flushSnapshots() {
        snapshotMapper.batchInsert(snapshotBuffer);
        snapshotBuffer.clear();
    }

    // 回測完成後釋放記憶體
    public void cleanup() {
        portfolioValues = null;
        dailyReturns = null;
        tradeDates = null;
        System.gc();  // 建議 GC
    }
}
```

### 3.3 記憶體用量估算

| 回測規模 | 估算記憶體 | 說明 |
|---------|-----------|------|
| 1 股 × 1 年 | ~5 MB | 250 日 × (價格 + 指標 + 快照) |
| 10 股 × 3 年 | ~150 MB | 7,500 日資料點 |
| 100 股 × 3 年 | ~1.5 GB | 需注意 JVM heap 設定 |
| 200 股 × 10 年 | ~5 GB | 接近上限，建議分批 |

**JVM 建議設定**
```bash
# 回測服務 JVM 參數
-Xms2g -Xmx8g
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:+HeapDumpOnOutOfMemoryError
```

---

## 4. 參數最佳化效能

### 4.1 平行執行策略

```
┌─────────────────────────────────────────────────────────────────┐
│                    參數最佳化平行執行                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  策略：將參數組合分配給多個執行緒平行執行                        │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    Worker Pool                           │    │
│  │                                                          │    │
│  │   Worker 1    Worker 2    Worker 3    Worker 4          │    │
│  │   ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐            │    │
│  │   │組合1 │   │組合2 │   │組合3 │   │組合4 │            │    │
│  │   │組合5 │   │組合6 │   │組合7 │   │組合8 │            │    │
│  │   │組合9 │   │...   │   │...   │   │...   │            │    │
│  │   └──────┘   └──────┘   └──────┘   └──────┘            │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                           │                                     │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    結果彙整                              │    │
│  │                                                          │    │
│  │  • 使用 ConcurrentHashMap 收集結果                      │    │
│  │  • 使用 AtomicInteger 追蹤進度                          │    │
│  │  • 完成後排序取 Top N                                   │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**平行最佳化實作**

```java
@Service
public class ParallelOptimizationService {

    private final ExecutorService optimizationPool =
        Executors.newFixedThreadPool(4);  // 4 個 worker

    public OptimizationResult optimize(
            BacktestTask baseTask,
            List<ParameterSet> combinations) {

        // 共享資料載入（只載入一次）
        BacktestDataSet sharedData = dataLoader.loadData(baseTask);

        // 進度追蹤
        AtomicInteger completed = new AtomicInteger(0);
        int total = combinations.size();

        // 平行執行
        List<CompletableFuture<CombinationResult>> futures = combinations.stream()
            .map(params -> CompletableFuture.supplyAsync(() -> {
                // 使用共享資料執行回測
                BacktestResult result = engine.executeWithData(
                    baseTask.withParameters(params), sharedData);

                // 更新進度
                int done = completed.incrementAndGet();
                updateProgress(done, total);

                return new CombinationResult(params, result.getMetrics());
            }, optimizationPool))
            .collect(Collectors.toList());

        // 等待所有完成
        List<CombinationResult> results = futures.stream()
            .map(CompletableFuture::join)
            .sorted(Comparator.comparing(r -> r.getMetrics().getSharpeRatio()).reversed())
            .collect(Collectors.toList());

        return buildOptimizationResult(results);
    }
}
```

### 4.2 效能對比

| 組合數量 | 序列執行 | 4 Worker 平行 | 加速比 |
|---------|---------|--------------|--------|
| 100 | 5 min | 1.5 min | 3.3x |
| 500 | 25 min | 7 min | 3.6x |
| 1000 | 50 min | 14 min | 3.6x |

---

## 5. 結果儲存最佳化

### 5.1 批次寫入

```java
/**
 * 批次寫入交易記錄與每日快照
 */
public class BatchResultWriter {

    private static final int TRADE_BATCH_SIZE = 50;
    private static final int SNAPSHOT_BATCH_SIZE = 100;

    private List<BacktestTrade> tradeBatch = new ArrayList<>();
    private List<DailySnapshot> snapshotBatch = new ArrayList<>();

    public void addTrade(BacktestTrade trade) {
        tradeBatch.add(trade);
        if (tradeBatch.size() >= TRADE_BATCH_SIZE) {
            flushTrades();
        }
    }

    public void addSnapshot(DailySnapshot snapshot) {
        snapshotBatch.add(snapshot);
        if (snapshotBatch.size() >= SNAPSHOT_BATCH_SIZE) {
            flushSnapshots();
        }
    }

    @Transactional
    public void flushTrades() {
        if (!tradeBatch.isEmpty()) {
            tradeMapper.batchInsert(tradeBatch);
            tradeBatch.clear();
        }
    }

    @Transactional
    public void flushSnapshots() {
        if (!snapshotBatch.isEmpty()) {
            snapshotMapper.batchInsert(snapshotBatch);
            snapshotBatch.clear();
        }
    }

    public void flushAll() {
        flushTrades();
        flushSnapshots();
    }
}
```

### 5.2 JSONB 欄位壓縮

```sql
-- 大型 JSONB 欄位使用 TOAST 壓縮
-- PostgreSQL 自動處理，但可調整策略

ALTER TABLE backtest_results
ALTER COLUMN monthly_returns SET STORAGE EXTENDED;  -- 壓縮 + 行外儲存

ALTER TABLE backtest_results
ALTER COLUMN stock_performance SET STORAGE EXTENDED;
```

---

## 6. 查詢效能最佳化

### 6.1 淨值曲線查詢

```sql
-- 最佳化：使用覆蓋索引
CREATE INDEX idx_snapshots_equity_curve ON backtest_daily_snapshots
(backtest_id, snapshot_date)
INCLUDE (portfolio_value, cumulative_return, drawdown, benchmark_value);

-- 避免 SELECT *，只取需要的欄位
SELECT snapshot_date, portfolio_value, cumulative_return,
       drawdown, benchmark_value
FROM backtest_daily_snapshots
WHERE backtest_id = :backtestId
ORDER BY snapshot_date;
```

### 6.2 交易明細分頁

```sql
-- 使用 keyset pagination 替代 OFFSET
-- 首頁
SELECT * FROM backtest_trades
WHERE backtest_id = :backtestId
ORDER BY trade_date, id
LIMIT 50;

-- 下一頁（使用上一頁最後一筆的 trade_date 和 id）
SELECT * FROM backtest_trades
WHERE backtest_id = :backtestId
  AND (trade_date, id) > (:lastDate, :lastId)
ORDER BY trade_date, id
LIMIT 50;
```

---

## 7. 監控指標

### 7.1 效能指標

```yaml
metrics:
  backtest:
    # 執行時間分布
    - name: backtest.execution.duration
      type: timer
      tags: [size: small/medium/large]

    # 記憶體使用
    - name: backtest.memory.used
      type: gauge
      description: 回測執行期間記憶體使用

    # 資料載入時間
    - name: backtest.data.load.duration
      type: timer

    # 交易處理速度
    - name: backtest.trades.per.second
      type: gauge

    # 最佳化效能
    - name: optimization.combinations.per.minute
      type: gauge
```

### 7.2 效能基準線

| 指標 | 基準線 | 告警閾值 |
|-----|-------|---------|
| 單股回測 (1年) | < 1s | > 3s |
| 資料載入 (10股/3年) | < 2s | > 5s |
| 每日處理速度 | > 500 日/秒 | < 200 日/秒 |
| 最佳化速度 | > 20 組合/分鐘 | < 10 組合/分鐘 |

---

## 8. 相關文檔

- [M16 功能需求](../specs/functional/M16-回測系統功能需求.md)
- [M16 業務流程](./M16-業務流程.md)
- [M16 Job 排程配置](../deployment/M16-Job排程配置.md)

---

**文件維護者**: 後端工程師
**最後更新**: 2026-01-15
**下次審核**: 2026-04-15
