# M17-風險管理模組 效能考量

> **文件編號**: PERF-M17
> **模組名稱**: 風險管理模組 (Risk Management Module)
> **版本**: v1.0
> **最後更新**: 2026-01-15
> **狀態**: Draft

---

## 1. 效能目標

### 1.1 回應時間目標

| 操作類型 | 目標時間 | 最大時間 | 說明 |
|---------|---------|---------|------|
| 取得風險概覽 | < 200ms | 500ms | 從快照讀取 |
| VaR 查詢 (已計算) | < 100ms | 300ms | 從快取讀取 |
| VaR 即時計算 | < 5s | 15s | Historical/Parametric |
| Monte Carlo VaR | < 30s | 60s | 10,000 次模擬 |
| 限額狀態查詢 | < 100ms | 200ms | 簡單查詢 |
| 壓力測試執行 | < 60s | 120s | 10 個情境 |
| 風險報告生成 | < 3s | 10s | STANDARD 報告 |

### 1.2 吞吐量目標

| 場景 | 目標 TPS | 說明 |
|-----|---------|------|
| 風險快照查詢 | 100 | 高頻 API |
| 預警查詢 | 50 | 中頻 API |
| VaR 即時計算 | 5 | 計算密集 |
| 壓力測試 | 2 | 計算密集 |

### 1.3 資源使用目標

| 資源 | 目標 | 最大值 |
|-----|------|-------|
| CPU 使用率 (正常) | < 30% | 50% |
| CPU 使用率 (批次) | < 70% | 90% |
| 記憶體使用 | < 2GB | 4GB |
| 資料庫連線 | < 20 | 50 |

---

## 2. VaR 計算效能優化

### 2.1 效能瓶頸分析

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      VaR 計算效能瓶頸                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Historical VaR (252 天 × 20 檔股票):                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ 1. 資料載入      │████████████████│  40%  │ DB 查詢 5,040 筆    │   │
│  │ 2. 報酬率計算    │██████│          │  15%  │ 數值計算            │   │
│  │ 3. 投組報酬合成  │████│            │  10%  │ 矩陣運算            │   │
│  │ 4. 排序取百分位  │██████████│      │  25%  │ 排序演算法          │   │
│  │ 5. 組件 VaR     │████│            │  10%  │ 迴圈計算            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  Monte Carlo VaR (10,000 次模擬 × 20 檔):                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ 1. 共變異數估計  │████████│        │  20%  │ 矩陣計算            │   │
│  │ 2. Cholesky 分解 │██████│          │  15%  │ 矩陣分解            │   │
│  │ 3. 隨機數生成    │████│            │  10%  │ RNG                 │   │
│  │ 4. 投組模擬      │████████████████│  40%  │ 200K 次矩陣乘法     │   │
│  │ 5. 統計彙總      │██████│          │  15%  │ 排序與統計          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 資料載入優化

#### 批次查詢

```java
@Repository
public class StockPriceRepository {

    /**
     * 批次取得多檔股票歷史價格
     * 使用單一查詢取代多次查詢
     */
    @Query(value = """
        SELECT stock_id, trade_date, close_price, daily_return
        FROM stock_daily_prices
        WHERE stock_id IN (:stockIds)
          AND trade_date BETWEEN :startDate AND :endDate
        ORDER BY stock_id, trade_date
        """, nativeQuery = true)
    List<StockPrice> findBatchPrices(
        @Param("stockIds") List<String> stockIds,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate);
}
```

#### 價格資料快取

```java
@Service
public class PriceCacheService {

    private final Cache<String, double[]> returnCache;

    public PriceCacheService() {
        this.returnCache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofHours(1))
            .build();
    }

    /**
     * 快取鍵格式: "stockId:period"
     * 例如: "2330:252" 表示台積電過去 252 天報酬率
     */
    public double[] getReturns(String stockId, int days) {
        String cacheKey = stockId + ":" + days;
        return returnCache.get(cacheKey, k -> loadReturns(stockId, days));
    }

    private double[] loadReturns(String stockId, int days) {
        List<StockPrice> prices = priceRepository.findRecentPrices(stockId, days);
        return prices.stream()
            .mapToDouble(p -> p.getDailyReturn().doubleValue())
            .toArray();
    }
}
```

### 2.3 計算優化

#### 矩陣運算使用 Apache Commons Math

```java
@Component
public class VaRCalculator {

    /**
     * 使用 Apache Commons Math 進行矩陣運算
     */
    public VaRResult calculateParametricVaR(
            double[][] returns,  // [days][stocks]
            double[] weights,
            double confidenceLevel) {

        int n = weights.length;

        // 1. 計算共變異數矩陣
        RealMatrix covMatrix = new Covariance(returns).getCovarianceMatrix();

        // 2. 計算投組變異數: w'Σw
        RealVector w = new ArrayRealVector(weights);
        double portfolioVariance = w.dotProduct(covMatrix.operate(w));
        double portfolioStdDev = Math.sqrt(portfolioVariance);

        // 3. 計算 VaR
        NormalDistribution normal = new NormalDistribution();
        double zScore = normal.inverseCumulativeProbability(1 - confidenceLevel);
        double varPct = -zScore * portfolioStdDev;

        return VaRResult.builder()
            .var(varPct)
            .method("PARAMETRIC")
            .confidenceLevel(confidenceLevel)
            .build();
    }
}
```

#### Monte Carlo 平行化

```java
@Component
public class MonteCarloVaRCalculator {

    @Value("${var.montecarlo.thread-pool-size:4}")
    private int threadPoolSize;

    /**
     * 平行執行 Monte Carlo 模擬
     */
    public VaRResult calculateMonteCarloVaR(
            RealMatrix covMatrix,
            double[] weights,
            int simulations,
            double confidenceLevel) {

        int n = weights.length;

        // 1. Cholesky 分解
        CholeskyDecomposition cholesky = new CholeskyDecomposition(covMatrix);
        RealMatrix L = cholesky.getL();

        // 2. 平行模擬
        ForkJoinPool pool = new ForkJoinPool(threadPoolSize);
        double[] portfolioReturns = pool.submit(() ->
            IntStream.range(0, simulations)
                .parallel()
                .mapToDouble(i -> simulateOneScenario(L, weights, n))
                .toArray()
        ).join();

        // 3. 排序取 VaR
        Arrays.sort(portfolioReturns);
        int varIndex = (int) Math.ceil(simulations * (1 - confidenceLevel));
        double var = -portfolioReturns[varIndex];

        // 4. 計算 CVaR (Expected Shortfall)
        double cvar = 0;
        for (int i = 0; i < varIndex; i++) {
            cvar += -portfolioReturns[i];
        }
        cvar /= varIndex;

        return VaRResult.builder()
            .var(var)
            .cvar(cvar)
            .method("MONTE_CARLO")
            .simulations(simulations)
            .confidenceLevel(confidenceLevel)
            .build();
    }

    private double simulateOneScenario(RealMatrix L, double[] weights, int n) {
        // 生成標準常態隨機數
        double[] z = new double[n];
        for (int j = 0; j < n; j++) {
            z[j] = ThreadLocalRandom.current().nextGaussian();
        }

        // 相關化: x = L * z
        RealVector zVector = new ArrayRealVector(z);
        RealVector x = L.operate(zVector);

        // 投組報酬: w'x
        double portfolioReturn = 0;
        for (int j = 0; j < n; j++) {
            portfolioReturn += weights[j] * x.getEntry(j);
        }

        return portfolioReturn;
    }
}
```

### 2.4 VaR 快取策略

```java
@Service
public class VaRCacheService {

    private final Cache<String, VaRResult> varCache;

    public VaRCacheService() {
        this.varCache = Caffeine.newBuilder()
            .maximumSize(500)
            .expireAfterWrite(Duration.ofMinutes(30))
            .build();
    }

    /**
     * 快取鍵格式: "portfolioId:method:confidence:horizon:date"
     */
    public VaRResult getOrCalculate(
            String portfolioId,
            String method,
            double confidence,
            int horizon,
            LocalDate date,
            Supplier<VaRResult> calculator) {

        String cacheKey = String.format("%s:%s:%.2f:%d:%s",
            portfolioId, method, confidence, horizon, date);

        return varCache.get(cacheKey, k -> calculator.get());
    }

    /**
     * 投組持倉變動時清除快取
     */
    public void invalidatePortfolio(String portfolioId) {
        varCache.asMap().keySet().removeIf(k -> k.startsWith(portfolioId + ":"));
    }
}
```

---

## 3. 相關性計算效能優化

### 3.1 增量計算

```java
@Service
public class IncrementalCorrelationService {

    /**
     * 增量更新相關係數
     * 使用 Welford 演算法避免重新計算整個矩陣
     */
    public void updateCorrelation(
            String portfolioId,
            LocalDate newDate,
            Map<String, Double> newReturns) {

        CorrelationCache cache = cacheRepository.findLatest(portfolioId);

        if (cache == null || isExpired(cache)) {
            // 完整重算
            calculateFullCorrelation(portfolioId);
            return;
        }

        // 增量更新 (滾動窗口)
        List<String> stockIds = cache.getStockIds();
        int n = stockIds.size();

        // 移除最舊的資料點
        double[][] oldReturns = cache.getReturnMatrix();
        double[][] newMatrix = new double[cache.getLookbackDays()][n];
        System.arraycopy(oldReturns, 1, newMatrix, 0, oldReturns.length - 1);

        // 添加新的資料點
        for (int i = 0; i < n; i++) {
            newMatrix[cache.getLookbackDays() - 1][i] =
                newReturns.getOrDefault(stockIds.get(i), 0.0);
        }

        // 使用 Apache Commons Math 計算相關係數
        PearsonsCorrelation correlation = new PearsonsCorrelation(newMatrix);
        RealMatrix corrMatrix = correlation.getCorrelationMatrix();

        // 更新快取
        updateCache(cache, corrMatrix.getData());
    }
}
```

### 3.2 矩陣計算批次處理

```java
@Component
public class BatchCorrelationCalculator {

    private static final int BATCH_SIZE = 50;  // 每批處理 50 檔股票

    /**
     * 大型投組分批計算相關係數
     */
    public double[][] calculateLargeCorrelation(
            List<String> stockIds,
            double[][] returns) {

        int n = stockIds.size();

        if (n <= BATCH_SIZE) {
            // 小型投組直接計算
            return new PearsonsCorrelation(returns).getCorrelationMatrix().getData();
        }

        // 大型投組分批計算
        double[][] result = new double[n][n];

        // 對角線為 1
        for (int i = 0; i < n; i++) {
            result[i][i] = 1.0;
        }

        // 分批計算非對角元素
        for (int i = 0; i < n; i += BATCH_SIZE) {
            int iEnd = Math.min(i + BATCH_SIZE, n);

            for (int j = i; j < n; j += BATCH_SIZE) {
                int jEnd = Math.min(j + BATCH_SIZE, n);

                calculateBatchCorrelation(returns, result, i, iEnd, j, jEnd);
            }
        }

        return result;
    }

    private void calculateBatchCorrelation(
            double[][] returns,
            double[][] result,
            int iStart, int iEnd,
            int jStart, int jEnd) {

        for (int i = iStart; i < iEnd; i++) {
            for (int j = Math.max(jStart, i + 1); j < jEnd; j++) {
                double corr = calculatePearson(returns, i, j);
                result[i][j] = corr;
                result[j][i] = corr;  // 對稱矩陣
            }
        }
    }

    private double calculatePearson(double[][] returns, int i, int j) {
        int n = returns.length;
        double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;

        for (int k = 0; k < n; k++) {
            double x = returns[k][i];
            double y = returns[k][j];
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumX2 += x * x;
            sumY2 += y * y;
        }

        double numerator = n * sumXY - sumX * sumY;
        double denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

        return denominator == 0 ? 0 : numerator / denominator;
    }
}
```

---

## 4. 壓力測試效能優化

### 4.1 情境預計算

```java
@Service
public class ScenarioPrecomputeService {

    private final Map<String, double[]> scenarioImpacts = new ConcurrentHashMap<>();

    /**
     * 系統啟動時預計算標準情境的衝擊係數
     */
    @PostConstruct
    public void precomputeScenarios() {
        List<RiskScenario> systemScenarios = scenarioRepository.findSystemScenarios();

        for (RiskScenario scenario : systemScenarios) {
            double[] impacts = calculateScenarioImpacts(scenario);
            scenarioImpacts.put(scenario.getScenarioId(), impacts);
        }

        log.info("Precomputed {} scenario impacts", systemScenarios.size());
    }

    /**
     * 壓力測試時直接使用預計算結果
     */
    public StressTestResult runStressTest(
            String portfolioId,
            String scenarioId,
            Map<String, Double> positions) {

        double[] impacts = scenarioImpacts.get(scenarioId);
        if (impacts == null) {
            // 自訂情境即時計算
            RiskScenario scenario = scenarioRepository.findById(scenarioId);
            impacts = calculateScenarioImpacts(scenario);
        }

        // 快速計算投組損失
        double portfolioLoss = 0;
        for (Map.Entry<String, Double> pos : positions.entrySet()) {
            int stockIndex = getStockIndex(pos.getKey());
            portfolioLoss += pos.getValue() * impacts[stockIndex];
        }

        return StressTestResult.builder()
            .scenarioId(scenarioId)
            .portfolioChange(portfolioLoss)
            .build();
    }
}
```

### 4.2 平行情境測試

```java
@Service
public class ParallelStressTestService {

    @Autowired
    private ExecutorService stressTestExecutor;

    /**
     * 平行執行多個情境測試
     */
    public List<StressTestResult> runParallelTests(
            String portfolioId,
            List<String> scenarioIds) {

        Map<String, Double> positions = loadPositions(portfolioId);

        List<CompletableFuture<StressTestResult>> futures = scenarioIds.stream()
            .map(scenarioId -> CompletableFuture.supplyAsync(() ->
                runSingleTest(portfolioId, scenarioId, positions),
                stressTestExecutor))
            .collect(Collectors.toList());

        return futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
    }

    private StressTestResult runSingleTest(
            String portfolioId,
            String scenarioId,
            Map<String, Double> positions) {

        RiskScenario scenario = scenarioRepository.findById(scenarioId);
        double portfolioChange = 0;

        for (Shock shock : scenario.getShocks()) {
            portfolioChange += calculateShockImpact(positions, shock);
        }

        return StressTestResult.builder()
            .portfolioId(portfolioId)
            .scenarioId(scenarioId)
            .scenarioName(scenario.getName())
            .portfolioChange(portfolioChange)
            .build();
    }
}
```

---

## 5. 資料庫效能優化

### 5.1 索引策略

```sql
-- 風險快照查詢優化
CREATE INDEX CONCURRENTLY idx_risk_snapshots_portfolio_date
ON risk_snapshots(portfolio_id, snapshot_date DESC);

-- 覆蓋索引 (避免回表)
CREATE INDEX CONCURRENTLY idx_risk_snapshots_covering
ON risk_snapshots(portfolio_id, snapshot_date DESC)
INCLUDE (risk_level, risk_score, var_95_daily, volatility_annualized, beta);

-- VaR 結果查詢
CREATE INDEX CONCURRENTLY idx_var_results_lookup
ON risk_var_results(portfolio_id, calculation_date DESC, method, confidence_level);

-- 限額狀態快速查詢
CREATE INDEX CONCURRENTLY idx_limits_active_status
ON risk_limits(portfolio_id, current_status)
WHERE enabled = TRUE AND current_status != 'NORMAL';

-- 預警快速查詢
CREATE INDEX CONCURRENTLY idx_alerts_active_severity
ON risk_alerts(portfolio_id, severity, triggered_at DESC)
WHERE status = 'ACTIVE';
```

### 5.2 分區策略

```sql
-- 風險快照按月分區
CREATE TABLE risk_snapshots (
    id                    BIGSERIAL,
    portfolio_id          VARCHAR(50) NOT NULL,
    snapshot_date         DATE NOT NULL,
    -- ... 其他欄位
    PRIMARY KEY (id, snapshot_date)
) PARTITION BY RANGE (snapshot_date);

-- 建立分區
CREATE TABLE risk_snapshots_2026_01
    PARTITION OF risk_snapshots
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

CREATE TABLE risk_snapshots_2026_02
    PARTITION OF risk_snapshots
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

-- 自動建立未來分區的函數
CREATE OR REPLACE FUNCTION create_risk_snapshot_partitions()
RETURNS void AS $$
DECLARE
    partition_date DATE;
    partition_name TEXT;
BEGIN
    FOR i IN 0..2 LOOP
        partition_date := DATE_TRUNC('month', CURRENT_DATE) + (i || ' months')::INTERVAL;
        partition_name := 'risk_snapshots_' || TO_CHAR(partition_date, 'YYYY_MM');

        IF NOT EXISTS (
            SELECT 1 FROM pg_tables
            WHERE tablename = partition_name
        ) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF risk_snapshots FOR VALUES FROM (%L) TO (%L)',
                partition_name,
                partition_date,
                partition_date + INTERVAL '1 month'
            );
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 查詢優化

```java
@Repository
public interface RiskSnapshotRepository extends JpaRepository<RiskSnapshot, Long> {

    /**
     * 使用 DTO 投影減少資料傳輸
     */
    @Query("""
        SELECT new com.chris.fin_shark.m17.dto.RiskSummaryDto(
            r.portfolioId, r.snapshotDate, r.riskLevel, r.riskScore,
            r.var95Daily, r.volatilityAnnualized, r.beta
        )
        FROM RiskSnapshot r
        WHERE r.portfolioId = :portfolioId
          AND r.snapshotDate = (
              SELECT MAX(r2.snapshotDate)
              FROM RiskSnapshot r2
              WHERE r2.portfolioId = :portfolioId
          )
        """)
    Optional<RiskSummaryDto> findLatestSummary(@Param("portfolioId") String portfolioId);

    /**
     * 歷史趨勢查詢 - 只取需要的欄位
     */
    @Query(value = """
        SELECT snapshot_date, var_95_daily, volatility_annualized, beta
        FROM risk_snapshots
        WHERE portfolio_id = :portfolioId
          AND snapshot_date >= :startDate
        ORDER BY snapshot_date
        """, nativeQuery = true)
    List<Object[]> findTrendData(
        @Param("portfolioId") String portfolioId,
        @Param("startDate") LocalDate startDate);
}
```

---

## 6. 快取策略

### 6.1 多層快取架構

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        M17 快取架構                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        L1: 本地快取 (Caffeine)                    │   │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐        │   │
│  │  │ VaR 結果       │  │ 相關性矩陣     │  │ 限額狀態       │        │   │
│  │  │ TTL: 30 min   │  │ TTL: 1 hour   │  │ TTL: 5 min    │        │   │
│  │  │ Size: 500     │  │ Size: 100     │  │ Size: 200     │        │   │
│  │  └───────────────┘  └───────────────┘  └───────────────┘        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        L2: 分散式快取 (Redis)                     │   │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐        │   │
│  │  │ 風險快照       │  │ 價格資料       │  │ 預警計數       │        │   │
│  │  │ TTL: 1 day    │  │ TTL: 1 hour   │  │ TTL: 15 min   │        │   │
│  │  └───────────────┘  └───────────────┘  └───────────────┘        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        L3: 資料庫快取表                           │   │
│  │  ┌───────────────┐  ┌───────────────┐                           │   │
│  │  │ correlation   │  │ 預計算結果     │                           │   │
│  │  │ _cache        │  │ (情境衝擊)     │                           │   │
│  │  └───────────────┘  └───────────────┘                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 快取配置

```java
@Configuration
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager cacheManager = new SimpleCacheManager();
        cacheManager.setCaches(Arrays.asList(
            buildCache("varResults", 500, 30, TimeUnit.MINUTES),
            buildCache("correlationMatrix", 100, 1, TimeUnit.HOURS),
            buildCache("limitStatus", 200, 5, TimeUnit.MINUTES),
            buildCache("riskSnapshots", 300, 15, TimeUnit.MINUTES),
            buildCache("stockReturns", 1000, 1, TimeUnit.HOURS)
        ));
        return cacheManager;
    }

    private CaffeineCache buildCache(String name, int maxSize, int ttl, TimeUnit unit) {
        return new CaffeineCache(name, Caffeine.newBuilder()
            .maximumSize(maxSize)
            .expireAfterWrite(ttl, unit)
            .recordStats()
            .build());
    }
}
```

### 6.3 快取失效策略

```java
@Component
public class RiskCacheInvalidator {

    @Autowired
    private CacheManager cacheManager;

    /**
     * 投組持倉變動時失效相關快取
     */
    @EventListener
    public void onPortfolioChanged(PortfolioChangedEvent event) {
        String portfolioId = event.getPortfolioId();

        // 失效 VaR 快取
        evictByPattern("varResults", portfolioId + ":*");

        // 失效相關性快取
        evictByPattern("correlationMatrix", portfolioId + ":*");

        // 失效風險快照快取
        evictByPattern("riskSnapshots", portfolioId);

        log.info("Invalidated risk caches for portfolio: {}", portfolioId);
    }

    /**
     * 每日資料更新後失效價格快取
     */
    @EventListener
    public void onDailyDataUpdated(DailyDataUpdatedEvent event) {
        Cache stockReturns = cacheManager.getCache("stockReturns");
        if (stockReturns != null) {
            stockReturns.clear();
        }

        log.info("Cleared stock returns cache after daily update");
    }
}
```

---

## 7. 效能監控

### 7.1 監控指標

```java
@Component
public class RiskPerformanceMetrics {

    private final MeterRegistry registry;

    // VaR 計算時間
    private final Timer varCalculationTimer;

    // 壓力測試時間
    private final Timer stressTestTimer;

    // 快取命中率
    private final Counter cacheHits;
    private final Counter cacheMisses;

    public RiskPerformanceMetrics(MeterRegistry registry) {
        this.registry = registry;

        this.varCalculationTimer = Timer.builder("risk.var.calculation.time")
            .description("VaR calculation time")
            .tag("module", "M17")
            .register(registry);

        this.stressTestTimer = Timer.builder("risk.stress_test.time")
            .description("Stress test execution time")
            .tag("module", "M17")
            .register(registry);

        this.cacheHits = Counter.builder("risk.cache.hits")
            .tag("module", "M17")
            .register(registry);

        this.cacheMisses = Counter.builder("risk.cache.misses")
            .tag("module", "M17")
            .register(registry);
    }

    public void recordVarCalculation(String method, Duration duration) {
        Timer.builder("risk.var.calculation.time")
            .tag("method", method)
            .register(registry)
            .record(duration);
    }
}
```

### 7.2 效能告警

```yaml
alerts:
  - name: VaRCalculationSlow
    condition: histogram_quantile(0.95, risk_var_calculation_time) > 10
    severity: warning
    message: "VaR 計算時間超過 10 秒 (P95)"

  - name: CacheHitRateLow
    condition: rate(risk_cache_hits[5m]) / (rate(risk_cache_hits[5m]) + rate(risk_cache_misses[5m])) < 0.7
    severity: warning
    message: "風險模組快取命中率低於 70%"

  - name: RiskJobDurationHigh
    condition: job_m17_daily_risk_calculation_duration > 1800
    severity: warning
    message: "每日風險計算超過 30 分鐘"
```

---

## 8. 相關文檔

- [M17 功能需求](../specs/functional/M17-風險管理功能需求.md)
- [M17 業務流程](./M17-業務流程.md)
- [M17 Job 排程](../deployment/M17-Job排程配置.md)

---

**文件維護者**: 後端工程師
**最後更新**: 2026-01-15
**下次審核**: 2026-04-15
