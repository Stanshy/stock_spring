# M15-警報通知系統 效能考量

> **文件編號**: PERF-M15
> **模組名稱**: 警報通知系統 (Alert Notification System)
> **版本**: v1.0
> **最後更新**: 2026-01-15
> **狀態**: Draft

---

## 1. 效能目標

### 1.1 回應時間目標

| 操作類型 | 目標延遲 | P99 延遲 | 說明 |
|---------|---------|---------|------|
| 信號監控到警報觸發 | < 5 秒 | < 10 秒 | 內部處理延遲 |
| 警報到用戶收到通知 | < 30 秒 | < 60 秒 | 端到端延遲 |
| 規則 CRUD | < 200ms | < 500ms | API 回應 |
| 歷史查詢 | < 300ms | < 800ms | 分頁查詢 |
| 通知設定操作 | < 200ms | < 500ms | API 回應 |

### 1.2 吞吐量目標

| 指標 | 目標值 | 說明 |
|-----|-------|------|
| 每分鐘信號處理 | 2000 則 | 全市場信號 |
| 每分鐘警報觸發 | 5000 則 | 符合規則的警報 |
| 每分鐘通知發送 | 10000 則 | 含重複管道 |
| 並發規則比對 | 100 用戶/秒 | 規則引擎 |
| Email 發送 | 500 封/分鐘 | SMTP 限制 |
| Line 發送 | 1000 則/分鐘 | API 限制 |

---

## 2. 效能挑戰分析

### 2.1 核心瓶頸

```
┌─────────────────────────────────────────────────────────────────────┐
│                       M15 效能瓶頸分析                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 規則比對效能                                                     │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                                                               │   │
│  │  每則信號需要與所有啟用規則比對                                 │   │
│  │  - 信號數: ~2000 則/天                                        │   │
│  │  - 規則數: 可能達 10,000+ 條                                  │   │
│  │  - 比對次數: 2000 × 10000 = 2000 萬次/天                     │   │
│  │                                                               │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  2. 通知發送瓶頸                                                     │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                                                               │   │
│  │  - SMTP 限制: 每分鐘最多 500 封                               │   │
│  │  - Line API 限制: 每分鐘 1000 請求                            │   │
│  │  - FCM 限制: 批量發送，每批最多 500 裝置                      │   │
│  │  - 需要非同步處理 + 佇列緩衝                                  │   │
│  │                                                               │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  3. 資料庫壓力                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                                                               │   │
│  │  - 警報歷史: 每日新增 ~50,000 筆                              │   │
│  │  - 通知日誌: 每日新增 ~100,000 筆                             │   │
│  │  - 未讀計數: 高頻查詢                                         │   │
│  │                                                               │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 效能風險評估

| 風險 | 影響 | 機率 | 緩解策略 |
|-----|------|------|---------|
| 規則比對超時 | 高 | 中 | 規則索引、預過濾 |
| 通知佇列積壓 | 高 | 中 | 佇列監控、限流 |
| 資料庫連線耗盡 | 高 | 低 | 連線池調優 |
| 外部服務超時 | 中 | 中 | 超時設定、重試 |

---

## 3. 規則比對優化

### 3.1 規則索引策略

```java
@Service
public class OptimizedRuleMatchService {

    /**
     * 規則索引結構
     * Key: 股票代碼 → 適用的規則列表
     */
    private final Map<String, List<AlertRule>> stockRuleIndex = new ConcurrentHashMap<>();

    /**
     * 全市場規則（stockIds 為空的規則）
     */
    private final List<AlertRule> globalRules = new CopyOnWriteArrayList<>();

    /**
     * 建立規則索引
     */
    @PostConstruct
    @Scheduled(fixedRate = 60000)  // 每分鐘更新
    public void buildRuleIndex() {
        List<AlertRule> enabledRules = ruleRepository.findAllEnabled();

        // 清空舊索引
        stockRuleIndex.clear();
        globalRules.clear();

        for (AlertRule rule : enabledRules) {
            if (rule.getConditions().getStockIds() == null ||
                rule.getConditions().getStockIds().isEmpty()) {
                // 全市場規則
                globalRules.add(rule);
            } else {
                // 指定股票規則
                for (String stockId : rule.getConditions().getStockIds()) {
                    stockRuleIndex.computeIfAbsent(stockId, k -> new CopyOnWriteArrayList<>())
                        .add(rule);
                }
            }
        }

        log.info("規則索引建立完成: {} 個股票索引, {} 條全市場規則",
            stockRuleIndex.size(), globalRules.size());
    }

    /**
     * 快速取得適用規則
     */
    public List<AlertRule> getApplicableRules(String stockId) {
        List<AlertRule> applicable = new ArrayList<>();

        // 加入股票專用規則
        List<AlertRule> stockRules = stockRuleIndex.get(stockId);
        if (stockRules != null) {
            applicable.addAll(stockRules);
        }

        // 加入全市場規則
        applicable.addAll(globalRules);

        return applicable;
    }
}
```

### 3.2 規則預過濾

```java
@Service
public class RulePreFilterService {

    /**
     * 預過濾規則（快速排除不符合的規則）
     */
    public List<AlertRule> preFilter(UnifiedSignal signal, List<AlertRule> rules) {
        return rules.stream()
            .filter(rule -> preFilterByDirection(signal, rule))
            .filter(rule -> preFilterByGrade(signal, rule))
            .collect(Collectors.toList());
    }

    /**
     * 方向預過濾
     */
    private boolean preFilterByDirection(UnifiedSignal signal, AlertRule rule) {
        List<String> directions = rule.getConditions().getDirections();
        if (directions == null || directions.isEmpty()) {
            return true;  // 無方向限制
        }
        return directions.contains(signal.getUnifiedDirection());
    }

    /**
     * 評級預過濾（使用評級數值比較）
     */
    private boolean preFilterByGrade(UnifiedSignal signal, AlertRule rule) {
        String minGrade = rule.getConditions().getMinGrade();
        if (minGrade == null) {
            return true;  // 無評級限制
        }
        return gradeToValue(signal.getGrade()) >= gradeToValue(minGrade);
    }

    private int gradeToValue(String grade) {
        return switch (grade) {
            case "A+" -> 6;
            case "A" -> 5;
            case "B+" -> 4;
            case "B" -> 3;
            case "C" -> 2;
            case "D" -> 1;
            default -> 0;
        };
    }
}
```

---

## 4. 通知佇列架構

### 4.1 多層佇列設計

```
┌─────────────────────────────────────────────────────────────────────┐
│                       通知佇列架構                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    優先級佇列                                  │   │
│  │                                                               │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │   │
│  │  │   HIGH      │  │   NORMAL    │  │    LOW      │           │   │
│  │  │   Queue     │  │   Queue     │  │   Queue     │           │   │
│  │  │ (即時發送)  │  │ (標準處理)  │  │ (批次彙總)  │           │   │
│  │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘           │   │
│  │         │                │                │                   │   │
│  │         └────────────────┼────────────────┘                   │   │
│  │                          │                                    │   │
│  └──────────────────────────┼────────────────────────────────────┘   │
│                             │                                        │
│                             ▼                                        │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    管道佇列                                    │   │
│  │                                                               │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │   │
│  │  │   Email     │  │    Line     │  │    FCM      │           │   │
│  │  │   Queue     │  │   Queue     │  │   Queue     │           │   │
│  │  │ (500/min)   │  │ (1000/min)  │  │ (批量發送)  │           │   │
│  │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘           │   │
│  │         │                │                │                   │   │
│  └─────────┼────────────────┼────────────────┼───────────────────┘   │
│            │                │                │                       │
│            ▼                ▼                ▼                       │
│      ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│      │  SMTP    │    │  Line    │    │ Firebase │                   │
│      │  Server  │    │  API     │    │   FCM    │                   │
│      └──────────┘    └──────────┘    └──────────┘                   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 限流實作

```java
@Service
public class RateLimitedNotificationSender {

    // Email 限流器: 500/分鐘
    private final RateLimiter emailLimiter = RateLimiter.create(500.0 / 60);

    // Line 限流器: 1000/分鐘
    private final RateLimiter lineLimiter = RateLimiter.create(1000.0 / 60);

    @Async("notificationExecutor")
    public CompletableFuture<NotificationResult> sendWithRateLimit(
            NotificationRequest request) {

        RateLimiter limiter = getLimiter(request.getChannel());

        // 等待取得許可（最多等 10 秒）
        if (!limiter.tryAcquire(10, TimeUnit.SECONDS)) {
            return CompletableFuture.completedFuture(
                NotificationResult.rateLimited(request.getAlertId()));
        }

        // 實際發送
        return doSend(request);
    }

    private RateLimiter getLimiter(NotificationChannel channel) {
        return switch (channel) {
            case EMAIL -> emailLimiter;
            case LINE -> lineLimiter;
            case PUSH -> null;  // FCM 使用批量發送，無需單獨限流
        };
    }
}
```

### 4.3 非同步執行器配置

```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean("notificationExecutor")
    public TaskExecutor notificationExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("notification-");
        executor.setRejectedExecutionHandler(new CallerRunsPolicy());
        executor.initialize();
        return executor;
    }

    @Bean("emailExecutor")
    public TaskExecutor emailExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("email-");
        executor.initialize();
        return executor;
    }
}
```

---

## 5. 快取策略

### 5.1 快取架構

```
┌─────────────────────────────────────────────────────────────────────┐
│                       M15 快取架構                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    L1: 本地快取 (Caffeine)                     │   │
│  │  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐  │   │
│  │  │ 規則索引快取   │  │ 用戶設定快取   │  │ 範本快取       │  │   │
│  │  │ TTL: 1 分鐘   │  │ TTL: 5 分鐘   │  │ TTL: 1 小時   │  │   │
│  │  │ Size: 全量    │  │ Size: 10000   │  │ Size: 100     │  │   │
│  │  └────────────────┘  └────────────────┘  └────────────────┘  │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                │                                     │
│                                ▼                                     │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    L2: 分散式快取 (Redis)                      │   │
│  │  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐  │   │
│  │  │ 每日計數       │  │ 最後檢查時間   │  │ 節流狀態       │  │   │
│  │  │ TTL: 1 天     │  │ TTL: 5 分鐘   │  │ TTL: 1 小時   │  │   │
│  │  └────────────────┘  └────────────────┘  └────────────────┘  │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 快取實作

```java
@Service
public class AlertCacheService {

    // 用戶設定快取
    private final Cache<String, UserNotificationSettings> settingsCache =
        Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(Duration.ofMinutes(5))
            .build();

    // 每日計數快取 (Redis)
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private static final String DAILY_COUNT_PREFIX = "alert:daily:";

    /**
     * 取得用戶設定（帶快取）
     */
    public UserNotificationSettings getSettings(String userId) {
        return settingsCache.get(userId, key -> {
            return settingsRepository.findByUserId(key)
                .orElse(new UserNotificationSettings());
        });
    }

    /**
     * 取得並遞增每日計數
     */
    public int incrementDailyCount(String userId, NotificationChannel channel) {
        String key = DAILY_COUNT_PREFIX + userId + ":" + channel + ":" + LocalDate.now();

        Long count = redisTemplate.opsForValue().increment(key);

        // 設定過期時間（隔日凌晨）
        redisTemplate.expireAt(key, getEndOfDay());

        return count.intValue();
    }

    /**
     * 檢查是否超過每日限額
     */
    public boolean isExceededDailyLimit(String userId, NotificationChannel channel) {
        UserNotificationSettings settings = getSettings(userId);
        int limit = getDailyLimit(settings, channel);

        String key = DAILY_COUNT_PREFIX + userId + ":" + channel + ":" + LocalDate.now();
        Integer count = (Integer) redisTemplate.opsForValue().get(key);

        return count != null && count >= limit;
    }

    /**
     * 清除用戶設定快取
     */
    public void evictSettingsCache(String userId) {
        settingsCache.invalidate(userId);
    }
}
```

---

## 6. 批量處理優化

### 6.1 FCM 批量發送

```java
@Service
public class FcmBatchSender {

    @Autowired
    private FirebaseMessaging firebaseMessaging;

    private static final int MAX_BATCH_SIZE = 500;

    /**
     * 批量發送 Push 通知
     */
    public List<SendResponse> sendBatch(List<Message> messages) {
        List<SendResponse> results = new ArrayList<>();

        // 分批發送
        Lists.partition(messages, MAX_BATCH_SIZE).forEach(batch -> {
            try {
                BatchResponse response = firebaseMessaging.sendEach(batch);
                results.addAll(response.getResponses());

                log.info("FCM 批量發送: {} 則，成功 {} 則",
                    batch.size(), response.getSuccessCount());

            } catch (FirebaseMessagingException e) {
                log.error("FCM 批量發送失敗", e);
                // 標記全部失敗
                batch.forEach(m -> results.add(SendResponse.fromException(e)));
            }
        });

        return results;
    }

    /**
     * 建構批量訊息
     */
    public List<Message> buildBatchMessages(AlertHistory alert, List<UserDevice> devices) {
        String title = buildTitle(alert);
        String body = buildBody(alert);

        return devices.stream()
            .filter(UserDevice::getIsActive)
            .map(device -> Message.builder()
                .setToken(device.getFcmToken())
                .setNotification(Notification.builder()
                    .setTitle(title)
                    .setBody(body)
                    .build())
                .putData("alertId", alert.getAlertId())
                .putData("stockId", alert.getStockId())
                .build())
            .collect(Collectors.toList());
    }
}
```

### 6.2 批量資料庫操作

```java
@Repository
public interface NotificationLogRepository extends JpaRepository<NotificationLog, Long> {

    /**
     * 批量插入（使用 @Modifying + native query）
     */
    @Modifying
    @Query(value = """
        INSERT INTO notification_logs
        (log_id, alert_id, user_id, channel, status, recipient, message_preview, created_at)
        VALUES
        (:#{#log.logId}, :#{#log.alertId}, :#{#log.userId}, :#{#log.channel.name()},
         :#{#log.status.name()}, :#{#log.recipient}, :#{#log.messagePreview}, NOW())
        """, nativeQuery = true)
    void insertLog(@Param("log") NotificationLog log);

    /**
     * 批量更新狀態
     */
    @Modifying
    @Query("UPDATE NotificationLog l SET l.status = :status, l.sentAt = :now WHERE l.logId IN :logIds")
    int batchUpdateStatus(
        @Param("logIds") List<String> logIds,
        @Param("status") NotificationStatus status,
        @Param("now") OffsetDateTime now
    );
}
```

---

## 7. 效能監控指標

### 7.1 關鍵指標

```java
@Component
public class AlertMetrics {

    private final MeterRegistry registry;

    // 警報觸發延遲
    private final Timer alertTriggerLatency;

    // 通知發送延遲
    private final Timer notificationSendLatency;

    // 佇列大小
    private final AtomicInteger queueSize;

    // 通知成功/失敗計數
    private final Counter notificationSuccess;
    private final Counter notificationFailure;

    public AlertMetrics(MeterRegistry registry) {
        this.registry = registry;

        this.alertTriggerLatency = Timer.builder("m15.alert.trigger.latency")
            .description("警報觸發延遲")
            .register(registry);

        this.notificationSendLatency = Timer.builder("m15.notification.send.latency")
            .description("通知發送延遲")
            .tags("channel", "all")
            .register(registry);

        this.queueSize = registry.gauge("m15.notification.queue.size",
            new AtomicInteger(0));

        this.notificationSuccess = Counter.builder("m15.notification.success")
            .register(registry);

        this.notificationFailure = Counter.builder("m15.notification.failure")
            .register(registry);
    }

    public void recordAlertTrigger(Duration duration) {
        alertTriggerLatency.record(duration);
    }

    public void recordNotificationSend(String channel, Duration duration, boolean success) {
        Timer.builder("m15.notification.send.latency")
            .tag("channel", channel)
            .register(registry)
            .record(duration);

        if (success) {
            notificationSuccess.increment();
        } else {
            notificationFailure.increment();
        }
    }
}
```

### 7.2 告警閾值

| 指標 | 警告閾值 | 嚴重閾值 |
|-----|---------|---------|
| 警報觸發延遲 P99 | > 10s | > 30s |
| 通知發送延遲 P99 | > 30s | > 60s |
| 佇列大小 | > 1000 | > 5000 |
| 通知失敗率 | > 5% | > 10% |
| 每分鐘通知數 | > 8000 | > 10000 |

---

## 8. 容量規劃

### 8.1 資料量預估

| 資料表 | 每日新增 | 每月新增 | 保留期限 | 最大資料量 |
|-------|---------|---------|---------|-----------|
| alert_rules | 100 | 3,000 | 永久 | 50 萬筆 |
| alert_history | 50,000 | 150 萬 | 180 天 | 900 萬筆 |
| notification_logs | 100,000 | 300 萬 | 90 天 | 900 萬筆 |
| daily_counts | 10,000 | 30 萬 | 30 天 | 30 萬筆 |

### 8.2 資源需求

| 資源 | 最低配置 | 建議配置 | 說明 |
|-----|---------|---------|------|
| CPU | 2 核心 | 4 核心 | 非同步處理需求 |
| 記憶體 | 2 GB | 4 GB | 規則索引快取 |
| Redis | 512 MB | 1 GB | 快取 + 佇列 |
| 資料庫連線 | 20 | 50 | HikariCP |

---

## 9. 相關文檔

- [M15 功能需求](../specs/functional/M15-警報通知系統功能需求.md)
- [M15 資料庫設計](./M15-資料庫設計.md)
- [M15 Job 排程配置](../deployment/M15-Job排程配置.md)

---

**文件維護者**: 後端工程師
**最後更新**: 2026-01-15
**下次審核**: 2026-04-15
