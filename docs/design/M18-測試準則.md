# M18 投資組合管理 測試準則

## 文件資訊
| 項目 | 內容 |
|------|------|
| 模組代號 | M18 |
| 模組名稱 | 投資組合管理 Portfolio Management |
| 文件版本 | 1.0 |
| 建立日期 | 2026-01-15 |

---

## 測試策略總覽

| 測試類型 | 覆蓋範圍 | 目標覆蓋率 |
|---------|---------|-----------|
| 單元測試 | 計算邏輯、成本計算、報酬率 | > 90% |
| 整合測試 | 交易流程、快照產生、股利處理 | > 80% |
| API 測試 | REST 端點、回應格式、錯誤處理 | 100% |
| 效能測試 | 計算效能、API 延遲、批次處理 | 關鍵路徑 |

---

## 1. 單元測試

### 1.1 移動加權平均成本計算

```java
@ExtendWith(MockitoExtension.class)
class WeightedAverageCostCalculatorTest {

    private WeightedAverageCostCalculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new WeightedAverageCostCalculator();
    }

    @Test
    @DisplayName("首次買進 - 均價等於買入價")
    void calculateAvgCost_firstPurchase() {
        // Given
        BigDecimal existingShares = BigDecimal.ZERO;
        BigDecimal existingAvgCost = BigDecimal.ZERO;
        BigDecimal newShares = new BigDecimal("1000");
        BigDecimal newPrice = new BigDecimal("550.00");

        // When
        BigDecimal result = calculator.calculateNewAvgCost(
            existingShares, existingAvgCost, newShares, newPrice);

        // Then
        assertThat(result).isEqualByComparingTo("550.00");
    }

    @Test
    @DisplayName("加碼買進 - 計算加權平均")
    void calculateAvgCost_additionalPurchase() {
        // Given: 原持 1000 股，均價 550
        BigDecimal existingShares = new BigDecimal("1000");
        BigDecimal existingAvgCost = new BigDecimal("550.00");
        // 新買 500 股，價格 600
        BigDecimal newShares = new BigDecimal("500");
        BigDecimal newPrice = new BigDecimal("600.00");

        // When
        BigDecimal result = calculator.calculateNewAvgCost(
            existingShares, existingAvgCost, newShares, newPrice);

        // Then: (1000*550 + 500*600) / 1500 = 566.67
        assertThat(result).isEqualByComparingTo("566.6667");
    }

    @Test
    @DisplayName("多次加碼 - 累積計算正確")
    void calculateAvgCost_multiplePurchases() {
        // 模擬多次買進
        BigDecimal shares = BigDecimal.ZERO;
        BigDecimal avgCost = BigDecimal.ZERO;

        // 第一次: 買 1000 股 @ 500
        shares = new BigDecimal("1000");
        avgCost = calculator.calculateNewAvgCost(
            BigDecimal.ZERO, BigDecimal.ZERO, shares, new BigDecimal("500"));
        assertThat(avgCost).isEqualByComparingTo("500.00");

        // 第二次: 買 500 股 @ 550
        BigDecimal newAvg = calculator.calculateNewAvgCost(
            shares, avgCost, new BigDecimal("500"), new BigDecimal("550"));
        shares = shares.add(new BigDecimal("500"));
        avgCost = newAvg;
        // (1000*500 + 500*550) / 1500 = 516.67
        assertThat(avgCost).isEqualByComparingTo("516.6667");

        // 第三次: 買 500 股 @ 600
        newAvg = calculator.calculateNewAvgCost(
            shares, avgCost, new BigDecimal("500"), new BigDecimal("600"));
        shares = shares.add(new BigDecimal("500"));
        avgCost = newAvg;
        // (1500*516.67 + 500*600) / 2000 = 537.50
        assertThat(avgCost).isCloseTo(new BigDecimal("537.50"), within(new BigDecimal("0.01")));
    }

    @Test
    @DisplayName("賣出後均價不變")
    void calculateAvgCost_sellDoesNotChangeAvgCost() {
        // Given
        BigDecimal existingShares = new BigDecimal("1000");
        BigDecimal existingAvgCost = new BigDecimal("550.00");

        // When: 賣出 500 股
        BigDecimal remainingShares = existingShares.subtract(new BigDecimal("500"));

        // Then: 均價應維持不變
        assertThat(existingAvgCost).isEqualByComparingTo("550.00");
        assertThat(remainingShares).isEqualByComparingTo("500");
    }
}
```

### 1.2 FIFO 賣出損益計算

```java
@ExtendWith(MockitoExtension.class)
class FifoSellCalculatorTest {

    private FifoSellCalculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new FifoSellCalculator();
    }

    @Test
    @DisplayName("單一批次完全賣出")
    void calculateRealizedPnL_singleLotFullSell() {
        // Given
        List<PositionLot> lots = List.of(
            createLot("lot1", LocalDate.of(2025, 6, 15), bd("1000"), bd("500.00"))
        );

        // When: 賣出 1000 股 @ 600
        FifoResult result = calculator.calculate(lots, bd("1000"), bd("600.00"));

        // Then: 損益 = 1000 * (600 - 500) = 100,000
        assertThat(result.getRealizedPnL()).isEqualByComparingTo("100000");
        assertThat(result.getCostBasis()).isEqualByComparingTo("500000");
        assertThat(result.getAllocations()).hasSize(1);
        assertThat(result.getAllocations().get(0).getLot().getId()).isEqualTo("lot1");
    }

    @Test
    @DisplayName("跨批次 FIFO 賣出")
    void calculateRealizedPnL_multipleLotsFifo() {
        // Given: 兩批次
        // Lot1: 2025-06-15, 500 股 @ 480
        // Lot2: 2025-09-20, 500 股 @ 520
        List<PositionLot> lots = List.of(
            createLot("lot1", LocalDate.of(2025, 6, 15), bd("500"), bd("480.00")),
            createLot("lot2", LocalDate.of(2025, 9, 20), bd("500"), bd("520.00"))
        );

        // When: 賣出 700 股 @ 600
        FifoResult result = calculator.calculate(lots, bd("700"), bd("600.00"));

        // Then:
        // Lot1: 全部 500 股, 成本 240,000, 收益 300,000, 損益 60,000
        // Lot2: 200 股, 成本 104,000, 收益 120,000, 損益 16,000
        // 總損益 = 76,000
        assertThat(result.getRealizedPnL()).isEqualByComparingTo("76000");
        assertThat(result.getCostBasis()).isEqualByComparingTo("344000");
        assertThat(result.getAllocations()).hasSize(2);

        // 驗證 Lot1 完全賣出
        LotAllocation alloc1 = result.getAllocations().get(0);
        assertThat(alloc1.getShares()).isEqualByComparingTo("500");
        assertThat(alloc1.getLot().getRemainingShares()).isEqualByComparingTo("0");

        // 驗證 Lot2 部分賣出
        LotAllocation alloc2 = result.getAllocations().get(1);
        assertThat(alloc2.getShares()).isEqualByComparingTo("200");
        assertThat(alloc2.getLot().getRemainingShares()).isEqualByComparingTo("300");
    }

    @Test
    @DisplayName("賣出虧損情況")
    void calculateRealizedPnL_loss() {
        // Given
        List<PositionLot> lots = List.of(
            createLot("lot1", LocalDate.of(2025, 6, 15), bd("1000"), bd("600.00"))
        );

        // When: 賣出 1000 股 @ 550 (虧損)
        FifoResult result = calculator.calculate(lots, bd("1000"), bd("550.00"));

        // Then: 損益 = 1000 * (550 - 600) = -50,000
        assertThat(result.getRealizedPnL()).isEqualByComparingTo("-50000");
    }

    private PositionLot createLot(String id, LocalDate date, BigDecimal shares, BigDecimal cost) {
        PositionLot lot = new PositionLot();
        lot.setId(id);
        lot.setPurchaseDate(date);
        lot.setOriginalShares(shares);
        lot.setRemainingShares(shares);
        lot.setCostPerShare(cost);
        return lot;
    }

    private BigDecimal bd(String value) {
        return new BigDecimal(value);
    }
}
```

### 1.3 TWR 計算測試

```java
@ExtendWith(MockitoExtension.class)
class TwrCalculatorTest {

    private TwrCalculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new TwrCalculator();
    }

    @Test
    @DisplayName("無現金流的 TWR 計算")
    void calculateTwr_noCashFlow() {
        // Given: 三日快照
        List<Snapshot> snapshots = List.of(
            createSnapshot(LocalDate.of(2026, 1, 1), bd("1000000"), bd("0"), bd("0")),
            createSnapshot(LocalDate.of(2026, 1, 2), bd("1010000"), bd("0"), bd("0")),
            createSnapshot(LocalDate.of(2026, 1, 3), bd("1025100"), bd("0"), bd("0"))
        );

        // When
        BigDecimal twr = calculator.calculate(snapshots);

        // Then:
        // Day1->Day2: 1010000/1000000 - 1 = 1%
        // Day2->Day3: 1025100/1010000 - 1 = 1.5%
        // TWR = (1.01 * 1.015) - 1 = 2.515%
        assertThat(twr).isCloseTo(bd("0.02515"), within(bd("0.00001")));
    }

    @Test
    @DisplayName("有現金流入的 TWR 計算")
    void calculateTwr_withCashInflow() {
        // Given: 第二天存入 100,000
        List<Snapshot> snapshots = List.of(
            createSnapshot(LocalDate.of(2026, 1, 1), bd("1000000"), bd("0"), bd("0")),
            createSnapshot(LocalDate.of(2026, 1, 2), bd("1110000"), bd("100000"), bd("0")),
            createSnapshot(LocalDate.of(2026, 1, 3), bd("1132200"), bd("0"), bd("0"))
        );

        // When
        BigDecimal twr = calculator.calculate(snapshots);

        // Then:
        // Day1->Day2: (1110000 - 100000) / 1000000 - 1 = 1%
        // Day2->Day3: 1132200 / 1110000 - 1 = 2%
        // TWR = (1.01 * 1.02) - 1 = 3.02%
        assertThat(twr).isCloseTo(bd("0.0302"), within(bd("0.0001")));
    }

    @Test
    @DisplayName("有現金流出的 TWR 計算")
    void calculateTwr_withCashOutflow() {
        // Given: 第二天提領 100,000
        List<Snapshot> snapshots = List.of(
            createSnapshot(LocalDate.of(2026, 1, 1), bd("1000000"), bd("0"), bd("0")),
            createSnapshot(LocalDate.of(2026, 1, 2), bd("909000"), bd("0"), bd("100000")),
            createSnapshot(LocalDate.of(2026, 1, 3), bd("936270"), bd("0"), bd("0"))
        );

        // When
        BigDecimal twr = calculator.calculate(snapshots);

        // Then:
        // Day1->Day2: (909000 + 100000) / 1000000 - 1 = 0.9%
        // Day2->Day3: 936270 / 909000 - 1 = 3%
        // TWR = (1.009 * 1.03) - 1 = 3.927%
        assertThat(twr).isCloseTo(bd("0.03927"), within(bd("0.0001")));
    }

    @Test
    @DisplayName("負報酬的 TWR 計算")
    void calculateTwr_negativeReturn() {
        // Given
        List<Snapshot> snapshots = List.of(
            createSnapshot(LocalDate.of(2026, 1, 1), bd("1000000"), bd("0"), bd("0")),
            createSnapshot(LocalDate.of(2026, 1, 2), bd("980000"), bd("0"), bd("0")),
            createSnapshot(LocalDate.of(2026, 1, 3), bd("950600"), bd("0"), bd("0"))
        );

        // When
        BigDecimal twr = calculator.calculate(snapshots);

        // Then:
        // Day1->Day2: -2%
        // Day2->Day3: -3%
        // TWR = (0.98 * 0.97) - 1 = -5.06%
        assertThat(twr).isCloseTo(bd("-0.0506"), within(bd("0.0001")));
    }

    private Snapshot createSnapshot(LocalDate date, BigDecimal totalValue,
                                    BigDecimal inflow, BigDecimal outflow) {
        Snapshot snapshot = new Snapshot();
        snapshot.setSnapshotDate(date);
        snapshot.setTotalValue(totalValue);
        snapshot.setCashInflow(inflow);
        snapshot.setCashOutflow(outflow);
        return snapshot;
    }
}
```

### 1.4 MWR 計算測試

```java
class MwrCalculatorTest {

    private MwrCalculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new MwrCalculator();
    }

    @Test
    @DisplayName("無現金流的 MWR 等於簡單報酬率")
    void calculateMwr_noCashFlow() {
        // Given: 初始 100 萬，期末 120 萬，持有一年
        List<CashFlowPoint> cashFlows = List.of(
            new CashFlowPoint(LocalDate.of(2025, 1, 1), bd("-1000000")),
            new CashFlowPoint(LocalDate.of(2026, 1, 1), bd("1200000"))
        );

        // When
        BigDecimal mwr = calculator.calculate(cashFlows);

        // Then: MWR = 20%
        assertThat(mwr).isCloseTo(bd("0.20"), within(bd("0.001")));
    }

    @Test
    @DisplayName("有現金流入的 MWR 計算")
    void calculateMwr_withInflow() {
        // Given:
        // 初始 100 萬
        // 6 個月後追加 50 萬
        // 年末價值 165 萬
        List<CashFlowPoint> cashFlows = List.of(
            new CashFlowPoint(LocalDate.of(2025, 1, 1), bd("-1000000")),
            new CashFlowPoint(LocalDate.of(2025, 7, 1), bd("-500000")),
            new CashFlowPoint(LocalDate.of(2026, 1, 1), bd("1650000"))
        );

        // When
        BigDecimal mwr = calculator.calculate(cashFlows);

        // Then: MWR 約 10%（因為追加投資時機影響）
        assertThat(mwr).isBetween(bd("0.09"), bd("0.11"));
    }

    @Test
    @DisplayName("有現金流出的 MWR 計算")
    void calculateMwr_withOutflow() {
        // Given:
        // 初始 100 萬
        // 6 個月後提領 30 萬
        // 年末價值 80 萬
        List<CashFlowPoint> cashFlows = List.of(
            new CashFlowPoint(LocalDate.of(2025, 1, 1), bd("-1000000")),
            new CashFlowPoint(LocalDate.of(2025, 7, 1), bd("300000")),
            new CashFlowPoint(LocalDate.of(2026, 1, 1), bd("800000"))
        );

        // When
        BigDecimal mwr = calculator.calculate(cashFlows);

        // Then: MWR 約 12.5%
        assertThat(mwr).isBetween(bd("0.12"), bd("0.13"));
    }
}
```

### 1.5 Brinson 歸因測試

```java
class BrinsonAttributionCalculatorTest {

    private BrinsonAttributionCalculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new BrinsonAttributionCalculator();
    }

    @Test
    @DisplayName("Brinson 歸因三效果總和等於主動報酬")
    void brinsonAttribution_effectsSumToActiveReturn() {
        // Given
        List<SectorData> portfolio = List.of(
            new SectorData("半導體", bd("0.45"), bd("0.35")),
            new SectorData("金融", bd("0.30"), bd("0.10")),
            new SectorData("傳產", bd("0.25"), bd("0.05"))
        );

        List<SectorData> benchmark = List.of(
            new SectorData("半導體", bd("0.35"), bd("0.28")),
            new SectorData("金融", bd("0.35"), bd("0.12")),
            new SectorData("傳產", bd("0.30"), bd("0.08"))
        );

        BigDecimal benchmarkReturn = bd("0.16"); // 16%

        // When
        AttributionResult result = calculator.calculate(portfolio, benchmark, benchmarkReturn);

        // Then: 配置效果 + 選股效果 + 交互效果 = 主動報酬
        BigDecimal totalEffect = result.getAllocationEffect()
            .add(result.getSelectionEffect())
            .add(result.getInteractionEffect());

        BigDecimal activeReturn = result.getPortfolioReturn()
            .subtract(result.getBenchmarkReturn());

        assertThat(totalEffect).isCloseTo(activeReturn, within(bd("0.0001")));
    }

    @Test
    @DisplayName("純配置效果 - 權重不同但選股相同")
    void brinsonAttribution_pureAllocationEffect() {
        // Given: 投組與基準選股報酬相同，只有權重不同
        List<SectorData> portfolio = List.of(
            new SectorData("半導體", bd("0.60"), bd("0.30")),
            new SectorData("金融", bd("0.40"), bd("0.10"))
        );

        List<SectorData> benchmark = List.of(
            new SectorData("半導體", bd("0.50"), bd("0.30")),
            new SectorData("金融", bd("0.50"), bd("0.10"))
        );

        BigDecimal benchmarkReturn = bd("0.20");

        // When
        AttributionResult result = calculator.calculate(portfolio, benchmark, benchmarkReturn);

        // Then: 選股效果應該接近 0
        assertThat(result.getSelectionEffect()).isCloseTo(bd("0"), within(bd("0.001")));
        // 配置效果應該是正的（超配高報酬產業）
        assertThat(result.getAllocationEffect()).isPositive();
    }

    @Test
    @DisplayName("純選股效果 - 權重相同但選股不同")
    void brinsonAttribution_pureSelectionEffect() {
        // Given: 投組與基準權重相同，選股報酬不同
        List<SectorData> portfolio = List.of(
            new SectorData("半導體", bd("0.50"), bd("0.35")),
            new SectorData("金融", bd("0.50"), bd("0.15"))
        );

        List<SectorData> benchmark = List.of(
            new SectorData("半導體", bd("0.50"), bd("0.30")),
            new SectorData("金融", bd("0.50"), bd("0.10"))
        );

        BigDecimal benchmarkReturn = bd("0.20");

        // When
        AttributionResult result = calculator.calculate(portfolio, benchmark, benchmarkReturn);

        // Then: 配置效果應該是 0（權重相同）
        assertThat(result.getAllocationEffect()).isCloseTo(bd("0"), within(bd("0.001")));
        // 選股效果應該是正的（選股優於基準）
        assertThat(result.getSelectionEffect()).isPositive();
    }
}
```

---

## 2. 整合測試

### 2.1 交易流程整合測試

```java
@SpringBootTest
@Transactional
class TradeExecutionIntegrationTest {

    @Autowired
    private TradeService tradeService;

    @Autowired
    private PortfolioRepository portfolioRepository;

    @Autowired
    private PositionRepository positionRepository;

    @Autowired
    private TestEntityManager entityManager;

    private Portfolio testPortfolio;

    @BeforeEach
    void setUp() {
        testPortfolio = createTestPortfolio("1000000"); // 初始 100 萬
    }

    @Test
    @DisplayName("完整買進流程 - 建立持倉、扣減現金、建立批次")
    void executeBuy_fullFlow() {
        // Given
        TradeRequest request = TradeRequest.builder()
            .stockId("2330")
            .tradeDate(LocalDate.now())
            .tradeType(TradeType.BUY)
            .shares(bd("1000"))
            .price(bd("550.00"))
            .build();

        // When
        TradeResult result = tradeService.execute(testPortfolio.getId(), request);

        // Then
        assertThat(result.isSuccess()).isTrue();

        // 驗證交易記錄
        assertThat(result.getTrade().getNetAmount())
            .isCloseTo(bd("550780"), within(bd("100"))); // 含手續費

        // 驗證持倉建立
        Position position = positionRepository
            .findByPortfolioIdAndStockId(testPortfolio.getId(), "2330")
            .orElseThrow();
        assertThat(position.getShares()).isEqualByComparingTo("1000");
        assertThat(position.getAvgCost()).isEqualByComparingTo("550.00");

        // 驗證現金扣減
        entityManager.refresh(testPortfolio);
        assertThat(testPortfolio.getCashBalance())
            .isCloseTo(bd("449220"), within(bd("100")));
    }

    @Test
    @DisplayName("完整賣出流程 - 更新持倉、增加現金、計算損益")
    void executeSell_fullFlow() {
        // Given: 先買進
        tradeService.execute(testPortfolio.getId(), TradeRequest.builder()
            .stockId("2330")
            .tradeDate(LocalDate.now().minusDays(30))
            .tradeType(TradeType.BUY)
            .shares(bd("1000"))
            .price(bd("500.00"))
            .build());

        // When: 賣出
        TradeResult result = tradeService.execute(testPortfolio.getId(), TradeRequest.builder()
            .stockId("2330")
            .tradeDate(LocalDate.now())
            .tradeType(TradeType.SELL)
            .shares(bd("500"))
            .price(bd("600.00"))
            .build());

        // Then
        assertThat(result.isSuccess()).isTrue();

        // 驗證已實現損益
        // 損益 = 500 * (600 - 500) - 手續費 - 證交稅
        assertThat(result.getRealizedPnL()).isPositive();

        // 驗證持倉更新
        Position position = positionRepository
            .findByPortfolioIdAndStockId(testPortfolio.getId(), "2330")
            .orElseThrow();
        assertThat(position.getShares()).isEqualByComparingTo("500");

        // 驗證現金增加
        entityManager.refresh(testPortfolio);
        assertThat(testPortfolio.getCashBalance())
            .isGreaterThan(bd("500000"));
    }

    @Test
    @DisplayName("買進失敗 - 現金不足")
    void executeBuy_insufficientCash() {
        // Given: 嘗試買超過現金的金額
        TradeRequest request = TradeRequest.builder()
            .stockId("2330")
            .tradeDate(LocalDate.now())
            .tradeType(TradeType.BUY)
            .shares(bd("2000"))
            .price(bd("600.00"))
            .build();

        // When & Then
        assertThatThrownBy(() -> tradeService.execute(testPortfolio.getId(), request))
            .isInstanceOf(BusinessException.class)
            .hasMessageContaining("M18-004");
    }

    @Test
    @DisplayName("賣出失敗 - 持倉不足")
    void executeSell_insufficientPosition() {
        // Given: 先買少量
        tradeService.execute(testPortfolio.getId(), TradeRequest.builder()
            .stockId("2330")
            .tradeDate(LocalDate.now())
            .tradeType(TradeType.BUY)
            .shares(bd("100"))
            .price(bd("500.00"))
            .build());

        // When & Then: 嘗試賣出超過持倉
        assertThatThrownBy(() -> tradeService.execute(testPortfolio.getId(), TradeRequest.builder()
            .stockId("2330")
            .tradeDate(LocalDate.now())
            .tradeType(TradeType.SELL)
            .shares(bd("200"))
            .price(bd("550.00"))
            .build()))
            .isInstanceOf(BusinessException.class)
            .hasMessageContaining("M18-005");
    }
}
```

### 2.2 快照產生整合測試

```java
@SpringBootTest
@Transactional
class SnapshotGenerationIntegrationTest {

    @Autowired
    private SnapshotService snapshotService;

    @Autowired
    private PortfolioRepository portfolioRepository;

    @Autowired
    private SnapshotRepository snapshotRepository;

    @MockBean
    private StockPriceService stockPriceService;

    @Test
    @DisplayName("快照產生 - 正確計算市值與報酬")
    void generateSnapshot_correctCalculation() {
        // Given
        Portfolio portfolio = createPortfolioWithPositions();
        when(stockPriceService.getLatestPrice("2330")).thenReturn(bd("680.00"));
        when(stockPriceService.getLatestPrice("2317")).thenReturn(bd("115.00"));

        // When
        Snapshot snapshot = snapshotService.generateSnapshot(portfolio, LocalDate.now());

        // Then
        assertThat(snapshot).isNotNull();
        assertThat(snapshot.getTotalValue()).isPositive();
        assertThat(snapshot.getMarketValue()).isPositive();

        // 驗證持倉明細
        List<SnapshotPosition> positions = snapshotPositionRepository
            .findBySnapshotId(snapshot.getId());
        assertThat(positions).hasSize(2);
    }

    @Test
    @DisplayName("快照產生 - 計算當日報酬率")
    void generateSnapshot_calculateDailyReturn() {
        // Given: 建立前一日快照
        Portfolio portfolio = createPortfolioWithPositions();
        LocalDate yesterday = LocalDate.now().minusDays(1);
        LocalDate today = LocalDate.now();

        Snapshot prevSnapshot = new Snapshot();
        prevSnapshot.setPortfolioId(portfolio.getId());
        prevSnapshot.setSnapshotDate(yesterday);
        prevSnapshot.setTotalValue(bd("1000000"));
        snapshotRepository.save(prevSnapshot);

        when(stockPriceService.getLatestPrice(anyString())).thenReturn(bd("100.00"));

        // When
        Snapshot todaySnapshot = snapshotService.generateSnapshot(portfolio, today);

        // Then: 應該計算出當日報酬率
        assertThat(todaySnapshot.getDailyReturn()).isNotNull();
    }
}
```

### 2.3 股利處理整合測試

```java
@SpringBootTest
@Transactional
class DividendProcessingIntegrationTest {

    @Autowired
    private DividendService dividendService;

    @Autowired
    private PortfolioRepository portfolioRepository;

    @Autowired
    private DividendRepository dividendRepository;

    @Test
    @DisplayName("現金股利發放 - 增加現金餘額")
    void processCashDividend_increasesCash() {
        // Given
        Portfolio portfolio = createPortfolioWithPosition("2330", bd("1000"));
        BigDecimal initialCash = portfolio.getCashBalance();

        Dividend dividend = createPendingDividend(portfolio, "2330",
            DividendType.CASH, bd("3.50")); // 每股 3.5 元

        // When
        dividendService.processDividendPayment(dividend);

        // Then
        portfolioRepository.refresh(portfolio);
        BigDecimal expectedIncrease = bd("3500"); // 1000股 * 3.5
        assertThat(portfolio.getCashBalance())
            .isCloseTo(initialCash.add(expectedIncrease), within(bd("1")));

        assertThat(dividend.getStatus()).isEqualTo(DividendStatus.PAID);
    }

    @Test
    @DisplayName("股票股利發放 - 增加持股數量")
    void processStockDividend_increasesShares() {
        // Given
        Portfolio portfolio = createPortfolioWithPosition("2317", bd("1000"));
        Position position = positionRepository
            .findByPortfolioIdAndStockId(portfolio.getId(), "2317")
            .orElseThrow();
        BigDecimal initialShares = position.getShares();

        Dividend dividend = createPendingDividend(portfolio, "2317",
            DividendType.STOCK, bd("0.5")); // 每股配 0.5 股
        dividend.setSharesReceived(bd("500"));

        // When
        dividendService.processDividendPayment(dividend);

        // Then
        positionRepository.refresh(position);
        assertThat(position.getShares())
            .isEqualByComparingTo(initialShares.add(bd("500")));

        assertThat(dividend.getStatus()).isEqualTo(DividendStatus.RECEIVED);
    }
}
```

---

## 3. API 測試

### 3.1 投資組合 API 測試

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class PortfolioApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("POST /portfolios - 建立投資組合成功")
    void createPortfolio_success() throws Exception {
        // Given
        CreatePortfolioRequest request = CreatePortfolioRequest.builder()
            .name("測試投資組合")
            .description("API 測試用")
            .currency("TWD")
            .initialCash(bd("1000000"))
            .targetAllocations(List.of(
                new TargetAllocationDto("2330", bd("0.5"), bd("0.3"), bd("0.7")),
                new TargetAllocationDto("2317", bd("0.5"), bd("0.3"), bd("0.7"))
            ))
            .build();

        // When & Then
        mockMvc.perform(post("/api/v1/portfolios")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.code").value(201))
            .andExpect(jsonPath("$.data.id").exists())
            .andExpect(jsonPath("$.data.name").value("測試投資組合"))
            .andExpect(jsonPath("$.data.cashBalance").value(1000000));
    }

    @Test
    @DisplayName("POST /portfolios - 目標權重總和不為 1 時失敗")
    void createPortfolio_invalidWeights() throws Exception {
        // Given: 權重總和為 0.8
        CreatePortfolioRequest request = CreatePortfolioRequest.builder()
            .name("測試投資組合")
            .initialCash(bd("1000000"))
            .targetAllocations(List.of(
                new TargetAllocationDto("2330", bd("0.3"), null, null),
                new TargetAllocationDto("2317", bd("0.5"), null, null)
            ))
            .build();

        // When & Then
        mockMvc.perform(post("/api/v1/portfolios")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.code").value("M18-002"));
    }

    @Test
    @DisplayName("GET /portfolios/{id} - 查詢投資組合詳情")
    void getPortfolio_success() throws Exception {
        // Given
        String portfolioId = createTestPortfolio();

        // When & Then
        mockMvc.perform(get("/api/v1/portfolios/{id}", portfolioId))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.id").value(portfolioId))
            .andExpect(jsonPath("$.data.positions").isArray())
            .andExpect(jsonPath("$.data.targetAllocations").isArray());
    }

    @Test
    @DisplayName("GET /portfolios/{id} - 投資組合不存在時 404")
    void getPortfolio_notFound() throws Exception {
        mockMvc.perform(get("/api/v1/portfolios/{id}", "non-existent"))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.code").value("M18-006"));
    }
}
```

### 3.2 交易 API 測試

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class TradeApiTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("POST /portfolios/{id}/trades - 買進交易成功")
    void createBuyTrade_success() throws Exception {
        // Given
        String portfolioId = createTestPortfolio();
        TradeRequest request = TradeRequest.builder()
            .stockId("2330")
            .tradeDate(LocalDate.now())
            .type(TradeType.BUY)
            .shares(bd("100"))
            .price(bd("550.00"))
            .build();

        // When & Then
        mockMvc.perform(post("/api/v1/portfolios/{id}/trades", portfolioId)
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.data.tradeId").exists())
            .andExpect(jsonPath("$.data.type").value("BUY"))
            .andExpect(jsonPath("$.data.position.newShares").value(100));
    }

    @Test
    @DisplayName("GET /portfolios/{id}/trades - 查詢交易記錄")
    void getTrades_withPagination() throws Exception {
        // Given
        String portfolioId = createPortfolioWithTrades();

        // When & Then
        mockMvc.perform(get("/api/v1/portfolios/{id}/trades", portfolioId)
                .param("page", "0")
                .param("size", "10"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.content").isArray())
            .andExpect(jsonPath("$.data.totalElements").isNumber())
            .andExpect(jsonPath("$.data.summary.totalBuys").isNumber());
    }
}
```

### 3.3 績效 API 測試

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class PerformanceApiTest {

    @Test
    @DisplayName("GET /portfolios/{id}/performance - 查詢績效指標")
    void getPerformance_success() throws Exception {
        // Given
        String portfolioId = createPortfolioWithHistory();

        // When & Then
        mockMvc.perform(get("/api/v1/portfolios/{id}/performance", portfolioId)
                .param("period", "YTD"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.returns.twr").isNumber())
            .andExpect(jsonPath("$.data.returns.mwr").isNumber())
            .andExpect(jsonPath("$.data.riskMetrics.sharpeRatio").isNumber())
            .andExpect(jsonPath("$.data.comparison.benchmarkReturn").isNumber());
    }

    @Test
    @DisplayName("GET /portfolios/{id}/attribution - 查詢績效歸因")
    void getAttribution_success() throws Exception {
        // Given
        String portfolioId = createPortfolioWithHistory();

        // When & Then
        mockMvc.perform(get("/api/v1/portfolios/{id}/attribution", portfolioId)
                .param("startDate", "2025-01-01")
                .param("endDate", "2025-12-31"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.attribution.allocationEffect").isNumber())
            .andExpect(jsonPath("$.data.attribution.selectionEffect").isNumber())
            .andExpect(jsonPath("$.data.sectorAttribution").isArray());
    }
}
```

---

## 4. 效能測試

### 4.1 績效計算效能測試

```java
@SpringBootTest
class PerformanceCalculationLoadTest {

    @Autowired
    private PerformanceService performanceService;

    @Test
    @DisplayName("TWR 計算 - 一年資料應在 100ms 內完成")
    void calculateTwr_oneYear_performanceTest() {
        // Given
        String portfolioId = createPortfolioWithOneYearData();

        // When
        long startTime = System.currentTimeMillis();
        performanceService.calculateTWR(portfolioId,
            LocalDate.now().minusYears(1), LocalDate.now());
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(100);
    }

    @Test
    @DisplayName("批次快照產生 - 1000 個投組應在 5 分鐘內完成")
    void generateSnapshots_batch_performanceTest() {
        // Given
        List<Portfolio> portfolios = create1000Portfolios();

        // When
        long startTime = System.currentTimeMillis();
        snapshotService.generateSnapshotsParallel(portfolios, LocalDate.now());
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(300000); // 5 分鐘
    }

    @Test
    @DisplayName("Brinson 歸因 - 應在 500ms 內完成")
    void calculateBrinsonAttribution_performanceTest() {
        // Given
        String portfolioId = createPortfolioWithSectorData();

        // When
        long startTime = System.currentTimeMillis();
        attributionService.calculateBrinsonAttribution(portfolioId,
            LocalDate.now().minusYears(1), LocalDate.now());
        long duration = System.currentTimeMillis() - startTime;

        // Then
        assertThat(duration).isLessThan(500);
    }
}
```

### 4.2 API 延遲測試

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ApiLatencyTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    @DisplayName("投組查詢 API P95 延遲應低於 200ms")
    void getPortfolio_latencyTest() {
        // Given
        String portfolioId = createTestPortfolio();
        List<Long> latencies = new ArrayList<>();

        // When: 執行 100 次請求
        for (int i = 0; i < 100; i++) {
            long start = System.nanoTime();
            restTemplate.getForEntity(
                "/api/v1/portfolios/" + portfolioId, String.class);
            long duration = (System.nanoTime() - start) / 1_000_000;
            latencies.add(duration);
        }

        // Then: 計算 P95
        Collections.sort(latencies);
        long p95 = latencies.get(94);
        assertThat(p95).isLessThan(200);
    }

    @Test
    @DisplayName("持倉查詢 API 併發測試")
    void getPositions_concurrencyTest() throws Exception {
        // Given
        String portfolioId = createPortfolioWithManyPositions();
        int concurrentRequests = 50;

        ExecutorService executor = Executors.newFixedThreadPool(10);
        CountDownLatch latch = new CountDownLatch(concurrentRequests);
        AtomicInteger successCount = new AtomicInteger(0);

        // When
        for (int i = 0; i < concurrentRequests; i++) {
            executor.submit(() -> {
                try {
                    ResponseEntity<String> response = restTemplate.getForEntity(
                        "/api/v1/portfolios/" + portfolioId + "/positions",
                        String.class);
                    if (response.getStatusCode().is2xxSuccessful()) {
                        successCount.incrementAndGet();
                    }
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await(30, TimeUnit.SECONDS);

        // Then
        assertThat(successCount.get()).isEqualTo(concurrentRequests);
    }
}
```

---

## 測試資料準備

### 測試資料建構器

```java
public class PortfolioTestDataBuilder {

    public static Portfolio createPortfolio(String initialCash) {
        Portfolio portfolio = new Portfolio();
        portfolio.setId(UUID.randomUUID().toString().substring(0, 8));
        portfolio.setName("Test Portfolio");
        portfolio.setCurrency("TWD");
        portfolio.setInitialCash(new BigDecimal(initialCash));
        portfolio.setCashBalance(new BigDecimal(initialCash));
        portfolio.setTotalValue(new BigDecimal(initialCash));
        portfolio.setStatus(PortfolioStatus.ACTIVE);
        return portfolio;
    }

    public static Position createPosition(String stockId, String shares, String avgCost) {
        Position position = new Position();
        position.setId(UUID.randomUUID().toString().substring(0, 8));
        position.setStockId(stockId);
        position.setShares(new BigDecimal(shares));
        position.setAvgCost(new BigDecimal(avgCost));
        position.setTotalCost(position.getShares().multiply(position.getAvgCost()));
        return position;
    }

    public static List<Snapshot> createSnapshotSequence(
            String portfolioId, int days, BigDecimal startValue, BigDecimal dailyReturn) {

        List<Snapshot> snapshots = new ArrayList<>();
        BigDecimal value = startValue;

        for (int i = 0; i < days; i++) {
            Snapshot snapshot = new Snapshot();
            snapshot.setPortfolioId(portfolioId);
            snapshot.setSnapshotDate(LocalDate.now().minusDays(days - i));
            snapshot.setTotalValue(value);
            snapshot.setCashInflow(BigDecimal.ZERO);
            snapshot.setCashOutflow(BigDecimal.ZERO);

            if (i > 0) {
                snapshot.setDailyReturn(dailyReturn);
            }

            snapshots.add(snapshot);
            value = value.multiply(BigDecimal.ONE.add(dailyReturn));
        }

        return snapshots;
    }
}
```

---

## 測試覆蓋率目標

| 模組 | 行覆蓋率 | 分支覆蓋率 |
|------|---------|-----------|
| 計算邏輯 (calculator) | > 95% | > 90% |
| 服務層 (service) | > 85% | > 80% |
| 控制器 (controller) | > 80% | > 75% |
| Repository | > 70% | > 65% |

```xml
<!-- pom.xml JaCoCo 配置 -->
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <configuration>
        <rules>
            <rule>
                <element>PACKAGE</element>
                <includes>
                    <include>com.chris.fin_shark.m18.calculator</include>
                </includes>
                <limits>
                    <limit>
                        <counter>LINE</counter>
                        <minimum>0.95</minimum>
                    </limit>
                </limits>
            </rule>
        </rules>
    </configuration>
</plugin>
```
